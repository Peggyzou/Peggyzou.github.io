<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>git | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介git是一个免费开源的版本控制系统，有效管理项目开发的源码。解决的问题：  开发中代码会存在多个版本，将代码在多个版本之间进行切换 在不影响现行开发工作的情况下对代码进行维护 开发时，某段代码被多人修改时，处理代码的冲突问题  分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓">
<meta property="og:type" content="article">
<meta property="og:title" content="git">
<meta property="og:url" content="http://example.com/2023/02/25/git/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="简介git是一个免费开源的版本控制系统，有效管理项目开发的源码。解决的问题：  开发中代码会存在多个版本，将代码在多个版本之间进行切换 在不影响现行开发工作的情况下对代码进行维护 开发时，某段代码被多人修改时，处理代码的冲突问题  分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/02/25/git/1.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/2.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/5.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/3.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/4.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/6.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/7.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/8.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/9.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/10.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/11.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/12.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/13.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/14.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/15.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/18.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/19.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/20.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/21.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/16.png">
<meta property="og:image" content="http://example.com/2023/02/25/git/17.png">
<meta property="article:published_time" content="2023-02-25T14:01:56.000Z">
<meta property="article:modified_time" content="2023-05-30T09:09:42.957Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/25/git/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/25/git/" class="article-date">
  <time datetime="2023-02-25T14:01:56.000Z" itemprop="datePublished">2023-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      git
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p>
<ul>
<li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li>
<li>在不影响现行开发工作的情况下对代码进行维护</li>
<li>开发时，某段代码被多人修改时，处理代码的冲突问题</li>
</ul>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。<img src="1.png" alt="1682601512635"></p>
<p>远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p>
<p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p>
<h2 id="下载和配置"><a href="#下载和配置" class="headerlink" title="下载和配置"></a>下载和配置</h2><p><a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a>无脑下载</p>
<p>下载Git后，首先要配置个人用户名称和电子邮件地址。这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global [user.name]</span><br><span class="line">git config --global [user.email]</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>被git管理的文件有三种状态：</p>
<ul>
<li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li>
<li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li>
<li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li>
</ul>
<p>可以通过git status查看文件的状态</p>
<p>新添加的文件处于未跟踪状态（未被git管理）:</p>
<ul>
<li>未跟踪-&gt;暂存：git add <code>&lt;filename&gt;</code></li>
<li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li>
<li>未修改-&gt;修改：修改代码后，转为修改状态</li>
<li>修改-&gt;暂存：git add <code>&lt;filename&gt;</code></li>
</ul>
<p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p>
<h2 id="将文件提交至远程仓库："><a href="#将文件提交至远程仓库：" class="headerlink" title="将文件提交至远程仓库："></a>将文件提交至远程仓库：</h2><ol>
<li>在总文件夹中右键选择 <code>git bash here</code>，初始化git。</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>连接远程仓库</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin &quot;仓库地址&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add &quot;文件名&quot;/git add *  把工作区某个文件提交至暂存区/把工作区所有文件提交至暂存区</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;版本名&quot;  把暂存区文件提交至本地仓库</span><br><span class="line"></span><br><span class="line">$ git push origin master  把本地仓库的文件推送到远程仓库的某一分支上</span><br></pre></td></tr></table></figure>

<h2 id="从远程仓库下载文件：fork、clone"><a href="#从远程仓库下载文件：fork、clone" class="headerlink" title="从远程仓库下载文件：fork、clone"></a>从远程仓库下载文件：fork、clone</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork包含了原来的仓库所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行 <code>clone</code>命令后，会在当前目录下创建一个名为 <code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h3 id="使用fork和clone"><a href="#使用fork和clone" class="headerlink" title="使用fork和clone"></a>使用fork和clone</h3><p>当你在 <code>github</code>发现感兴趣开源项目的时候，可以通过点击 <code>github</code>仓库中右上角 <code>fork</code>标识的按钮，如下图：</p>
<p><img src="2.png" alt="1682602188024"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的 <code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过 <code>git clone</code>对你这个复制的远程仓库进行克隆,在 <code>github</code>中，开源项目右侧存在 <code>code</code>按钮，点击后则会显示开源项目 <code>url</code>信息，如下图所示：通过 <code>git clone xxx</code>则能完成远程项目的下载</p>
<p><img src="5.png" alt="1682602404998"></p>
<p>后续更改任何东西都可以在本地完成，如 <code>git add</code>、<code>git commit</code>一系列的操作，然后通过 <code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送 <code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="3.png" alt="1682602282691"></p>
<p>整体流程如下图：</p>
<p><img src="4.png" alt="1682602320048"></p>
<p>fork和clone的区别</p>
<h3 id="其三者区别如下："><a href="#其三者区别如下：" class="headerlink" title="其三者区别如下："></a>其三者区别如下：</h3><ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
</ul>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p><code>git</code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="6.png" alt="1682603560111"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的 <code>git</code>命令</p>
<h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>一个 <code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h4 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h4><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p>
<ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h4 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h4><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而 <code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的 <code>git</code>文件中对应也存储了 <code>git</code>本地仓库分支的 <code>commit ID</code>和 跟踪的远程分支的 <code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git/refs/head/[本地分支]</li>
<li>.git/refs/remotes/[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中 <code>master</code>的 <code>commitID</code>不变</p>
<p>但是与 <code>git</code>上面关联的那个 <code>orign/master</code>的 <code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过 <code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="7.png" alt="1682604231981"></p>
<p>也就是 <code>fetch</code>的时候本地的 <code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地 <code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用 <code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="8.png" alt="1682604272380"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到 <code>git pull</code>或者 <code>git fetch</code>命令</p>
<p><strong>fetch</strong></p>
<p>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>例如从远程的 <code>origin</code>仓库的 <code>master</code>分支下载代码到本地并新建一个 <code>temp</code>分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br></pre></td></tr></table></figure>

<p>如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来到本地当前分支</p>
<p>这里 <code>git fetch</code>不会进行合并，执行后需要手动执行 <code>git merge</code>合并，如下：</p>
<p><strong>pull</strong></p>
<p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>例如将远程主机 <code>origin</code>的 <code>master</code>分支拉取过来，与本地的 <code>branchtest</code>分支合并，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure>

<p>同样如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来与本地当前分支合并</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h2 id="git-rebase-和-git-merge"><a href="#git-rebase-和-git-merge" class="headerlink" title="git rebase 和 git merge"></a>git rebase 和 git merge</h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p><strong>git merge</strong></p>
<p>将当前分支合并到指定分支，命令用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure>

<p>通过 <code>git merge</code>将当前分支与 <code>xxx</code>分支合并，产生的新的 <code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从 <code>master</code>分支分叉出来的，如下所示：</p>
<p><img src="9.png" alt="1682604971963"></p>
<p>合并 <code>bugfix</code>分支到 <code>master</code>分支时，如果 <code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含 <code>master</code>分支所有的历史记录</p>
<p>所以通过把 <code>master</code>分支的位置移动到 <code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果 <code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="10.png" alt="1682605021939"></p>
<p>这时候使用 <code>git merge</code>的时候，会生成一个新的提交，并且 <code>master</code>分支的 <code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="11.png" alt="1682605062943"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<p><strong>git rebase（变基）</strong></p>
<p>将当前分支移植到指定分支或指定 <code>commit</code>之上，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>同样，<code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="12.png" alt="1682605154719"></p>
<p>通过 <code>git rebase</code>，会变成如下情况：</p>
<p><img src="13.png" alt="1682605189602"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="14.png" alt="1682605269640"></p>
<p><code>rebase</code>之后，<code>master</code>的 <code>HEAD</code>位置不变。因此，要合并 <code>master</code>分支和 <code>bugfix</code>分支</p>
<p><img src="15.png" alt="1682605347300"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的 <code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交 <code>X</code>和 <code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置 <code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>从上面可以看到，<code>merge</code>和 <code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<p><strong>merge</strong></p>
<p>通过 <code>merge</code>合并分支会新增一个 <code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<p><strong>rebase</strong></p>
<p><code>rebase</code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 <code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把 <code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<p><strong>冲突如何产生？</strong></p>
<p>所谓冲突就是两个开发者对同一个文件同一个位置做出了不同内容的修改，因此就产生了冲突。</p>
<p>一般冲突的产生发生在两个分支进行合并时或者是从远程仓库拉取代码到本地时。</p>
<p>但是归根结底，冲突产生的原因还是：对同一个文件同一个位置做出了不同内容的修改。从而导致冲突发生。</p>
<p><strong>比如：master 分支和 hot-fix 分支上都修改了代码</strong>， 那么在合并分支的时候就会发生冲突。</p>
<p><code>【第一步】在 hot-fix 分支上增加如下代码，并且提交。</code></p>
<p><img src="18.png" alt="1685437407135"></p>
<p><code>【第二步】在master 分支上同样的地方增加如下代码，并且提交。</code></p>
<p><img src="19.png" alt="1685437413727"></p>
<p><code>【第三步】 我们现在站在 master 分支上合并 hot-fix 分支， 就会发生代码冲突。</code></p>
<p><code>【第四步】手动解决冲突，合并代码。</code></p>
<p><img src="20.png" alt="1685437533173"></p>
<p>代码冲突就解决了， 提交本地库，查看修改结果：</p>
<p><img src="21.png" alt="1685437711486"></p>
<h2 id="git-reset-和-git-revert"><a href="#git-reset-和-git-revert" class="headerlink" title="git reset 和 git revert"></a>git reset 和 git revert</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="16.png" alt="1682605761698"></p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><img src="17.png" alt="1682605793002"></p>
<h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用 <code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用 <code>git reset</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/25/git/" data-id="clm52imvv000cc4wpgnbxb4xm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          que
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" rel="tag">商城项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">组件化、模块化、工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">网络基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" rel="tag">网络攻击</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/ts/" style="font-size: 10px;">ts</a> <a href="/tags/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">商城项目</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">框架</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 10px;">组件化、模块化、工程化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">网络基础</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" style="font-size: 10px;">网络攻击</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/">浏览器渲染</a>
          </li>
        
          <li>
            <a href="/2023/08/13/typescript/">typescript</a>
          </li>
        
          <li>
            <a href="/2023/06/02/MongoDB/">MongoDB</a>
          </li>
        
          <li>
            <a href="/2023/06/02/express%E6%A1%86%E6%9E%B6/">express框架</a>
          </li>
        
          <li>
            <a href="/2023/06/02/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/">会话控制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>