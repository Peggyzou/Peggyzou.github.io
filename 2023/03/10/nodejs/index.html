<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>nodejs | 海底世界</title><meta name="author" content="柯"><meta name="copyright" content="柯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="nodejs文档 线程和进程 进程（厂房）：程序运行的环境 线程（工人）：实行进行运算的东西  同步同步通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。 解决同步java、python 通过多线程来解决，成本高 node.js 通过异步方式解决 异步：一段代码的执行不会影响其它代码  异步的问题：无法通过">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs">
<meta property="og:url" content="http://example.com/2023/03/10/nodejs/index.html">
<meta property="og:site_name" content="海底世界">
<meta property="og:description" content="nodejs文档 线程和进程 进程（厂房）：程序运行的环境 线程（工人）：实行进行运算的东西  同步同步通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。 解决同步java、python 通过多线程来解决，成本高 node.js 通过异步方式解决 异步：一段代码的执行不会影响其它代码  异步的问题：无法通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/18.png">
<meta property="article:published_time" content="2023-03-10T14:02:39.000Z">
<meta property="article:modified_time" content="2023-09-05T14:03:07.382Z">
<meta property="article:author" content="柯">
<meta property="article:tag" content="node">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/18.png"><link rel="shortcut icon" href="/imgs/favicon.png"><link rel="canonical" href="http://example.com/2023/03/10/nodejs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":120},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nodejs',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-05 22:03:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/avatar.png" onerror="onerror=null;src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/imgs/18.png')"><nav id="nav"><span id="blog-info"><a href="/" title="海底世界"><span class="site-name">海底世界</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nodejs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-10T14:02:39.000Z" title="发表于 2023-03-10 22:02:39">2023-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-05T14:03:07.382Z" title="更新于 2023-09-05 22:03:07">2023-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nodejs"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://nodejs.dev/en/">nodejs文档</a></p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul>
<li>进程（厂房）：程序运行的环境</li>
<li>线程（工人）：实行进行运算的东西</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p>
<h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python 通过多线程来解决，成本高</p>
<p>node.js 通过异步方式解决</p>
<p>异步：一段代码的执行不会影响其它代码</p>
<ul>
<li>异步的问题：无法通过return设置返回值</li>
<li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li>
</ul>
<p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）</p>
<p>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p>
<ul>
<li>创建promise时，构造函数中需要一个函数作为参数。</li>
<li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li>
<li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li>
<li>通过promise的实例方法then来读取promise中存储的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise中的数据&quot;</span>,result)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据&quot;</span>,reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul>
<li>catch()用法和then类似，但是只需要一个回调函数作为参数</li>
<li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul>
<li>finally()无论是正常存储还是出现异常了，都会执行</li>
<li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li>
</ul>
<h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><ul>
<li>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）</li>
<li>finally的返回值不会存到新的promise中</li>
</ul>
<h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p>
<ul>
<li>PromiseResult: 用来存储数据</li>
<li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p>
<h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">7</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">8</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p>
<h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul>
<li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.reject() 创建一个立即拒绝的promise</li>
<li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>),<span class="title function_">sum</span>(<span class="number">5</span>,<span class="number">6</span>),<span class="title function_">sum</span>(<span class="number">3</span>,<span class="number">4</span>)])</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li>
<li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li>
<li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li>
</ul>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p>
<p>调用栈：</p>
<ul>
<li>栈是一种数据结构，先进后出</li>
<li>调用栈中放的是要执行的代码<br>任务队列</li>
<li>队列是一种数据结构，先进先出</li>
<li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li>
</ul>
<p>JS中任务队列有两种</p>
<ul>
<li>宏任务队列（大部分代码都去宏任务队列中去排队）</li>
<li>微任务队列（Promise的回调函数（then、catch、finally））</li>
</ul>
<p>整个流程：</p>
<ol>
<li>执行调用栈中的代码</li>
<li>执行微任务队列中的任务</li>
<li>执行宏任务队列中的任务</li>
</ol>
<p>queueMicrotask()用来向微任务队列中添加一个任务</p>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">111</span>,<span class="number">222</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br></pre></td></tr></table></figure>

<p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(a+b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4,33,1,2,3</span></span><br></pre></td></tr></table></figure>

<p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p>
<p>注意以下代码的运行顺序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(a+b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出1,2,3</span></span><br></pre></td></tr></table></figure>

<p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出1,2,4,3</span></span><br></pre></td></tr></table></figure>

<h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p>
<ol>
<li>无法选择要引入模块的哪些内容</li>
<li>在复杂的场景下容易出错</li>
</ol>
<p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p>
<ul>
<li>使用require（“模块的路径”）函数引入模块</li>
<li>引入自定义模块时，模块名要以./或者../开头</li>
<li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li>
</ul>
<p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p>
<p>访问exports的方式有着两种：</p>
<ul>
<li>exports</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>module.exports</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p>
<h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p>
<ul>
<li>使用.mjs作为扩展名</li>
<li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li>
</ul>
<p>向外部导出内容：export</p>
<p>导入内容：</p>
<ul>
<li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li>
</ul>
<p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p>
<p>导入：</p>
<ul>
<li>import 变量名 from “url” 变量名可以随意命名</li>
</ul>
<p>es模块都运行在严格模式下</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p>
<p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p>
<ul>
<li>process.exit()  结束当前进程</li>
<li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span> (<span class="string">&quot;process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4、3、2、1</span></span><br></pre></td></tr></table></figure>

<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p>
<p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p>
<p>工作目录不同，所产生的绝对路径也就不同</p>
<p>最终形态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./05.promise.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure>

<h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p>
<ul>
<li>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</li>
<li>fs.readFile()，异步的文件读取方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(</span><br><span class="line">    path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>),</span><br><span class="line">    <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>主流用法：promise版本的fs</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs/promises&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">&#125;,)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p>
<p>npm init 初始化项目，创建package.json文件（需要回答问题）</p>
<p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p>
<p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p>
<ul>
<li>将包下载到当前项目的node_modules目录下</li>
<li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li>
<li>会自动添加package-lock.json文件：加速npm下载的，不用动</li>
</ul>
<p>npm i 自动安装所有依赖</p>
<p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p>
<p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p>
<p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p>
<p>镜像的配置：</p>
<ul>
<li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a target="_blank" rel="noopener" href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li>
<li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li>
</ul>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p>
<p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p>
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/1500126264">b站</a></p>
<p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p>
<p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p>
<h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p>
<p>第二步中客户端如何和服务器建立（断开）连接</p>
<p>答：<br>三次握手（建立连接）</p>
<ul>
<li>客户端发送请求连接（SYN:同步）</li>
<li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li>
<li>客户端向服务器发送同意连接的信息（ACK：同意）</li>
</ul>
<p>四次挥手（断开连接）</p>
<ul>
<li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li>
<li>服务器向客户端返回数据，知道了（ACK）</li>
<li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li>
<li>客户端向服务器发数据，可以断开了（ACK）</li>
</ul>
<p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p>
<p>TCP/IP协议族：规定了互联网中所有的通信细节</p>
<p>网络通信的过程由四层组成</p>
<ul>
<li>应用层<br>软件层面，浏览器、服务器都属于应用层</li>
<li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li>
<li>网络层<br>负责给数据包，添加信息</li>
<li>数据链路层<br>传输信息</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的（请求字符串是明文，不安全）</p>
<h3 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h3><p>客户端发送给服务器的报文称为请求报文</p>
<p>请求报文的格式：</p>
<ul>
<li>请求首行<br>第一部分  get/post：get请求主要用来向服务器请求资源，没有请求体，键值对为明文，安全性差，且不能发送较大的数据；post请求主要用来向服务器发送数据，post请求有请求体，无法在地址栏直接查看，安全性较好，请求体大小没有限制，可以发送任意大小的数据，所以尽量用post发送请求<br>第二部分  请求资源的路径，多个名值对用&amp;连接<br>第三部分  http协议版本</li>
<li>请求头<br>请求头也是名值对结构，用来告诉服务器我们浏览器的信息（浏览器可以接受的文件类型、浏览器允许的压缩的编码、浏览器的信息）</li>
<li>空行<br>用来分隔请求头和请求头</li>
<li>请求体<br>post请求直接通过请求体发送数据</li>
</ul>
<h3 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h3><p>服务器发送给客户端的报文称为请求报文</p>
<ul>
<li><p>响应首行<br>第一部分  http协议版本<br>第二部分  响应状态码<br>响应状态码的规则：</p>
<ul>
<li>1xx  请求处理中</li>
<li>2xx  请求成功</li>
<li>3xx  请求重定向</li>
<li>4xx  客户端错误</li>
<li>5xx  服务器错误<br>第三部分  对响应状态码的描述</li>
</ul>
</li>
<li><p>响应头<br>也是名值对结构，告诉浏览器响应的信息（响应体的类型、大小等）</p>
</li>
<li><p>空行<br>分隔响应头和响应体</p>
</li>
<li><p>响应体<br>服务器返回给客户端的内容</p>
</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>express是node中的服务器软件，通过express可以快速在node中搭建一个web服务器</p>
<p>使用步骤：</p>
<ol>
<li>创建并初始化项目：npm init -y</li>
<li>安装express: npm add express</li>
<li>创建index.js编写代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="comment">// 获取服务器的实例（一起皆对象）</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// &quot;/&quot;相当于http://localhost:3000</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// req：请求信息，res:响应信息</span></span><br><span class="line">    <span class="comment">// 在路由中，应该做两件事:读取用户的请求和根据请求返回响应</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello路由&quot;</span>）</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务器(监听端口号)，启动后就可以通过3000端口来访问了</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动“”）</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="nodemon使用"><a href="#nodemon使用" class="headerlink" title="nodemon使用"></a>nodemon使用</h3><p>代码修改后可以自动重启服务器</p>
<p>使用方式：全局安装</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i nodemon -g</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<ul>
<li>nodemon  运行index.js</li>
<li>nodemon xxx  运行指定的js</li>
</ul>
<h3 id="访问服务器呈现页面"><a href="#访问服务器呈现页面" class="headerlink" title="访问服务器呈现页面"></a>访问服务器呈现页面</h3><p>服务器器中的代码，对于外部来说是不可见的，所以写的html页面，浏览器无法直接访问，需要将页面所在的目录设置为静态资源的目录（public文件夹）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 设置static中间价后，浏览器访问时会自动去public目录寻找是否有匹配的静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./public&quot;</span>)))</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello1路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>在路径中以冒号命名的部分称为param,可以通过req.params获取。param一般不会传递很复杂的参数</p>
<h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><p>get请求通过req.query获取参数，post通过req.body获取参数</p>
<p>默认情况下，express不会自动解析请求头，需要通过中间价来为其增加功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入解析请求头的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>())</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="错误路由"><a href="#错误路由" class="headerlink" title="错误路由"></a>错误路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有路由后边配置错误路由</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">404</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;您访问的地址已被劫持&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h4><p>ejs是node中的一款模板引擎长得像个网页，可以嵌入变量</p>
<p>使用步骤：</p>
<ol>
<li>安装ejs</li>
<li>配置express的模板引擎为ejs</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将ejs设置为默认的模板引擎</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&quot;view engine&quot;</span>,<span class="string">&quot;ejs&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>模板引擎需要被express渲染后才能使用,res.render()用来渲染一个模板引擎，并将其返回给浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/students&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&quot;students&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是express中创建的一个对象,实际上是一个中间件，可以在该中间件上绑定各种路由以及其他的中间件（便于管理）</p>
<p>新建routes文件夹，在该文件夹下存放各种路由数据的文件，再在服务器的主文件中引入使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;./list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hell0,我是list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&quot;./routes/user&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</p>
<p>cookie是HTTP协议中用来解决无状态问题的技术，本质就是一个头，服务器以响应头的形式将cookie发送给客户端，客户端收到后会将其存储，并在下次向服务器发送请求时将其传回，这样服务器就可以根据cookie来识别出客户端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cookie解析</span></span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/hello&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 将用户名放入cookie</span></span><br><span class="line">        res.<span class="title function_">cookie</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">cookie</span>.<span class="property">username</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>cookie的不足：<br>cookie是由服务器创建，浏览器保存，每次浏览器访问服务器时都需要将cookie发回，这就导致我们不能在cookie存放较多的数据，并且cookie是直接存储在客户端，容易被篡改盗用，不能存储敏感数据</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>为了解决cookie的不足，希望可以将每个用户的数据都有一个对应的id，只需要通过cookie将id发送给浏览器，浏览器每次访问只需将id发回，即可读取到服务器中的数据。</p>
<p>session是服务器中的一个对象，这个对象用来存储用户的数据，每一个session对象都有一个唯一的id，会通过cookie的形式发送给客户端，客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入session</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>)</span><br><span class="line"><span class="comment">// 设置session中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>:<span class="string">&quot;dazhaxie&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 登录成功后，将用户名放入session，这里仅仅是添加到了内存中的session，而没有写入文件中</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="property">loginUser</span> = username</span><br><span class="line">        <span class="comment">// 为了使得session可以立刻存储</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="title function_">save</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//session的默认有效期是一次会话</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">loginUser</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">柯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/10/nodejs/">http://example.com/2023/03/10/nodejs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">海底世界</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/node/">node</a></div><div class="post_share"><div class="social-share" data-image="/imgs/18.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/" title="CSS注意点"><img class="cover" src="/imgs/13.png" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSS注意点</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" title="商城项目"><img class="cover" src="/imgs/9.png" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">商城项目</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/02/express%E6%A1%86%E6%9E%B6/" title="express框架"><img class="cover" src="/imgs/14.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">express框架</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/avatar.png" onerror="this.onerror=null;this.src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">柯</div><div class="author-info__description">归途也还可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程和进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-1"><span class="toc-number">2.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text">解决同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">2.3.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">promise实例的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#then"><span class="toc-number">2.4.1.</span> <span class="toc-text">then</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch"><span class="toc-number">2.4.2.</span> <span class="toc-text">catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally"><span class="toc-number">2.4.3.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.4.</span> <span class="toc-text">promise实例的方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">Promise原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">2.7.</span> <span class="toc-text">promise解决回调地狱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.</span> <span class="toc-text">promise的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.9.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%92%8C-await"><span class="toc-number">2.10.</span> <span class="toc-text">async 和 await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">2.11.</span> <span class="toc-text">CommonJS模块化规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">2.12.</span> <span class="toc-text">ES6模块化规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">2.13.</span> <span class="toc-text">核心模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#process"><span class="toc-number">2.13.1.</span> <span class="toc-text">process</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.13.1.1.</span> <span class="toc-text">如何使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#path"><span class="toc-number">2.13.2.</span> <span class="toc-text">path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fs-file-system"><span class="toc-number">2.13.3.</span> <span class="toc-text">fs (file system)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">npm包管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json"><span class="toc-number">3.1.</span> <span class="toc-text">package.json</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">当在浏览器中输入地址以后发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%EF%BC%88request%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">请求报文（request）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%88response%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">响应报文（response）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Express"><span class="toc-number">6.</span> <span class="toc-text">Express</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nodemon%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">nodemon使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2"><span class="toc-number">6.2.</span> <span class="toc-text">访问服务器呈现页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#param"><span class="toc-number">6.3.</span> <span class="toc-text">param</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%92%8C-post"><span class="toc-number">6.4.</span> <span class="toc-text">get 和 post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%B7%AF%E7%94%B1"><span class="toc-number">6.5.1.</span> <span class="toc-text">错误路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ejs%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.5.2.</span> <span class="toc-text">ejs模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Router"><span class="toc-number">7.</span> <span class="toc-text">Router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie"><span class="toc-number">8.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session"><span class="toc-number">9.</span> <span class="toc-text">session</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="深入理解浏览器中的进程和线程"><img src="https://tenfei05.cfp.cn/creative/vcg/800/new/VCG41N1343790808.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="深入理解浏览器中的进程和线程"/></a><div class="content"><a class="title" href="/2023/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="深入理解浏览器中的进程和线程">深入理解浏览器中的进程和线程</a><time datetime="2023-11-09T07:19:27.000Z" title="发表于 2023-11-09 15:19:27">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E4%BB%8E%E8%BE%93%E5%85%A5Url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B/" title="从输入Url到页面渲染的过程"><img src="/imgs/7.png" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="从输入Url到页面渲染的过程"/></a><div class="content"><a class="title" href="/2023/11/09/%E4%BB%8E%E8%BE%93%E5%85%A5Url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B/" title="从输入Url到页面渲染的过程">从输入Url到页面渲染的过程</a><time datetime="2023-11-09T00:45:48.000Z" title="发表于 2023-11-09 08:45:48">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/" title="浏览器渲染"><img src="/imgs/4.png" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="浏览器渲染"/></a><div class="content"><a class="title" href="/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/" title="浏览器渲染">浏览器渲染</a><time datetime="2023-08-30T11:53:55.000Z" title="发表于 2023-08-30 19:53:55">2023-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/13/typescript/" title="typescript"><img src="/imgs/20.png" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="typescript"/></a><div class="content"><a class="title" href="/2023/08/13/typescript/" title="typescript">typescript</a><time datetime="2023-08-13T02:08:39.000Z" title="发表于 2023-08-13 10:08:39">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/MongoDB/" title="MongoDB"><img src="/imgs/17.png" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="MongoDB"/></a><div class="content"><a class="title" href="/2023/06/02/MongoDB/" title="MongoDB">MongoDB</a><time datetime="2023-06-02T15:32:34.000Z" title="发表于 2023-06-02 23:32:34">2023-06-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 柯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>