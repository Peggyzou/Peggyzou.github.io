<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nodejs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/10/nodejs/" class="article-date">
  <time datetime="2023-03-10T14:02:39.000Z" itemprop="datePublished">2023-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/10/nodejs/">nodejs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://nodejs.dev/en/">nodejs文档</a></p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul>
<li>进程（厂房）：程序运行的环境</li>
<li>线程（工人）：实行进行运算的东西</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p>
<h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python 通过多线程来解决，成本高</p>
<p>node.js 通过异步方式解决</p>
<p>异步：一段代码的执行不会影响其它代码</p>
<ul>
<li>异步的问题：无法通过return设置返回值</li>
<li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li>
</ul>
<p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）</p>
<p>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p>
<ul>
<li>创建promise时，构造函数中需要一个函数作为参数。</li>
<li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li>
<li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li>
<li>通过promise的实例方法then来读取promise中存储的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise中的数据&quot;</span>,result)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据&quot;</span>,reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul>
<li>catch()用法和then类似，但是只需要一个回调函数作为参数</li>
<li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul>
<li>finally()无论是正常存储还是出现异常了，都会执行</li>
<li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li>
</ul>
<h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><ul>
<li>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）</li>
<li>finally的返回值不会存到新的promise中</li>
</ul>
<h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p>
<ul>
<li>PromiseResult: 用来存储数据</li>
<li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p>
<h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">7</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">8</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p>
<h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul>
<li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.reject() 创建一个立即拒绝的promise</li>
<li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>),<span class="title function_">sum</span>(<span class="number">5</span>,<span class="number">6</span>),<span class="title function_">sum</span>(<span class="number">3</span>,<span class="number">4</span>)])</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li>
<li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li>
<li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li>
</ul>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p>
<p>调用栈：</p>
<ul>
<li>栈是一种数据结构，先进后出</li>
<li>调用栈中放的是要执行的代码<br>任务队列</li>
<li>队列是一种数据结构，先进先出</li>
<li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li>
</ul>
<p>JS中任务队列有两种</p>
<ul>
<li>宏任务队列（大部分代码都去宏任务队列中去排队）</li>
<li>微任务队列（Promise的回调函数（then、catch、finally））</li>
</ul>
<p>整个流程：</p>
<ol>
<li>执行调用栈中的代码</li>
<li>执行微任务队列中的任务</li>
<li>执行宏任务队列中的任务</li>
</ol>
<p>queueMicrotask()用来向微任务队列中添加一个任务</p>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">111</span>,<span class="number">222</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br></pre></td></tr></table></figure>

<p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(a+b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4,33,1,2,3</span></span><br></pre></td></tr></table></figure>

<p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p>
<p>注意以下代码的运行顺序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(a+b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出1,2,3</span></span><br></pre></td></tr></table></figure>

<p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出1,2,4,3</span></span><br></pre></td></tr></table></figure>

<h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p>
<ol>
<li>无法选择要引入模块的哪些内容</li>
<li>在复杂的场景下容易出错</li>
</ol>
<p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p>
<ul>
<li>使用require（“模块的路径”）函数引入模块</li>
<li>引入自定义模块时，模块名要以./或者../开头</li>
<li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li>
</ul>
<p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p>
<p>访问exports的方式有着两种：</p>
<ul>
<li>exports</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>module.exports</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p>
<h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p>
<ul>
<li>使用.mjs作为扩展名</li>
<li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li>
</ul>
<p>向外部导出内容：export</p>
<p>导入内容：</p>
<ul>
<li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li>
</ul>
<p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p>
<p>导入：</p>
<ul>
<li>import 变量名 from “url” 变量名可以随意命名</li>
</ul>
<p>es模块都运行在严格模式下</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p>
<p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p>
<ul>
<li>process.exit()  结束当前进程</li>
<li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span> (<span class="string">&quot;process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4、3、2、1</span></span><br></pre></td></tr></table></figure>

<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p>
<p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p>
<p>工作目录不同，所产生的绝对路径也就不同</p>
<p>最终形态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./05.promise.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure>

<h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p>
<ul>
<li>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</li>
<li>fs.readFile()，异步的文件读取方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(</span><br><span class="line">    path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>),</span><br><span class="line">    <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>主流用法：promise版本的fs</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs/promises&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">&#125;,)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p>
<p>npm init 初始化项目，创建package.json文件（需要回答问题）</p>
<p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p>
<p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p>
<ul>
<li>将包下载到当前项目的node_modules目录下</li>
<li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li>
<li>会自动添加package-lock.json文件：加速npm下载的，不用动</li>
</ul>
<p>npm i 自动安装所有依赖</p>
<p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p>
<p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p>
<p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p>
<p>镜像的配置：</p>
<ul>
<li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a target="_blank" rel="noopener" href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li>
<li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li>
</ul>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p>
<p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p>
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/1500126264">b站</a></p>
<p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p>
<p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p>
<h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p>
<p>第二步中客户端如何和服务器建立（断开）连接</p>
<p>答：<br>三次握手（建立连接）</p>
<ul>
<li>客户端发送请求连接（SYN:同步）</li>
<li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li>
<li>客户端向服务器发送同意连接的信息（ACK：同意）</li>
</ul>
<p>四次挥手（断开连接）</p>
<ul>
<li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li>
<li>服务器向客户端返回数据，知道了（ACK）</li>
<li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li>
<li>客户端向服务器发数据，可以断开了（ACK）</li>
</ul>
<p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p>
<p>TCP/IP协议族：规定了互联网中所有的通信细节</p>
<p>网络通信的过程由四层组成</p>
<ul>
<li>应用层<br>软件层面，浏览器、服务器都属于应用层</li>
<li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li>
<li>网络层<br>负责给数据包，添加信息</li>
<li>数据链路层<br>传输信息</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的（请求字符串是明文，不安全）</p>
<h3 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h3><p>客户端发送给服务器的报文称为请求报文</p>
<p>请求报文的格式：</p>
<ul>
<li>请求首行<br>第一部分  get/post：get请求主要用来向服务器请求资源，没有请求体，键值对为明文，安全性差，且不能发送较大的数据；post请求主要用来向服务器发送数据，post请求有请求体，无法在地址栏直接查看，安全性较好，请求体大小没有限制，可以发送任意大小的数据，所以尽量用post发送请求<br>第二部分  请求资源的路径，多个名值对用&amp;连接<br>第三部分  http协议版本</li>
<li>请求头<br>请求头也是名值对结构，用来告诉服务器我们浏览器的信息（浏览器可以接受的文件类型、浏览器允许的压缩的编码、浏览器的信息）</li>
<li>空行<br>用来分隔请求头和请求头</li>
<li>请求体<br>post请求直接通过请求体发送数据</li>
</ul>
<h3 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h3><p>服务器发送给客户端的报文称为请求报文</p>
<ul>
<li><p>响应首行<br>第一部分  http协议版本<br>第二部分  响应状态码<br>响应状态码的规则：</p>
<ul>
<li>1xx  请求处理中</li>
<li>2xx  请求成功</li>
<li>3xx  请求重定向</li>
<li>4xx  客户端错误</li>
<li>5xx  服务器错误<br>第三部分  对响应状态码的描述</li>
</ul>
</li>
<li><p>响应头<br>也是名值对结构，告诉浏览器响应的信息（响应体的类型、大小等）</p>
</li>
<li><p>空行<br>分隔响应头和响应体</p>
</li>
<li><p>响应体<br>服务器返回给客户端的内容</p>
</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>express是node中的服务器软件，通过express可以快速在node中搭建一个web服务器</p>
<p>使用步骤：</p>
<ol>
<li>创建并初始化项目：npm init -y</li>
<li>安装express: npm add express</li>
<li>创建index.js编写代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="comment">// 获取服务器的实例（一起皆对象）</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// &quot;/&quot;相当于http://localhost:3000</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// req：请求信息，res:响应信息</span></span><br><span class="line">    <span class="comment">// 在路由中，应该做两件事:读取用户的请求和根据请求返回响应</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello路由&quot;</span>）</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务器(监听端口号)，启动后就可以通过3000端口来访问了</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动“”）</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="nodemon使用"><a href="#nodemon使用" class="headerlink" title="nodemon使用"></a>nodemon使用</h3><p>代码修改后可以自动重启服务器</p>
<p>使用方式：全局安装</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -g</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<ul>
<li>nodemon  运行index.js</li>
<li>nodemon xxx  运行指定的js</li>
</ul>
<h3 id="访问服务器呈现页面"><a href="#访问服务器呈现页面" class="headerlink" title="访问服务器呈现页面"></a>访问服务器呈现页面</h3><p>服务器器中的代码，对于外部来说是不可见的，所以写的html页面，浏览器无法直接访问，需要将页面所在的目录设置为静态资源的目录（public文件夹）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 设置static中间价后，浏览器访问时会自动去public目录寻找是否有匹配的静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./public&quot;</span>)))</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello1路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>在路径中以冒号命名的部分称为param,可以通过req.params获取。param一般不会传递很复杂的参数</p>
<h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><p>get请求通过req.query获取参数，post通过req.body获取参数</p>
<p>默认情况下，express不会自动解析请求头，需要通过中间价来为其增加功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入解析请求头的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>())</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="错误路由"><a href="#错误路由" class="headerlink" title="错误路由"></a>错误路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在所有路由后边配置错误路由</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">404</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;您访问的地址已被劫持&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h4><p>ejs是node中的一款模板引擎长得像个网页，可以嵌入变量</p>
<p>使用步骤：</p>
<ol>
<li>安装ejs</li>
<li>配置express的模板引擎为ejs</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将ejs设置为默认的模板引擎</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&quot;view engine&quot;</span>,<span class="string">&quot;ejs&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>模板引擎需要被express渲染后才能使用,res.render()用来渲染一个模板引擎，并将其返回给浏览器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/students&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&quot;students&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是express中创建的一个对象,实际上是一个中间件，可以在该中间件上绑定各种路由以及其他的中间件（便于管理）</p>
<p>新建routes文件夹，在该文件夹下存放各种路由数据的文件，再在服务器的主文件中引入使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;./list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hell0,我是list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&quot;./routes/user&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</p>
<p>cookie是HTTP协议中用来解决无状态问题的技术，本质就是一个头，服务器以响应头的形式将cookie发送给客户端，客户端收到后会将其存储，并在下次向服务器发送请求时将其传回，这样服务器就可以根据cookie来识别出客户端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cookie解析</span></span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/hello&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 将用户名放入cookie</span></span><br><span class="line">        res.<span class="title function_">cookie</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">cookie</span>.<span class="property">username</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>cookie的不足：<br>cookie是由服务器创建，浏览器保存，每次浏览器访问服务器时都需要将cookie发回，这就导致我们不能在cookie存放较多的数据，并且cookie是直接存储在客户端，容易被篡改盗用，不能存储敏感数据</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>为了解决cookie的不足，希望可以将每个用户的数据都有一个对应的id，只需要通过cookie将id发送给浏览器，浏览器每次访问只需将id发回，即可读取到服务器中的数据。</p>
<p>session是服务器中的一个对象，这个对象用来存储用户的数据，每一个session对象都有一个唯一的id，会通过cookie的形式发送给客户端，客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入session</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>)</span><br><span class="line"><span class="comment">// 设置session中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>:<span class="string">&quot;dazhaxie&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 登录成功后，将用户名放入session，这里仅仅是添加到了内存中的session，而没有写入文件中</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="property">loginUser</span> = username</span><br><span class="line">        <span class="comment">// 为了使得session可以立刻存储</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="title function_">save</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//session的默认有效期是一次会话</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">loginUser</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/10/nodejs/" data-id="clm52imvy000ic4wp7e7qgmbd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-在线商城项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time datetime="2023-03-10T08:53:58.000Z" itemprop="datePublished">2023-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/">que</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p>node_modules文件夹：项目依赖文件夹</p>
<p>public文件夹：一般放置一些静态资源（图片）。值得注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。</p>
<p>src文件夹</p>
<pre><code>api文件夹：发送请求的配置

assets文件夹：一般用于存放静态资源（放置多个组件共用的静态资源），值得注意，放在assets文件夹里的静态资源，在webpack打包的时候，webpack会把静态资源当做一个模块，打包到JS文件里面。

components文件夹：一般放置非路由组件（全局组件）

pages文件夹：存放路由相关组件（pages也可换成views）

router文件夹：路由配置文件

store文件夹：vuex相关文件

mock文件夹：存放mock模拟数据

App.vue：唯一的根组件（汇总所有组件）

main.js：入口文件，也是整个程序当中最先执行的文件
</code></pre>
<p>.gitignore:git版本管制忽略的配置（一般不碰）</p>
<p>babel.config.js：babel的配置文件（相当于翻译官，比如把ES6相关语法翻译为ES5，兼容性更好，一般不碰）</p>
<p>package.json：应用包配置文件（类似于项目身份证，记录着项目名称、项目依赖、项目运行等信息）</p>
<p>package-lock.json：包版本控制文件（缓存性文件）</p>
<p>README.md：应用描述文件（说明性文件）</p>
<p>vue.config.js：可以对脚手架进行个性化定制，如何配置可以参考Vue CLI</p>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="comment">// 注册路由:组件身上都有$route、$router属性</span></span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 注册仓库:组件身上有$store属性</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="comment">// 配置全局事件总线</span></span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$API</span>=<span class="variable constant_">API</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>main.js是入口文件，所有全局组件在该文件中引入</p>
<h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Header</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 路由组件出口 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 在Home、Search显示，在登录、注册隐藏 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Footer</span> <span class="attr">v-show</span>=<span class="string">&quot;$route.meta.show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>Header、Footer是非路由组件，路由组件将展示在 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>的位置。</p>
<p>Footer组件在某些路由组件展示时要隐藏掉，就可以在路由配置中增加meta属性进行控制。</p>
<h2 id="router文件夹"><a href="#router文件夹" class="headerlink" title="router文件夹"></a>router文件夹</h2><h3 id="routes-js"><a href="#routes-js" class="headerlink" title="routes.js"></a>routes.js</h3><p>该文件用来配置路由信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span>=(<span class="params"></span>)=&gt;<span class="keyword">import</span> (<span class="string">&#x27;@/pages/Home&#x27;</span>) <span class="comment">//路由懒加载写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Search</span> <span class="keyword">from</span> <span class="string">&quot;../pages/Search&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: foo,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Search</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;search&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: <span class="literal">true</span></span><br><span class="line">    &#125;，</span><br><span class="line"><span class="comment">// 重定向，项目运行的时候，首先定位到首页</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/trade&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Trade</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 路由独享守卫</span></span><br><span class="line">    <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 去交易页面，必须是从购物车来的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&quot;/shopcart&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="路由懒加载："><a href="#路由懒加载：" class="headerlink" title="路由懒加载："></a>路由懒加载：</h4><blockquote>
<p>学习Vue的时候，各类教程都会告诉我们：Vue 的特点是SPA—— <strong>Single Page Application</strong> （单页应用程序）。</p>
<p>它有着诸如：“只有第一次会加载页面, 以后的每次页面切换，只需要进行组件替换；减少了请求体积，加快页面响应速度，降低了对服务器的压力” 等等优点。</p>
<p>但是呢！因为Vue 是SPA，所以首页第一次加载时会把所有的组件以及组件相关的资源全都加载了。</p>
<p>这样就会导致首页加载时加载了许多首页用不上的资源，造成网站首页打开速度变慢的问题，降低用户体验。</p>
<p>为了解决上面问题，我们需要对Vue实现组件懒加载（按需加载）。</p>
</blockquote>
<p>而vue中的路由懒加载其实是利用了webpack的异步加载的方法。</p>
<p>我们都知道webpack会整合所有的资源，将其打入一个包内。但是要实现懒加载，我们肯定不能让子组件被整合进一个包里头。所以需要解决的问题就是如何将子组件单独打包成一个文件，在我们需要用到他的时候去加载。</p>
<p>首先解决第一个问题，如何将子组件打包成一个单独的文件。</p>
<p>在webpack中提供了一个import方法给我们，注意是方法，而不是我们经常使用的那个import。</p>
<p>正常的引入文件我们会这样做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;sum&#125; from &#x27;./js/count&#x27; //同步加载</span><br></pre></td></tr></table></figure>

<p>而这样的写法就是大家所说的同步引入，他是会被打进一个文件内的。<br>使用import方法，就可以做到异步引入，从而使被引入的文件单独被打包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;count&quot; */</span>  <span class="string">&#x27;./js/count&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样就会使这个count.js被单独打包成一个文件了</p>
<p><img src="image/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/1684379436196.png" alt="1684379436196"></p>
<p>被单独打包的文件默认会使用文件的路径作为文件名。</p>
<p>在webpack配置中我们还需要这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//所有文件的输出路径</span></span><br><span class="line">        <span class="comment">//__dirname: nodejs的变量，代表当前文件的文件夹目录</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),<span class="comment">//绝对路径</span></span><br><span class="line">        <span class="comment">//文件名</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        <span class="comment">//代码块的文件名</span></span><br><span class="line">        <span class="attr">chunkFilename</span>:<span class="string">&quot;[name].chunk.js&quot;</span>,  这里的name就是上面的webpackChunkName</span><br><span class="line">        <span class="attr">clean</span>:<span class="literal">true</span> <span class="comment">//自动删除上次打包的结果</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>/* webpackChunkName: “count” */这一行注释就是为了修改打包出来的文件名的  count就是文件名。</p>
<p>这样我们就实现了一个将文件单独打包的功能。</p>
<p>当然离懒加载还差一点。</p>
<p>虽然上文中我们做到了异步加载，并且也将文件单独打包了，但是如果单纯这样做的话资源还是会被一起加载。细心的同学可能已经发现了，在vue中我们通常会给需要懒加载的路由这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;con&quot; */</span> <span class="string">&#x27;./xxx.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>没错，这里就是利用了函数只有被调用才会执行的特性。将组件的component属性赋值一个函数，在函数中去异步引入组件。这样才是一个完整的路由懒加载方案。</p>
<h4 id="props-路由传递参数-："><a href="#props-路由传递参数-：" class="headerlink" title="props(路由传递参数)："></a>props(路由传递参数)：</h4><p><strong>props分为三种形式</strong></p>
<ul>
<li>props为对象</li>
<li>props为布尔值，这种只能接收params动态路由的参数</li>
<li>props为函数，可以接收query和params参数(推荐)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="attr">addr</span>:<span class="string">&#x27;河南省信阳市商城县李集乡新庄村&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/detail/:id/:title&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">    <span class="comment">// props是个布尔值</span></span><br><span class="line">    <span class="comment">// props:true,</span></span><br><span class="line">    <span class="title function_">props</span>(<span class="params">$route</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">id</span>:$route.<span class="property">params</span>.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">title</span>:$route.<span class="property">params</span>.<span class="property">title</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;detail&quot; */</span> <span class="string">&#x27;../views/Detail.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;hash&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题"><a href="#vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题" class="headerlink" title="vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题"></a>vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题</h4><p>项目中涉及到跨页面传参数和后台进行数据交互，看到需求之后第一反应就是用路由传参来解决；Vue中给我们提供了三种路由传参方式，下面我们一个一个的来看一下:</p>
<p><strong>方法一：params传参</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/child,</span></span><br><span class="line"><span class="string">  name: &#x27;</span><span class="title class_">Child</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">  component: Child</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="string">this.$router.push(&#123;</span></span><br><span class="line"><span class="string">    name:&#x27;</span><span class="title class_">Child</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">    params:&#123;</span></span><br><span class="line"><span class="string">    	id:123</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>通过params传递参数，如果我们想获取id的 参数值，我们可以通过 <code>this.$route.params.id</code>这种方式来打印出来就可以得到了；（注意：获取参数的时候是 <code>$route</code>，跳转和传参的时候是$router）</p>
<blockquote>
<p>传参时params要与name配合使用，query这没有这种要求</p>
</blockquote>
<p><strong>方法二：路由属性配置传参</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/child/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/child/$&#123;id&#125;&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过路由属性配置传参我们可以用 <code>this.$route.params.id</code>来获取到id的值，注意this.$router.push方法里面路径带的是值，路由配置项那里带的是变量名(属性名)来实现的对应；</p>
<p>以上两种传参方式基本上可以理解为ajax中的post请求方式，参数都是不可见的，但是上面两种方法都有一个弊端，就是当页面刷新了是获取不到参数值的，那么有没有一种方法是页面刷新之后参数依然存在呢？</p>
<p>方法三：query传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//子路由配置</span><br><span class="line">&#123;</span><br><span class="line">  path: &#x27;/child,</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  component: Child</span><br><span class="line">&#125;</span><br><span class="line">//父路由编程式传参(一般通过事件触发)</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">    name:&#x27;Child&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">    	id:123</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>

<p>第三种方式是用query来传参，这种方式是可以解决页面刷新参数消失问题的，这种方式可以理解为是ajax中的get方法，参数是直接在url后面添加的，参数是可见的，所以解决页面刷新参数消失问题建议使用方法三来解决；</p>
<p>其实解决页面刷新参数丢失问题的方案还有很多，比如把参数存在sessionStorange或者localStorange中都是可行的，不过我们既然用vue框架，就要用vue的方式来解决问题。这里只是想告诉大家，问题的解决方案可以多种多样，要学会用多种方式或者说多种方案来解决一个问题，不要有太多的局限性！</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><h4 id="重写push、replace方法"><a href="#重写push、replace方法" class="headerlink" title="重写push、replace方法"></a>重写push、replace方法</h4><p><strong>编程式导航</strong>路由跳转到 <strong>当前路由</strong> , 多次执行会抛出**NavigationDuplicated **的警告错误。</p>
<blockquote>
<p>注意:编程式导航（push|replace）才会有这种情况的异常， <strong>声明式导航是没有这种问题</strong> ，因为声明式导航内部已经解决这种问题。</p>
</blockquote>
<p>这种异常，对于程序没有任何影响的。 但为什么会出现这种现象？</p>
<p>由于vue-router最新版本3.5.2，引入了promise，当传递参数多次且重复，会抛出异常，因此出现上面现象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写push||replace方法</span></span><br><span class="line"><span class="keyword">let</span> originPush = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>;</span><br><span class="line"><span class="keyword">let</span> originReplace = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">        <span class="comment">// 保证上下文仍是VueRouter的实例</span></span><br><span class="line">        originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">        <span class="comment">// 保证上下文仍是VueRouter的实例</span></span><br><span class="line">        originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    <span class="comment">// 滚动行为</span></span><br><span class="line">    <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">        <span class="comment">// 始终滚动到顶部</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="设置全局路由守卫"><a href="#设置全局路由守卫" class="headerlink" title="设置全局路由守卫"></a>设置全局路由守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫（路由跳转之前进行判断）</span></span><br><span class="line"><span class="comment">//登录后不能再进登录界面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span></span><br><span class="line">    <span class="keyword">let</span> token = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>;</span><br><span class="line">    <span class="keyword">let</span> name = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//如果登录了</span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还要去登录界面</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name)&#123;</span><br><span class="line">                <span class="comment">// 如果有用户信息</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;getUserInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//token失效了，获取不到用户信息，重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;userLogout&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未登录，不能去交易相关的页面，若要去先登录</span></span><br><span class="line">        <span class="keyword">let</span> toPath=to.<span class="property">path</span></span><br><span class="line">        <span class="keyword">if</span>(toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./trade&#x27;</span>)!=-<span class="number">1</span> || toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./pay&#x27;</span>)!=-<span class="number">1</span>||toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;/center&#x27;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login?redirect=&#x27;</span>+toPath)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="store文件夹"><a href="#store文件夹" class="headerlink" title="store文件夹"></a>store文件夹</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">  detail.js</span><br><span class="line">  home.js</span><br><span class="line">  search.js</span><br><span class="line">  shopcart.js</span><br><span class="line">  trade.js</span><br><span class="line">  user.js</span><br><span class="line">  index.js</span><br></pre></td></tr></table></figure>

<h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">//每个小仓库</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露store类的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">modules</span>:&#123;</span><br><span class="line">        home,</span><br><span class="line">        .</span><br><span class="line">	.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="home-js"><a href="#home-js" class="headerlink" title="home.js"></a>home.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// home的小仓库</span></span><br><span class="line"><span class="keyword">import</span> &#123; reqCategoryList, reqGetBannerList, reqGetFloorList &#125; <span class="keyword">from</span> <span class="string">&quot;@/api&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> state = &#123;  <span class="comment">//存储数据</span></span><br><span class="line">    <span class="comment">// state中数据默认值根据接口返回值初始化的</span></span><br><span class="line">    <span class="attr">categoryList</span>: [],</span><br><span class="line">    <span class="comment">// 轮播图的数据</span></span><br><span class="line">    <span class="attr">bannerList</span>: [],</span><br><span class="line">    <span class="comment">// floor的数据</span></span><br><span class="line">    <span class="attr">floorList</span>: [],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;   <span class="comment">//可以书写业务逻辑或者异步处理</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">categoryList</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">reqCategoryList</span>();</span><br><span class="line">        <span class="comment">// console.log(result)</span></span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">code</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="title function_">commit</span>(<span class="string">&quot;CATEGORYLIST&quot;</span>, result.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;   <span class="comment">//修改state的唯一手段</span></span><br><span class="line">    <span class="title function_">CATEGORYLIST</span>(<span class="params">state, categoryList</span>) &#123;</span><br><span class="line">        state.<span class="property">categoryList</span> = categoryList;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">GETBANNERLIST</span>(<span class="params">state, bannerList</span>) &#123;</span><br><span class="line">        state.<span class="property">bannerList</span> = bannerList;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">GETFLOORLIST</span>(<span class="params">state, floorList</span>) &#123;</span><br><span class="line">        state.<span class="property">floorList</span> = floorList;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 理解为计算属性，用于简化仓库数据，让组件获取仓库数据更加方便</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state,</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="api文件夹"><a href="#api文件夹" class="headerlink" title="api文件夹"></a>api文件夹</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api</span><br><span class="line">  ajax.js</span><br><span class="line">  index.js</span><br><span class="line">  mockAjax.js</span><br></pre></td></tr></table></figure>

<h3 id="ajax-js-二次封装axios"><a href="#ajax-js-二次封装axios" class="headerlink" title="ajax.js(二次封装axios)"></a>ajax.js(二次封装axios)</h3><p>封装了什么？</p>
<ol>
<li>基础路径，请求超时时间</li>
<li>请求拦截器<br>如果有token,把token放入请求头<br>进度条开始</li>
<li>响应拦截器<br>进度条结束</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对axios进行二次封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="comment">// 引入进度条</span></span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&quot;nprogress&quot;</span>;</span><br><span class="line"><span class="comment">// 引入进度条的样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="comment">// 利用axios对象的方法create创建axios的实例</span></span><br><span class="line"><span class="comment">// request就是axios，只不过稍微配置一下</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// 基础路径，发请求的时候，路径中会出现/api</span></span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;/api&quot;</span>,</span><br><span class="line">    <span class="comment">// 请求超时的时间</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截器：在发请求之前，请求拦截器可以检测到，可以在请求发出去之前做一些事</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(store.<span class="property">state</span>.<span class="property">detail</span>.<span class="property">uuid_token</span>)&#123;</span><br><span class="line">        <span class="comment">// 请求头添加一个字段userTempId</span></span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">userTempId</span> = store.<span class="property">state</span>.<span class="property">detail</span>.<span class="property">uuid_token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要携带token给服务器</span></span><br><span class="line">    <span class="keyword">if</span>(store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>)</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">token</span>=store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进度条开始动</span></span><br><span class="line">    nprogress.<span class="title function_">start</span>();</span><br><span class="line">    <span class="comment">// config:配置对象、对象里面有一个属性很重要，headers请求头</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 进度条结束</span></span><br><span class="line">    nprogress.<span class="title function_">done</span>();</span><br><span class="line">    <span class="comment">// 成功的回调函数:服务器相应数据回来后，响应拦截器可以检测到</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;faile&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> requests</span><br></pre></td></tr></table></figure>

<h3 id="index-js-2"><a href="#index-js-2" class="headerlink" title="index.js"></a>index.js</h3><p>API统一管理</p>
<h2 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mock</span><br><span class="line">  banner.json</span><br><span class="line">  floor.json</span><br><span class="line">  mockServe.js</span><br></pre></td></tr></table></figure>

<h3 id="mockServe-js"><a href="#mockServe-js" class="headerlink" title="mockServe.js"></a>mockServe.js</h3><p>创建接口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mockjs模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Mock</span> <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入JSON格式数据(webpack默认对外暴露图片、JSON数据格式)</span></span><br><span class="line"><span class="keyword">import</span> banner <span class="keyword">from</span> <span class="string">&#x27;./banner.json&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> floor <span class="keyword">from</span> <span class="string">&#x27;./floor.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock数据：第一个参数：请求地址；第二个：请求数据</span></span><br><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="string">&quot;/mock/banner&quot;</span>,&#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">data</span>:banner&#125;)<span class="comment">//模拟首页大的轮播图的数据</span></span><br><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="string">&quot;/mock/floor&quot;</span>,&#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">data</span>:floor&#125;)</span><br></pre></td></tr></table></figure>

<p>在api/mockAjax.js中封装axios方法，配置基础路径为”/mock”</p>
<p>在api/index.js中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mockRequests <span class="keyword">from</span> <span class="string">&quot;./mockAjax&quot;</span>;</span><br><span class="line"><span class="comment">// 获取home首页轮播图接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">reqGetBannerList</span> = (<span class="params"></span>) =&gt; mockRequests.<span class="title function_">get</span>(<span class="string">&#x27;/banner&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>此项目为在线电商Web App (SPA)，包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块，使用Vue全家桶+ES6++Webpack+Axios等前端热门技术，采用模块化、组件化、工程化的模式开发</p>
<p>首先为每个单页面编写了html\css的静态页面，使用vue-cli脚手架搭建项目，根据模块将静态页面拆分成静态组件，为每个组件配置路由，建一个router文件夹,专门用来配置路由，在router的总文件中可以设置全局路由守卫，在某个具体的路由配置中可以设置路由独享守卫。组件分为路由组件和非路由组件，放在两个不同的文件夹中，其中非路由组件分为全局组件（三级联动、分页器、轮播图）和非全局组件（header、footer），全局组件在入口文件main.js中引入，可在任意组件中使用。</p>
<p>用axios发送ajax请求，首先对axios进行二次封装，配置基础路径以及请求超时的时间，另外配置请求拦截器和响应拦截器，同时配置请求进度条。引入vuex插件，在actions中发送请求，将获得的数据存放在state中，组件需要的时候，派发actions捞取数据进行展示，以此实现前后端交互、数据动态展示。</p>
<p>使用导航守卫实现以下功能：</p>
<ul>
<li>只有登陆了, 才能查看交易/支付/个人中心界面</li>
<li>只有没有登陆, 才能查看登陆界面</li>
<li>只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面</li>
<li>只能从购物车界面, 才能跳转到交易界面</li>
<li>只能从交易界面, 才能跳转到支付界面</li>
<li>只有从支付界面, 才能跳转到支付成功的界面</li>
</ul>
<h3 id="项目中的难点、亮点、挑战"><a href="#项目中的难点、亮点、挑战" class="headerlink" title="项目中的难点、亮点、挑战"></a>项目中的难点、亮点、挑战</h3><p>1 mock模拟数据，实现前后端分离开发<br>2 组件间通信：父组件给子组件传递数据用props、子组件给父组件用自定义事件、兄弟组件间通信用全局事件总线（$bus）<br>3 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误，是因为编程式导航中引入了promise语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，解决办法，重写push和replace，指定两个空回调<br>4 展示某用户的订单信息：携带token。携带手机号、验证码、密码等数据进行注册请求，注册成功后，服务器会下发token。当携带手机号和密码进行登录请求时，可获取相应的token，在请求拦截器中将token作为一个字段添加到响应头，此后发送的请求都会带着token获取数据。<br>5 表单验证：</p>
<h4 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h4><ol>
<li>三级联动中，鼠标移入添加背景颜色时，为了防止事件触发过于频繁，此处用了节流。</li>
</ol>
<h4 id="home组件"><a href="#home组件" class="headerlink" title="home组件"></a>home组件</h4><h5 id="三级联动"><a href="#三级联动" class="headerlink" title="三级联动"></a>三级联动</h5><p><strong>静态文件+过渡：</strong></p>
<p>CSS：确定过渡元素的起始状态、结束状态、过渡事件、过渡规律</p>
<p>HTML：用 <code>&lt;transation&gt;&lt;transation/&gt;</code> 包裹过渡元素</p>
<p>JS：绑定鼠标事件</p>
<p>对于一级列表，在home组件中，初始化v-show=true，在其他组建中初始化v-show=false</p>
<p>对于二、三级列表，在一级列表的每一项上绑定鼠标移入事件，在绑定函数中传入index，用该条件决定二、三级列表的display样式。</p>
<p><strong>路由跳转：</strong></p>
<p>在三级列表中点击某类商品需要跳转路由，如何跳转到对应路由：</p>
<ol>
<li>利用事件委派，在一二三级列表的父元素上绑定点击事件</li>
<li>在每个a标签上添加自定义属性（商品名：判断点击的是否是a标签；商品id：判断点击的是那个a标签），经过判断后再决定路由跳转</li>
</ol>
<p><strong>重难点说明</strong></p>
<ol>
<li>组件与vuex交互</li>
<li>事件控制二三级分类列表的显示与隐藏</li>
<li>优化高频事件触发处理: 利用lodash进行函数节流处理</li>
<li>优化减小打包文件: 对lodash库实现按需引入</li>
<li>解决快速移出后可能显示第一个分类的子分类列表的bug</li>
<li>优化减少组件对象数量: 使用编程式导航代替声明式导航</li>
<li>优化事件处理效率: 利用事件委托</li>
<li>利用标签自定义属性携带动态数据</li>
<li>控制一级列表的显示与隐藏</li>
<li>一级列表显示隐藏的过渡效果</li>
<li>优化请求执行的位置, 减少请求次数</li>
<li>合并分类query参数与搜索的关键字params参数</li>
</ol>
<h4 id="serach组件"><a href="#serach组件" class="headerlink" title="serach组件"></a>serach组件</h4><p>由面包屑区域、商品筛选框、商品列表、分页器组成</p>
<p>把商品的品牌和属性单独写一个商品筛选的组件，父组件由面包屑、商品筛选、商品详情。当点击品牌值或者属性值时，需要把值传递给父组件，以在面包屑中（此处需要去重）显示。此处涉及子组件给父组件传递信息，用到自定义事件，在父组件中用子组件时绑定自定义事件，子组件中发生点击事件时触发函数。</p>
<p>同时点击商品值或者属性值后要更新商品筛选组件和商品列表，此处需要在父组件中发送请求，因为发送请求需要带的参数在父组件中。请求获得的数据存放在vuex中，而商品筛选组件所需的数据是从vuex中取，所以会更新商品筛选框。注意：在header的搜索框中输入值点击搜索后，值会作为params参数参与路由跳转到search中，所以在search组件挂载前要将该参数合并到searchParams（发送请求需要带的参数）中</p>
<p>商品详情处会有综合排序或者价格排序，点击综合时，就按综合属性进行排序，如果原来是升序，就按降序排列，否则反之；点击价格时同理。</p>
<p><strong>分页器</strong></p>
<p>点击某一页时，把当前页数放入searchParams（发送请求需要带的参数）中，发送请求获取对应数据</p>
<p>父向子传递参数：当前页数，每页展示多少条数据、总共有多少条数据、中间的连续页数</p>
<p>如果当前页为1，则上一页按钮disable</p>
<p>如果连续页的第一页大于1，则显示第一页</p>
<p>如果连续页的第一页大于2，则显示省略号</p>
<p>如果连续页大于总页数，则首页为1，尾页为总页数；否则，连续页的首项为当前页-parseInt(连续页数/2),尾项为当前页+parseInt(连续页数/2)，如果首页小于1，取1，尾页为连续页数；如果尾页大于总页数，取最后一页，首页为总页数-连续页数+1</p>
<p>如果连续页的尾页小于总页数，则有总页数</p>
<p>如果连续页的尾页小于总页数-1，则有省略号</p>
<h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><p>手机号：</p>
<p>验证码：如果有了手机号，带上手机号发送请求，获取验证码</p>
<p>登录密码：</p>
<p>确认密码：</p>
<p>同意协议：</p>
<p><strong>表单验证:到b站看个视频</strong></p>
<p><strong>注册</strong></p>
<p>表单验证成功后，带着手机号、验证码、密码向服务器发送请求存储用户数据，并跳转路由到登录页</p>
<h4 id="登录组件"><a href="#登录组件" class="headerlink" title="登录组件"></a>登录组件</h4><p>携带手机号和密码发送登录请求，服务器会下发一个token，将其本地存储，在请求拦截器中判断是否有token,有则加入请求头中。</p>
<h4 id="详情组件"><a href="#详情组件" class="headerlink" title="详情组件"></a>详情组件</h4><p><strong>添加购物车</strong></p>
<p>携带商品id和数量向后端发送请求（后台会存储数据），同时将该商品的信息会话存储，跳转到成功添加购物车页面，展示会话存储的信息。从成功添加购物车页面，可以去购物车，进行结算</p>
<p><strong>放大镜</strong></p>
<p>放大镜下方有个图片列表，里面为该商品的一些图片，图片列表和放大镜是兄弟组件。在放大镜组件中首先获取兄弟组件中传过来的图片索引，此处用到了全局事件总线。</p>
<p>布局：图片框设置相对定位，遮罩层和放大的区域的display为none，鼠标移入的时候display为block。遮罩层的宽高都为图片框的一半，放大框和图片框大小相同，但是放大框中图片宽高为图片框中图片的2倍，鼠标移入图片框的时候，获取鼠标的位置，定位遮罩层的位置，同时设置放大框中图片的left和top属性为-2倍</p>
<h4 id="订单组件"><a href="#订单组件" class="headerlink" title="订单组件"></a>订单组件</h4><p>收件人信息、商品清单、买家留言等部分</p>
<p>点击去支付，跳转到支付页</p>
<h4 id="支付组件"><a href="#支付组件" class="headerlink" title="支付组件"></a>支付组件</h4><p>点击立即支付后，弹出二维码支付框（elementui），设置定时器，每过一秒钟获取以下支付信息，如果支付成功，则关闭支付框，跳转到支付成功组件</p>
<h4 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h4><p>我的订单</p>
<h4 id="支付成功组件"><a href="#支付成功组件" class="headerlink" title="支付成功组件"></a>支付成功组件</h4><p>该部分有组件内守卫，如果是从pay组件过来的，放行</p>
<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><ol>
<li>全局守卫：如果没有登录（没有token），则不能去trade\pay\center等页面，到直接去登录界面，同时将要去的页面路径作为重定向的参数传递，待登录后，判断路径中是否有重定向参数，再跳转至重定向页面<br>登录后，如果token过期了，则需要到登录界面重新登录</li>
<li>支付成功组件用到了组件内守卫，如果是从pay组件过来的，放行</li>
<li>路由独享守卫：只能从购物车界面跳转到交易界面，只能从交易界面跳转到支付界面</li>
</ol>
<h4 id="重写Push、replace"><a href="#重写Push、replace" class="headerlink" title="重写Push、replace"></a>重写Push、replace</h4><p>编程式路由跳转到当前路径且参数没有变化时会抛NavigationDuplicated 错误</p>
<p>原因：vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise</p>
<p>解决办法：如果没穿成功和失败的回调函数，传两个空函数</p>
<h4 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h4><p>二次封装即配置基础路径，设置请求超时时间</p>
<p>另外还可以配置请求拦截器和响应拦截器</p>
<p>请求拦截器：把token放入请求头、进度条开始</p>
<p>响应拦截器：进度条结束</p>
<h4 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h4><p>本项目自创了首页轮播图以及两个floor层的数据，数据为json格式。然后写一个mockserve服务器，引入数据，作为接口的响应数据。同二次封装axios一样封装一个mockajax，将基础路径配置为/mock。</p>
<p>注：以/api开头的接口在vue.config.js中配置proxy代理</p>
<h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h4><p>项目中在轮播图处使用了，只有节点更新后才能使用第三方轮播图组件</p>
<h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><ol>
<li>当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能 <strong>把不同路由对应的组件分割成不同的代码块</strong> ，然后当路由被访问的时候才加载对应组件，这样就更加高效了</li>
<li>本质就是<strong>Vue 的异步组件</strong>在路由组件上的应用</li>
<li>需要使用动态import语法, 也就是<strong>import()函数</strong></li>
</ol>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>编程式路由导航：</p>
<ul>
<li>push</li>
<li>replace</li>
</ul>
<h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误"><a href="#编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误" class="headerlink" title="编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误"></a>编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误</h3><p>解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误<br>解决2: 修正Vue原型上的push和replace方法 (优秀)</p>
<h3 id="如何指定params参数可传可不传"><a href="#如何指定params参数可传可不传" class="headerlink" title="如何指定params参数可传可不传?"></a>如何指定params参数可传可不传?</h3><p>path: ‘/search/:keyword?’</p>
<h3 id="指定params参数时可不可以用path和params配置的组合"><a href="#指定params参数时可不可以用path和params配置的组合" class="headerlink" title=":指定params参数时可不可以用path和params配置的组合?"></a>:指定params参数时可不可以用path和params配置的组合?</h3><p>不可以,用path和params配置的组合, 只能用name和params配置的组合<br>query配置可以与path或name进行组合使用</p>
<h3 id="如果指定name与params配置-但params中数据是一个””-无法跳转"><a href="#如果指定name与params配置-但params中数据是一个””-无法跳转" class="headerlink" title="如果指定name与params配置, 但params中数据是一个””, 无法跳转"></a>如果指定name与params配置, 但params中数据是一个””, 无法跳转</h3><p>解决1: 不指定params<br>解决2: 指定params参数值为undefined</p>
<h3 id="路由组件能不能传递props数据"><a href="#路由组件能不能传递props数据" class="headerlink" title="路由组件能不能传递props数据?"></a>路由组件能不能传递props数据?</h3><p>可以: 可以将query或且params参数映射/转换成props传递给路由组件对象<br>实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p>
<h2 id="axios二次封装-1"><a href="#axios二次封装-1" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><ul>
<li>基础路径</li>
<li>请求超时时间</li>
<li>请求拦截器（请求进度条，携带token）</li>
<li>响应拦截器</li>
</ul>
<h2 id="路由守卫-1"><a href="#路由守卫-1" class="headerlink" title="路由守卫"></a>路由守卫</h2><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>在准备跳转到某个路由组件之前 (在开发中用的比较多)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫（路由跳转之前进行判断）</span></span><br><span class="line"><span class="comment">//登录后不能再进登录界面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span></span><br><span class="line">    <span class="keyword">let</span> token = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>;</span><br><span class="line">    <span class="keyword">let</span> name = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//如果登录了</span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还要去登录界面</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name)&#123;</span><br><span class="line">                <span class="comment">// 如果有用户信息</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;getUserInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//token失效了，获取不到用户信息，重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;userLogout&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未登录，不能去交易相关的页面，若要去先登录</span></span><br><span class="line">        <span class="keyword">let</span> toPath=to.<span class="property">path</span></span><br><span class="line">        <span class="keyword">if</span>(toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./trade&#x27;</span>)!=-<span class="number">1</span> || toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./pay&#x27;</span>)!=-<span class="number">1</span>||toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;/center&#x27;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login?redirect=&#x27;</span>+toPath)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>说明: to:<br>目标route;<br>from: 起始route;</p>
<p>next: 放行函数</p>
<ul>
<li>next(): 执行下一个守卫回调, 如果没有跳转到目标路由</li>
<li>next(false)/不执行: 跳转流程在当前处中断, 不会跳转到目标路由组件</li>
<li>next(path): 跳转到指定的另一个路由</li>
</ul>
<ol start="2">
<li>全局后置守卫: 在跳转到某个路由组件之后</li>
</ol>
<p>router.afterEach((to, from) =&gt; {})</p>
<ol start="3">
<li>路由独享守卫</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由独享守卫</span></span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 去交易页面，必须是从购物车来的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&quot;/shopcart&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>3 组件守卫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 组件内守卫</span></span><br><span class="line">    <span class="title function_">beforeRouteEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">      <span class="comment">// 在渲染该组件的路由被confirm前调用</span></span><br><span class="line">      <span class="comment">// 不能获取组件实例this，因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">      <span class="comment">// 但可以通过next(component =&gt; &#123;&#125;), 在回调函数中访问组件对象</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">from</span>.<span class="property">path</span>==<span class="string">&#x27;/pay&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组件对象将要更新前调用, 可以访问this</span></span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;&#125;,</span><br><span class="line"><span class="comment">// 在当前组件离开前调用, 可以访问this</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">     <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" data-id="clm52imw3000xc4wp99616h0n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" rel="tag">商城项目</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/25/git/" class="article-date">
  <time datetime="2023-02-25T14:01:56.000Z" itemprop="datePublished">2023-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/25/git/">git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p>
<ul>
<li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li>
<li>在不影响现行开发工作的情况下对代码进行维护</li>
<li>开发时，某段代码被多人修改时，处理代码的冲突问题</li>
</ul>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。<img src="1.png" alt="1682601512635"></p>
<p>远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p>
<p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p>
<h2 id="下载和配置"><a href="#下载和配置" class="headerlink" title="下载和配置"></a>下载和配置</h2><p><a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a>无脑下载</p>
<p>下载Git后，首先要配置个人用户名称和电子邮件地址。这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global [user.name]</span><br><span class="line">git config --global [user.email]</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>被git管理的文件有三种状态：</p>
<ul>
<li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li>
<li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li>
<li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li>
</ul>
<p>可以通过git status查看文件的状态</p>
<p>新添加的文件处于未跟踪状态（未被git管理）:</p>
<ul>
<li>未跟踪-&gt;暂存：git add <code>&lt;filename&gt;</code></li>
<li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li>
<li>未修改-&gt;修改：修改代码后，转为修改状态</li>
<li>修改-&gt;暂存：git add <code>&lt;filename&gt;</code></li>
</ul>
<p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p>
<h2 id="将文件提交至远程仓库："><a href="#将文件提交至远程仓库：" class="headerlink" title="将文件提交至远程仓库："></a>将文件提交至远程仓库：</h2><ol>
<li>在总文件夹中右键选择 <code>git bash here</code>，初始化git。</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>连接远程仓库</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin &quot;仓库地址&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add &quot;文件名&quot;/git add *  把工作区某个文件提交至暂存区/把工作区所有文件提交至暂存区</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;版本名&quot;  把暂存区文件提交至本地仓库</span><br><span class="line"></span><br><span class="line">$ git push origin master  把本地仓库的文件推送到远程仓库的某一分支上</span><br></pre></td></tr></table></figure>

<h2 id="从远程仓库下载文件：fork、clone"><a href="#从远程仓库下载文件：fork、clone" class="headerlink" title="从远程仓库下载文件：fork、clone"></a>从远程仓库下载文件：fork、clone</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork包含了原来的仓库所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行 <code>clone</code>命令后，会在当前目录下创建一个名为 <code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h3 id="使用fork和clone"><a href="#使用fork和clone" class="headerlink" title="使用fork和clone"></a>使用fork和clone</h3><p>当你在 <code>github</code>发现感兴趣开源项目的时候，可以通过点击 <code>github</code>仓库中右上角 <code>fork</code>标识的按钮，如下图：</p>
<p><img src="2.png" alt="1682602188024"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的 <code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过 <code>git clone</code>对你这个复制的远程仓库进行克隆,在 <code>github</code>中，开源项目右侧存在 <code>code</code>按钮，点击后则会显示开源项目 <code>url</code>信息，如下图所示：通过 <code>git clone xxx</code>则能完成远程项目的下载</p>
<p><img src="5.png" alt="1682602404998"></p>
<p>后续更改任何东西都可以在本地完成，如 <code>git add</code>、<code>git commit</code>一系列的操作，然后通过 <code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送 <code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="3.png" alt="1682602282691"></p>
<p>整体流程如下图：</p>
<p><img src="4.png" alt="1682602320048"></p>
<p>fork和clone的区别</p>
<h3 id="其三者区别如下："><a href="#其三者区别如下：" class="headerlink" title="其三者区别如下："></a>其三者区别如下：</h3><ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
</ul>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p><code>git</code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="6.png" alt="1682603560111"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的 <code>git</code>命令</p>
<h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>一个 <code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h4 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h4><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p>
<ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h4 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h4><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而 <code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的 <code>git</code>文件中对应也存储了 <code>git</code>本地仓库分支的 <code>commit ID</code>和 跟踪的远程分支的 <code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git/refs/head/[本地分支]</li>
<li>.git/refs/remotes/[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中 <code>master</code>的 <code>commitID</code>不变</p>
<p>但是与 <code>git</code>上面关联的那个 <code>orign/master</code>的 <code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过 <code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="7.png" alt="1682604231981"></p>
<p>也就是 <code>fetch</code>的时候本地的 <code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地 <code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用 <code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="8.png" alt="1682604272380"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到 <code>git pull</code>或者 <code>git fetch</code>命令</p>
<p><strong>fetch</strong></p>
<p>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>例如从远程的 <code>origin</code>仓库的 <code>master</code>分支下载代码到本地并新建一个 <code>temp</code>分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br></pre></td></tr></table></figure>

<p>如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来到本地当前分支</p>
<p>这里 <code>git fetch</code>不会进行合并，执行后需要手动执行 <code>git merge</code>合并，如下：</p>
<p><strong>pull</strong></p>
<p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>例如将远程主机 <code>origin</code>的 <code>master</code>分支拉取过来，与本地的 <code>branchtest</code>分支合并，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure>

<p>同样如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来与本地当前分支合并</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h2 id="git-rebase-和-git-merge"><a href="#git-rebase-和-git-merge" class="headerlink" title="git rebase 和 git merge"></a>git rebase 和 git merge</h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p><strong>git merge</strong></p>
<p>将当前分支合并到指定分支，命令用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure>

<p>通过 <code>git merge</code>将当前分支与 <code>xxx</code>分支合并，产生的新的 <code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从 <code>master</code>分支分叉出来的，如下所示：</p>
<p><img src="9.png" alt="1682604971963"></p>
<p>合并 <code>bugfix</code>分支到 <code>master</code>分支时，如果 <code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含 <code>master</code>分支所有的历史记录</p>
<p>所以通过把 <code>master</code>分支的位置移动到 <code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果 <code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="10.png" alt="1682605021939"></p>
<p>这时候使用 <code>git merge</code>的时候，会生成一个新的提交，并且 <code>master</code>分支的 <code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="11.png" alt="1682605062943"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<p><strong>git rebase（变基）</strong></p>
<p>将当前分支移植到指定分支或指定 <code>commit</code>之上，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>同样，<code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="12.png" alt="1682605154719"></p>
<p>通过 <code>git rebase</code>，会变成如下情况：</p>
<p><img src="13.png" alt="1682605189602"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="14.png" alt="1682605269640"></p>
<p><code>rebase</code>之后，<code>master</code>的 <code>HEAD</code>位置不变。因此，要合并 <code>master</code>分支和 <code>bugfix</code>分支</p>
<p><img src="15.png" alt="1682605347300"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的 <code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交 <code>X</code>和 <code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置 <code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>从上面可以看到，<code>merge</code>和 <code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<p><strong>merge</strong></p>
<p>通过 <code>merge</code>合并分支会新增一个 <code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<p><strong>rebase</strong></p>
<p><code>rebase</code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 <code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把 <code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<p><strong>冲突如何产生？</strong></p>
<p>所谓冲突就是两个开发者对同一个文件同一个位置做出了不同内容的修改，因此就产生了冲突。</p>
<p>一般冲突的产生发生在两个分支进行合并时或者是从远程仓库拉取代码到本地时。</p>
<p>但是归根结底，冲突产生的原因还是：对同一个文件同一个位置做出了不同内容的修改。从而导致冲突发生。</p>
<p><strong>比如：master 分支和 hot-fix 分支上都修改了代码</strong>， 那么在合并分支的时候就会发生冲突。</p>
<p><code>【第一步】在 hot-fix 分支上增加如下代码，并且提交。</code></p>
<p><img src="18.png" alt="1685437407135"></p>
<p><code>【第二步】在master 分支上同样的地方增加如下代码，并且提交。</code></p>
<p><img src="19.png" alt="1685437413727"></p>
<p><code>【第三步】 我们现在站在 master 分支上合并 hot-fix 分支， 就会发生代码冲突。</code></p>
<p><code>【第四步】手动解决冲突，合并代码。</code></p>
<p><img src="20.png" alt="1685437533173"></p>
<p>代码冲突就解决了， 提交本地库，查看修改结果：</p>
<p><img src="21.png" alt="1685437711486"></p>
<h2 id="git-reset-和-git-revert"><a href="#git-reset-和-git-revert" class="headerlink" title="git reset 和 git revert"></a>git reset 和 git revert</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="16.png" alt="1682605761698"></p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><img src="17.png" alt="1682605793002"></p>
<h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用 <code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用 <code>git reset</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/25/git/" data-id="clm52imvv000cc4wpgnbxb4xm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/" rel="tag">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" rel="tag">商城项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">组件化、模块化、工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag">网络基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" rel="tag">网络攻击</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/ts/" style="font-size: 10px;">ts</a> <a href="/tags/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">商城项目</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">框架</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 10px;">组件化、模块化、工程化</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">网络基础</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" style="font-size: 10px;">网络攻击</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/">浏览器渲染</a>
          </li>
        
          <li>
            <a href="/2023/08/13/typescript/">typescript</a>
          </li>
        
          <li>
            <a href="/2023/06/02/MongoDB/">MongoDB</a>
          </li>
        
          <li>
            <a href="/2023/06/02/express%E6%A1%86%E6%9E%B6/">express框架</a>
          </li>
        
          <li>
            <a href="/2023/06/02/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/">会话控制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>