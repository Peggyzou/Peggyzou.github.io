<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nodejs</title>
      <link href="/2023/03/10/nodejs/"/>
      <url>/2023/03/10/nodejs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nodejs.dev/en/">nodejs文档</a></p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程（厂房）：程序运行的环境</li><li>线程（工人）：实行进行运算的东西</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p><h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python</p><p>通过多线程来解决，成本高</p><p>node.js</p><p>通过异步方式解决</p><p>异步：一段代码的执行不会影响其它代码</p><ul><li>异步的问题：无法通过return设置返回值</li><li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li></ul><p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）<br>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p><ul><li>创建promise时，构造函数中需要一个函数作为参数。</li><li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li><li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li><li>通过promise的实例方法then来读取promise中存储的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise中的数据&quot;</span>,result)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据&quot;</span>,reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul><li>catch()用法和then类似，但是只需要一个回调函数作为参数</li><li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>finally()无论是正常存储还是出现异常了，都会执行</li><li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li></ul><h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><p>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）<br>finally的返回值不会存到新的promise中</p><h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p><ul><li>PromiseResult: 用来存储数据</li><li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p><h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">7</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">8</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p><h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul><li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>Promise.reject() 创建一个立即拒绝的promise</li><li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>),<span class="title function_">sum</span>(<span class="number">5</span>,<span class="number">6</span>),<span class="title function_">sum</span>(<span class="number">3</span>,<span class="number">4</span>)])</span><br></pre></td></tr></table></figure><ul><li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li><li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li><li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p><p>调用栈：</p><ul><li>栈是一种数据结构，先进后出</li><li>调用栈中放的是要执行的代码<br>任务队列</li><li>队列是一种数据结构，先进先出</li><li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li></ul><p>JS中任务队列有两种</p><ul><li>宏任务队列（大部分代码都去宏任务队列中去排队）</li><li>微任务队列（Promise的回调函数（then、catch、finally））</li></ul><p>整个流程：</p><ol><li>执行调用栈中的代码</li><li>执行微任务队列中的任务</li><li>执行宏任务队列中的任务</li></ol><p>queueMicrotask()用来向微任务队列中添加一个任务</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">111</span>,<span class="number">222</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br></pre></td></tr></table></figure><p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(a+b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4,33,1,2,3</span></span><br></pre></td></tr></table></figure><p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p><p>注意以下代码的运行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(a+b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出1,2,3</span></span><br></pre></td></tr></table></figure><p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出1,2,4,3</span></span><br></pre></td></tr></table></figure><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p><ol><li>无法选择要引入模块的哪些内容</li><li>在复杂的场景下容易出错</li></ol><p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p><ul><li>使用require（“模块的路径”）函数引入模块</li><li>引入自定义模块时，模块名要以./或者../开头</li><li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li></ul><p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p><p>访问exports的方式有着两种：</p><ul><li>exports</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li>module.exports</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p><h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p><ul><li>使用.mjs作为扩展名</li><li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li></ul><p>向外部导出内容：export</p><p>导入内容：</p><ul><li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li></ul><p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p><p>导入：</p><ul><li>import 变量名 from “url” 变量名可以随意命名</li></ul><p>es模块都运行在严格模式下</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p><p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p><ul><li>process.exit()  结束当前进程</li><li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span> (<span class="string">&quot;process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4、3、2、1</span></span><br></pre></td></tr></table></figure><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p><p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p><p>工作目录不同，所产生的绝对路径也就不同</p><p>最终形态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./05.promise.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p><ul><li><p>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</p></li><li><p>fs.readFile()，异步的文件读取方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(</span><br><span class="line">    path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>),</span><br><span class="line">    <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>主流用法：promise版本的fs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs/promises&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">&#125;,)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p><p>npm init 初始化项目，创建package.json文件（需要回答问题）</p><p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p><p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p><ul><li>将包下载到当前项目的node_modules目录下</li><li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li><li>会自动添加package-lock.json文件：加速npm下载的，不用动</li></ul><p>npm i 自动安装所有依赖</p><p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p><p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p><p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p><p>镜像的配置：</p><ul><li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p><p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p><p><a href="https://space.bilibili.com/1500126264">b站</a></p><p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p><p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p><h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p><p>第二步中客户端如何和服务器建立（断开）连接</p><p>答：<br>三次握手（建立连接）  </p><ul><li>客户端发送请求连接（SYN:同步）</li><li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li><li>客户端向服务器发送同意连接的信息（ACK：同意）</li></ul><p>四次挥手（断开连接）</p><ul><li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li><li>服务器向客户端返回数据，知道了（ACK）</li><li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li><li>客户端向服务器发数据，可以断开了（ACK）</li></ul><p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p><p>TCP/IP协议族：规定了互联网中所有的通信细节</p><p>网络通信的过程由四层组成</p><ul><li>应用层<br>软件层面，浏览器、服务器都属于应用层</li><li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li><li>网络层<br>负责给数据包，添加信息</li><li>数据链路层<br>传输信息</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的</p><p>请求报文（request）：客户端发送给服务器的报文称为请求报文</p><p>请求报文的格式：</p><ul><li>请求首行</li><li>请求头</li><li>空行</li><li>请求体</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>que</title>
      <link href="/2023/03/10/que/"/>
      <url>/2023/03/10/que/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>此项目为在线电商Web App (SPA)，包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块，使用Vue全家桶+ES6++Webpack+Axios等前端热门技术，采用模块化、组件化、工程化的模式开发</p><p>首先为每个单页面编写了html\css的静态页面，使用vue-cli脚手架搭建项目，根据模块将静态页面拆分成静态组件，为每个组件配置路由，建一个router文件夹,专门用来配置路由，在router的总文件中可以设置全局路由守卫，在某个具体的路由配置中可以设置路由独享守卫。组件分为路由组件和非路由组件，放在两个不同的文件夹中，其中非路由组件分为全局组件（三级联动、分页器、轮播图）和非全局组件（header、footer），全局组件在入口文件main.js中引入，可在任意组件中使用。</p><p>用axios发送ajax请求，首先对axios进行二次封装，配置基础路径以及请求超时的时间，另外配置请求拦截器和响应拦截器，同时配置请求进度条。引入vuex插件，在actions中发送请求，将获得的数据存放在state中，组件需要的时候，派发actions捞取数据进行展示，以此实现前后端交互、数据动态展示。</p><p>使用导航守卫实现以下功能：</p><ul><li>只有登陆了, 才能查看交易/支付/个人中心界面</li><li>只有没有登陆, 才能查看登陆界面</li><li>只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面</li><li>只能从购物车界面, 才能跳转到交易界面</li><li>只能从交易界面, 才能跳转到支付界面</li><li>只有从支付界面, 才能跳转到支付成功的界面</li></ul><h3 id="项目中的难点、亮点、挑战"><a href="#项目中的难点、亮点、挑战" class="headerlink" title="项目中的难点、亮点、挑战"></a>项目中的难点、亮点、挑战</h3><p>1 mock模拟数据，实现前后端分离开发<br>2 组件间通信：父组件给子组件传递数据用props、子组件给父组件用自定义事件、兄弟组件间通信用全局事件总线（$bus）<br>3 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误，是因为编程式导航中引入了promise语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，解决办法，重写push和replace，指定两个空回调<br>4 展示某用户的订单信息：携带token。携带手机号、验证码、密码等数据进行注册请求，注册成功后，服务器会下发token。当携带手机号和密码进行登录请求时，可获取相应的token，在请求拦截器中将token作为一个字段添加到响应头，此后发送的请求都会带着token获取数据。<br>5 表单验证：</p><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>编程式路由导航：</p><ul><li>push</li><li>replace</li></ul><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误"><a href="#编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误" class="headerlink" title="编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误"></a>编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误</h3><p>解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误<br>解决2: 修正Vue原型上的push和replace方法 (优秀)</p><h3 id="如何指定params参数可传可不传"><a href="#如何指定params参数可传可不传" class="headerlink" title="如何指定params参数可传可不传?"></a>如何指定params参数可传可不传?</h3><p>path: ‘/search/:keyword?’</p><h3 id="指定params参数时可不可以用path和params配置的组合"><a href="#指定params参数时可不可以用path和params配置的组合" class="headerlink" title=":指定params参数时可不可以用path和params配置的组合?"></a>:指定params参数时可不可以用path和params配置的组合?</h3><p>不可以,用path和params配置的组合, 只能用name和params配置的组合<br>query配置可以与path或name进行组合使用</p><h3 id="如果指定name与params配置-但params中数据是一个””-无法跳转"><a href="#如果指定name与params配置-但params中数据是一个””-无法跳转" class="headerlink" title="如果指定name与params配置, 但params中数据是一个””, 无法跳转"></a>如果指定name与params配置, 但params中数据是一个””, 无法跳转</h3><p>解决1: 不指定params<br>解决2: 指定params参数值为undefined</p><h3 id="路由组件能不能传递props数据"><a href="#路由组件能不能传递props数据" class="headerlink" title="路由组件能不能传递props数据?"></a>路由组件能不能传递props数据?</h3><p>可以: 可以将query或且params参数映射/转换成props传递给路由组件对象<br>实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p><h2 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><ul><li>基础路径</li><li>请求超时时间</li><li>请求拦截器（请求进度条，携带token）</li><li>响应拦截器</li></ul><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>在准备跳转到某个路由组件之前 (在开发中用的比较多)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫（路由跳转之前进行判断）</span></span><br><span class="line"><span class="comment">//登录后不能再进登录界面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span></span><br><span class="line">    <span class="keyword">let</span> token = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>;</span><br><span class="line">    <span class="keyword">let</span> name = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//如果登录了</span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还要去登录界面</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name)&#123;</span><br><span class="line">                <span class="comment">// 如果有用户信息</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;getUserInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//token失效了，获取不到用户信息，重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;userLogout&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未登录，不能去交易相关的页面，若要去先登录</span></span><br><span class="line">        <span class="keyword">let</span> toPath=to.<span class="property">path</span></span><br><span class="line">        <span class="keyword">if</span>(toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./trade&#x27;</span>)!=-<span class="number">1</span> || toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./pay&#x27;</span>)!=-<span class="number">1</span>||toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;/center&#x27;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login?redirect=&#x27;</span>+toPath)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>说明: to:<br>目标route;<br>from: 起始route;<br>next: 放行函数</p><ul><li>next(): 执行下一个守卫回调, 如果没有跳转到目标路由</li><li>next(false)/不执行: 跳转流程在当前处中断, 不会跳转到目标路由组件</li><li>next(path): 跳转到指定的另一个路由</li></ul><ol start="2"><li>全局后置守卫: 在跳转到某个路由组件之后</li></ol><p>router.afterEach((to, from) =&gt; {})</p><ol start="3"><li>路由独享守卫</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由独享守卫</span></span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 去交易页面，必须是从购物车来的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&quot;/shopcart&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>3 组件守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 组件内守卫</span></span><br><span class="line">    <span class="title function_">beforeRouteEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">      <span class="comment">// 在渲染该组件的路由被confirm前调用</span></span><br><span class="line">      <span class="comment">// 不能获取组件实例this，因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">      <span class="comment">// 但可以通过next(component =&gt; &#123;&#125;), 在回调函数中访问组件对象</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">from</span>.<span class="property">path</span>==<span class="string">&#x27;/pay&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组件对象将要更新前调用, 可以访问this</span></span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;&#125;,</span><br><span class="line"><span class="comment">// 在当前组件离开前调用, 可以访问this</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">     <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/02/25/git/"/>
      <url>/2023/02/25/git/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p><ul><li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li><li>在不影响现行开发工作的情况下对代码进行维护</li><li>开发时，某段代码被多人修改时，处理代码的冲突问题</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://git-scm.com/">Git</a>无脑下载</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;zoujingke&quot;</span><br><span class="line">git config --global user.name &quot;zoujk640852@<span class="number">163</span>.com&quot;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>git status：查看当前仓库的状态，是否被git管理<br>git init：初始化仓库<br>git log: 查看操作日志</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>被git管理的文件有三种状态：</p><ul><li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li><li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li><li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li></ul><p>可以通过git status查看文件的状态</p><p>新添加的文件处于未跟踪状态（未被git管理）:</p><ul><li>未跟踪-&gt;暂存：git add <filename></li><li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li><li>未修改-&gt;修改：修改代码后，转为修改状</li><li>修改-&gt;暂存：git add <filename></li></ul><p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>恢复文件：<br>git restore <filename> | git restore *<br>删除文件：<br>git rm <filename> 若文件当前是修改状态，不会删除文件。<br>git rm <filename> -f 强制删除<br>取消暂存状态：<br>git restore –stage<br>移动文件：（重命名）<br>git mv <oldfilename> <newfilename></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p><p>git branch 查看所有分支<br>git branch &lt;分支名&gt; 创建分支<br>git branch -d &lt;分支名&gt; 删除分支<br>git switch &lt;分支名&gt; 切换当前所处分支<br>git branch -c &lt;分支名&gt; 创建分支且设为当前所处分支<br>git merge &lt;分支名&gt; 将该分支合并到主分支上</p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>开发中，除了通过merge合并分支外，还可以通过变基完成分支的合并。merge合并分支时，在提交记录中会将所有的分支创建和分支合并的过程全部都显示出来，这样当项目比较复杂，开发过程比较波折时，必须要反复地创建、合并、删除分支。但是这样会使得代码的提交记录会变得极其混乱。</p><p>变基原理：</p><ol><li>当发起变基时，git会首先找到两条分支的最近的共同祖先。</li><li>对比当前分支相对于祖先的历史提交，并且将它们提取处理存储到一个临时文件中</li><li>将当前部分指向目标的基底</li><li>以当前基底开始，重新执行历史操作</li></ol><p>变基和merge对于合并分支来说最终的结果是一样的，但是变基会使得代码的提交记录会更整洁更清晰。注意！大部分情况下合并和变基是可以互换的，但是如果分支已经提交给了远程仓库，尽量不要使用变基。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>以上对于git的所有操作都是在本地进行的。在开发中，我们需要一个远程的git仓库。远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p><p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p><p>将本地库上传git：</p><p>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:Peggyzou/-.git   origin：远程库的名字   后面为远程库的url<br>git branch -M main   修改分支的名字<br>git push -u origin main   将代码上传到服务器上</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/12/hello-world/"/>
      <url>/2023/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
