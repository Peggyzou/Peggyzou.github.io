<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2023/04/20/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/04/20/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>懒加载经常出现在前端面试中，是前端性能优化的常用技巧。懒加载也叫延迟加载，把非关键资源先不加载，等用到了再加载，将加载非关键资源的时间推迟，而加快页面的初始加载时间。懒加载经常被用在图片、视频、音频、JavaScript 文件等资源加载上，本文主要讨论图片的懒加载。通过本文你能收获：</p><ul><li>图片懒加载的原理</li><li>实现图片懒加载的四种方案的原理以及优缺点</li><li>图片懒加载的一些优化</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>图片懒加载的原理是没有在可视区域的图片暂时不加载图片，等进入可视区域后在加载图片，这样可以减少初始页面加载的图片数量而提升页面加载速度。<br>图片懒加载在提升页面加载速度的同时也会伴随用户看其他未展示的图片时会有等待时间；图片加载显示会伴有布局抖动等问题。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>图片懒加载的关键是：判断一个元素是否在可视区域。</p><h2 id="通过offsetTop来计算是否在可视区域内"><a href="#通过offsetTop来计算是否在可视区域内" class="headerlink" title="通过offsetTop来计算是否在可视区域内"></a>通过offsetTop来计算是否在可视区域内</h2><p>可视区域高度是 <code>document.documentElement.clientHeight</code> ，而可视区域的位置是在滚动条滚动位置 <code>scrollTop</code> 到 <code>scrollTop+document.documentElement.clientHeight</code>之间。因此通过 <code>image.offsetTop &lt;= document.documentElement.clientHeight + document.documentElement.scrollTop</code> 判断图片是否可以在可视区域内。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">var</span> lazyImages <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">".lazyload"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      lazyImages<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">image</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> image<span class="token punctuation">.</span>offsetTop <span class="token operator">&lt;=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">+</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          image<span class="token punctuation">.</span>src <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"data-src"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></code></pre><p>添加滚动条监听。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">  window<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>html结构。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"./default.gif"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"lazyload"</span> data<span class="token operator">-</span>src<span class="token operator">=</span><span class="token string">"./photo-1.jpg"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面只是简单的实现图片懒加载，在实际开发中还要很多细节需要优化：<br>首先是兼容性，这里有两个点涉及到兼容性：<code>document.documentElement.clientHeight</code> 和 <code>document.documentElement.scrollTop</code> 。<br>获取浏览器窗口的内部高度方法有 <code>window.innerHeight</code>、<code>document.documentElement.clientHeight</code>。<br><code>window.innerHeight</code>兼容性是 ie9+ 和其他主流浏览器。<code>document.documentElement.clientHeight</code> 浏览器都支持。</p><p>获取滚动位置方法有 <code>window.pageYOffset</code> 和 <code>document.documentElement.scrollTop</code> 。 <code>window.pageYOffset</code> 兼容性是 ie9+ 和其他主流浏览器。</p><p>第二优化点是offsetTop</p><blockquote><p>offsetParent 元素有滚动条的情况下计算会不会有问题?<strong>HTMLElement.offsetTop</strong> 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部内边距的距离</p></blockquote><p>offsetTop 是相对其 offsetParent 元素的并不是相对浏览器窗口可视区域的。如果图片元素有 offsetParent 那么 offsetTop 是有偏差的</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getBoundingClientTop</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> top <span class="token operator">=</span> el<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>  <span class="token keyword">let</span> parent <span class="token operator">=</span> el<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    top <span class="token operator">+=</span> parent<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>第三优化点避免赋值 src 。 代码是通过 lazyload 类获取需要懒加载的元素，这样会把之前已经加载图片的元素也获取到了，而重复设置 src属性。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">var</span> lazyImages <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">".lazyload[data-src]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     lazyImages<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">image</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>         <span class="token function">getBoundingClientTop</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span> <span class="token operator">&lt;=</span>         document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">+</span>           document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop       <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         image<span class="token punctuation">.</span>src <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"data-src"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         image<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span><span class="token string">"data-src"</span><span class="token punctuation">)</span>       <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span></code></pre><p>通过 lazyload 类并且有 data-src 来获取元素，src 设置完后移除 data-src 属性来避免重复设置 src 。</p><p>第四优化点 onscroll 是否添加防抖。<br>onscroll 常用的优化点是加入防抖来减少事件触发的频率，但这里如果加了防抖，计算元素是否在可视区域内的精度就差很多，当滚动速度比较快的情况下加载反应不灵敏，这里就要找平衡点。</p><p>第五优化点页面中局部的 div 滚动图片懒加载。<br>除了整个页面的滚动图片懒加载，也有页面中局部滚动图片懒加载，就需要给制定的有滚动条 dom 元素绑定onscroll 事件。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">srcollDom<span class="token punctuation">.</span><span class="token function-variable function">onscroll</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">lazyload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>并且获取图片 top 是相对有滚动条 dom 元素</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getBoundingClientTop</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">getBoundingClientTop</span><span class="token punctuation">(</span>srcollDom<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> srcollDom<span class="token punctuation">.</span>clientHeight <span class="token operator">+</span> srcollDom<span class="token punctuation">.</span>scrollTop</code></pre><p>第六优化点加载图片的时间点提前。<br>代码中是图片元素进入可视区域后才加载图片，用户就需要等待一段时间才能看到图片显示出来，如果把图片加载时间提前，图片元素距离可视区域一定范围内就加载图片，那么用户等待时间就会减少一些。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性好，各个环节可以控制。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>性能相对不是很好，滚动事件频繁触发，并且获取元素的位置信息，可能会强行触发重排和重绘导致一定的性能消耗。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="布局抖动"><a href="#布局抖动" class="headerlink" title="布局抖动"></a>布局抖动</h2><p>布局抖动是因为开始图片没有宽高，内容显示出来后有了宽高导致位置变动。带来的影响主要是用户体验不好，用户的注意力已经锁定了某个区域准备阅读，突然那个区域下移了，中断阅读而重新定位。可以直接在 img 标签上设置要加载图片的宽高。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"blank.gif"</span> data<span class="token operator">-</span>src<span class="token operator">=</span><span class="token string">"normal.jpg"</span> style<span class="token operator">=</span><span class="token string">"width:800px;height:600px;"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>虽然响应式下图片的宽高会变，但是图片的宽高比是不变的，图片的宽高比变了图片也就变形了。所以 img 标签设定图片宽高比，就能根据不同视图的宽度算出不同高度。 先创建一个宽高比为 5:1 的 div。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"padding-bottom: 20%;background-color: green;"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>padding 为百分比是相对自身宽度的百分比。 然后再创建了一个宽高比为 5:1 的 img。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"padding-bottom: 20%;position: relative;"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>img style<span class="token operator">=</span><span class="token string">"position:absolute;width: 100%;height:100%"</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>这样就能适应响应式的宽度改变，这种方式叫 Aspect Ratio Boxes。<br>占位图片可以设置成原图片的小尺寸图片，被放大后图片变模糊，这样开始加载小图片但图片的轮廓出现，后面在加载大图片显示清晰，给用户的体验是图片开始就在加载，然后加载完成就变清晰了。<br>img 标签 srcset 属性是处理响应式图片的。懒加载中可以设置 data-srcset 来延迟修改 srcset 属性。</p><h2 id="SEO不友好"><a href="#SEO不友好" class="headerlink" title="SEO不友好"></a>SEO不友好</h2><p><code>&lt;img&gt;</code> 标签中的 src 属性携带的仍然是原始大小的图片确保了站外 SEO、社会化分享、RSS 等不会读不到原图。Aspect Ratio Boxes 方式使占位图片适应响应式，srcset 属性存放了一张原图的小尺寸缩略图阻止 src 原图的加载而加载缩略图优化加载体验，最后延迟将 data-srcset 的值赋值到 srcset 中。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li><a href="https://link.juejin.cn/?target=https://github.com/tuupola/lazyload" title="https://github.com/tuupola/lazyload">lazyload.js</a><br>是 IntersectionObserver 方式，而且当浏览器不支持 IntersectionObserver 的时候就直接加载图片，没有延迟加载的功能。</li><li><a href="https://link.juejin.cn/?target=https://github.com/hilongjw/vue-lazyload" title="https://github.com/hilongjw/vue-lazyload">vue-lazyload</a><br>使用 IntersectionObserver 和 getBoundingClientRect 方式，默认 getBoundingClientRect 方式懒加载，里面的一些封装细节有很多有意思的地方，不止绑定了 onscroll 事件还绑定了 ‘onwheel’、’onmousewheel’、’onresize’、 ‘onanimationend’、’ontransitionend’、’ontouchmove’问什么要绑定这么多事件，插件为什么默认 getBoundingClientRect 方式而不用 IntersectionObserver 方式。</li><li><a href="https://link.juejin.cn/?target=https://github.com/twobin/react-lazyload" title="https://github.com/twobin/react-lazyload">react-lazyload</a><br>只用了 getBoundingClientRect 方式。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、token</title>
      <link href="/2023/04/04/cookie%E3%80%81session%E3%80%81token/"/>
      <url>/2023/04/04/cookie%E3%80%81session%E3%80%81token/</url>
      
        <content type="html"><![CDATA[<h1 id="面试必问-session，cookie和token的区别"><a href="#面试必问-session，cookie和token的区别" class="headerlink" title="面试必问:session，cookie和token的区别"></a>面试必问:session，cookie和token的区别</h1><h1 id="session，cookie和token究竟是什么"><a href="#session，cookie和token究竟是什么" class="headerlink" title="session，cookie和token究竟是什么"></a><strong>session，cookie和token究竟是什么</strong></h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>cookie，session，token作为面试必问题，很多同学能答个大概，但是又迷糊不清，希望本篇文章对大家有所帮助</p><h2 id="http是一个无状态协议"><a href="#http是一个无状态协议" class="headerlink" title="http是一个无状态协议"></a><strong>http是一个无状态协议</strong></h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a><strong>cookie和session</strong></h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li><p>首先，客户端会发送一个http请求到服务器端。</p></li><li><p>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解<br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p></li><li><p>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</p></li><li><p>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</p><p><img src="/2023/04/04/cookie%E3%80%81session%E3%80%81token/1.png" alt="1680574215469"></p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="cookie和session通俗小结"><a href="#cookie和session通俗小结" class="headerlink" title="cookie和session通俗小结"></a><strong>cookie和session通俗小结</strong></h3><p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p><h2 id="token定义"><a href="#token定义" class="headerlink" title="token定义"></a><strong>token定义</strong></h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存<a href="https://cloud.tencent.com/solution/tb-digitalid?from=20065&from_column=20065">身份认证</a>相关的数据。</p><h3 id="token组成"><a href="#token组成" class="headerlink" title="token组成"></a><strong>token组成</strong></h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放"><a href="#存放" class="headerlink" title="存放"></a><strong>存放</strong></h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>中</p><h3 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a><strong>token认证流程</strong></h3><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h2 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a><strong>token可以抵抗csrf，cookie+session不行</strong></h2><p>因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h2 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a><strong>分布式情况下的session和token</strong></h2><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种解决session负载均衡的方法。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等<a href="https://cloud.tencent.com/product/tke?from=20065&from_column=20065">容器</a>中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><p><strong>补充:JWT</strong></p><p>JWT就是token的一种实现方式，并且基本是java web领域的事实标准。</p><p>JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输token</p><p>JWT 由 3 部分构成:</p><p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。流程：</p><p>在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，</p><p>然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: 你的Token。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="/2023/03/29/react/"/>
      <url>/2023/03/29/react/</url>
      
        <content type="html"><![CDATA[<h2 id="JSX的注意事项"><a href="#JSX的注意事项" class="headerlink" title="JSX的注意事项"></a>JSX的注意事项</h2><ol><li>JSX不是字符串，不要加引号</li><li>JSX中html标签应该小写，react组件标签应该大写开头</li><li>JSX中有且只有一个根标签</li><li>JSX的标签必须正确结束（自结束标签必须写结束符）</li><li>在JSX中可以使用{ }嵌入表达式（有值的语句就是表达式）</li><li>如果表达式是空值、布尔值、undefined，将不会显示</li><li>在JSX中，属性可以直接在标签中设置<br>注意：<br>class需要使用对象设置<br>style中必须使用对象设置</li></ol><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>在react中操作的元素被称为react元素，并不是真正的元素DOM元素</p><p>react通过虚拟DOM将react元素和元素DOM进行映射，虽然操作的是react元素，但是这些操作最终都会在真实的DOM中体现</p><p>虚拟DOM的好处：</p><ol><li>降低API复杂度</li><li>解决兼容问题</li><li>提升性能（减少DOM的不必要操作）</li></ol><p>每当调用root.render()时，页面就会重新渲染，react会通过diffing算法，将新的元素与旧的元素进行比较，通过比较找到发生变化的元素，并且只对变化的元素进行修改，没有变化的不处理。</p><p>比较两次数据时，会先比较父元素，如果不同，直接所有元素全部替换，父元素一致，再逐个比较子元素，直到找到所有发生变化的元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/25/1/"/>
      <url>/2023/03/25/1/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>        let arr = '[[1,2,3],[1,2,4]]'        let arr1 = Number("123");        let arr2 = new Number("123")        console.log(typeof arr1)        console.log(arr2)        let a='c'        let obj={            [1+'2']:'e',            [a]:'d'        }        console.log(obj)    </script></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS、XSRF</title>
      <link href="/2023/03/23/XSS%E3%80%81XSRF/"/>
      <url>/2023/03/23/XSS%E3%80%81XSRF/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是XSS？"><a href="#什么是XSS？" class="headerlink" title="什么是XSS？"></a>什么是XSS？</h3><p>跨站脚本（Cross-site scripting，简称为：CSS, 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。</p><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h3 id="XSS-常见的注入方法："><a href="#XSS-常见的注入方法：" class="headerlink" title="XSS 常见的注入方法："></a>XSS 常见的注入方法：</h3><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><h3 id="XSS常见分类"><a href="#XSS常见分类" class="headerlink" title="XSS常见分类"></a>XSS常见分类</h3><p><strong>反射型（非持久型）XSS</strong> 、 <strong>存储型（持久型）XSS</strong> 、<strong>DOM型XSS</strong></p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS主要是诱导欧诺个户点击一个URL链接，在这个URL链接里就嵌入了恶意脚本，点击URL链接之后，那个URL指向的是黑客自己的服务器上的一段恶意脚本。然后恶意脚本被返回到用户的浏览器里就会运行，然后就可以控制你的浏览器里的行为了，这个控制行为就很恐怖了，他可以干很多的事儿。</p><p>反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，所以它的危害性较存储型要小。</p><p><img src="/2023/03/23/XSS%E3%80%81XSRF/1.png" alt="1679562778477"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型（或 HTML 注入型/持久型）XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站，不需要特制的链接来执行。黑客仅仅需要利用 XSS 漏洞提交代码（反射型XSS通常只在url中）到一个网站上其他用户可能访问的地方。这些地区可能是 <code>博客评论，用户评论，留言板，聊天室，HTML 电子邮件</code>，和其他的许多地方。一旦用户访问受感染的页，执行是自动的。（比如在评论区文本框输入js恶意代码，这段代码被保存到数据库，用户翻看评论区时就会自动执行这段代码）</p><p><img src="/2023/03/23/XSS%E3%80%81XSRF/2.png" alt="1679562990035"></p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p><p>DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token constant">DOM</span> Based <span class="token constant">XSS</span> Demo<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token keyword">function</span> <span class="token function">xsstest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> str <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> "<span class="token operator">&lt;</span>img        src<span class="token operator">=</span><span class="token string">'"+str+"'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>img<span class="token operator">></span>"<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"output"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> id<span class="token operator">=</span><span class="token string">"input"</span> size<span class="token operator">=</span><span class="token number">50</span> value<span class="token operator">=</span><span class="token string">""</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"submit"</span> onclick<span class="token operator">=</span><span class="token string">"xsstest()"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><h3 id="XSS攻击代码出现的场景"><a href="#XSS攻击代码出现的场景" class="headerlink" title="XSS攻击代码出现的场景"></a>XSS攻击代码出现的场景</h3><p>有url（跳转）或者有输入（请求）的地方</p><h3 id="XSS-攻击的预防"><a href="#XSS-攻击的预防" class="headerlink" title="XSS 攻击的预防"></a>XSS 攻击的预防</h3><p><strong>常用防范方法</strong></p><ul><li>httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。</li><li>输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li>转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善。想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库。</li><li>白名单: 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><h4 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a><strong>预防存储型和反射型 XSS 攻击</strong></h4><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</p><p>预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><p>TML转义前面已经说过,这里仅仅谈谈纯前端渲染</p><p><strong>纯前端渲染的过程：</strong></p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。</p><h4 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a><strong>预防 DOM 型 XSS 攻击</strong></h4><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML、.outerHTML、document.write() </code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code> .textContent、.setAttribute()</code> 等。</p><p>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover </code>等， 标签的 <code>href</code>属性，JavaScript 的 <code>eval()、setTimeout()、setInterval()</code>等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免</p><h3 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><p>如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><img src="/2023/03/23/XSS%E3%80%81XSRF/3.png" alt="1679583818295"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生</p><ul><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ul><h3 id="常见的CSRF攻击类型"><a href="#常见的CSRF攻击类型" class="headerlink" title="常见的CSRF攻击类型"></a>常见的CSRF攻击类型</h3><h4 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h4><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://bank.example/withdraw?amount=10000&amp;for=hacker<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span> </code></pre><p>在受害者访问含有这个img的页面后，浏览器会自动向<a href="http://bank.example/withdraw?amount=10000&amp;for=hacker">http://bank.example/withdraw?amount=10000&amp;for=hacker</a> 发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求</p><h4 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h4><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><pre class="language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://bank.example/withdraw<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>POST</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xiaoming<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>amount<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>for<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"> document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> </code></pre><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><h4 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h4><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker<span class="token punctuation">"</span></span> <span class="token attr-name">taget</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>重磅消息！！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">/></span></span></code></pre><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险</p><h3 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h3><ul><li>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</li><li>本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。 XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相关问题</title>
      <link href="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="将文章部署到远程仓库不成功时，可能的问题："><a href="#将文章部署到远程仓库不成功时，可能的问题：" class="headerlink" title="将文章部署到远程仓库不成功时，可能的问题："></a>将文章部署到远程仓库不成功时，可能的问题：</h2><p>如果出现下图中的问题，说明未连接到远程仓库</p><p><img src="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.PNG" alt="1679554899216"></p><p>右键选择Git Bash Here，输入以下命令进行连接</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:yourName/repositoryname.git</code></pre><p>yourName是用户名，repositoryname是仓库名字，地址也可以直接在github中复制</p><p><img src="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.PNG" alt="1679554369659"></p><p>连接到远程仓库后，重新生成一次ssh key，在Git Hub Here中输入ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#x6f;&#117;&#x72;&#101;&#109;&#97;&#105;&#108;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x79;&#x6f;&#117;&#x72;&#101;&#109;&#97;&#105;&#108;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a>“</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail@example.com"</span></code></pre><p>xxxxxx<a href="mailto:youremail@example.com">@example.com</a>改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key），此时会提醒密钥所在位置，如下图所示</p><p><img src="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/3.PNG" alt="1679555216959"></p><p>找到密钥后，复制粘贴到github中：个人头像-setting-SSH and GPG keys</p><p><img src="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/4.PNG" alt="1679556436250"></p><p>即可成功部署文章</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型/原型链</title>
      <link href="/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a><strong>原型的作用</strong></h2><p>原型被定义为给其它对象提供共享属性的对象，函数的实例可以共享原型上的属性和方法</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>它的作用就是当你在访问一个对象上属性的时候，如果该对象内部不存在这个属性，那么就会去它 <code>__proto__</code>属性所指向的对象（原型对象）上查找。如果原型对象依旧不存在这个属性，那么就会去其原型的 <code>__proto__</code>属性所指向的原型对象上去查找。以此类推，直到找到 <code>null</code>，而这个查找的线路，也就构成了我们常说的<strong>原型链</strong></p><p><strong>原型链和作用域的区别：</strong> 原型链是查找对象上的属性，作用域链是查找当前上下文中的变量</p><h2 id="proto-、prototype、constructor属性介绍"><a href="#proto-、prototype、constructor属性介绍" class="headerlink" title="proto 、prototype、constructor属性介绍"></a><strong>proto</strong> 、prototype、constructor属性介绍</h2><ol><li>js中对象分为两种，普通对象和函数对象</li><li><code>__proto__</code>和 <code>constructor</code>是对象独有的。<code>prototype</code>属性是函数独有的，它的作用是包含可以给特定类型的所有实例提供共享的属性和方法；但是在 JS 中，函数也是对象，所以函数也拥有 <code>__proto__</code>和 <code>constructor</code>属性</li><li><code>constructor</code>属性是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数 <code>构造函数.prototype.constructor === 该构造函数本身</code></li><li>一个对象的 <code>__proto__</code>指向其构造函数的 <code>prototype</code>,<code>函数创建的对象.__proto__ === 该函数.prototype</code></li><li>特殊的 <code>Object</code>、<code>Function</code></li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 的基本用法，它可以判断一个对象的原型链上是否包含该构造函数的原型，经常用来判断对象是否为该构造函数的实例</p><p><strong>特殊示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre><p><strong>手写instanceof方法</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> proto <span class="token operator">=</span> obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instanceOf</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> Dog<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true true</span></code></pre><h2 id="instanceof与typeof的区别"><a href="#instanceof与typeof的区别" class="headerlink" title="instanceof与typeof的区别"></a><strong>instanceof与typeof的区别</strong></h2><p>1）<code>typeof</code>一般被用于来判断一个变量的类型</p><p>typeof可以用来判断 <code>number、undefined、symbol、string、function、boolean、object</code> 这七种数据类型，特殊情况：<code>typeof null === &#39;object&#39;</code></p><p>2）<code>instanceof</code>判断一个对象的原型链上是否包含该构造函数的原型</p><h2 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h2><p><strong>new一个对象，到底发生什么？</strong></p><p>1）创建一个对象，该对象的原型指向构造函数的原型</p><p>2）调用该构造函数，构造函数的this指向新生成的对象</p><p>3）判断构造函数是否有返回值，如果有返回值且返回值是一个对象或一个方法，则返回该值；否则返回新生成的对象</p><p><strong>构造函数有返回值的案例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"ming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;test:1&#125; </span></code></pre><p><strong>手写new</strong></p><pre class="language-none"><code class="language-none">function selfNew(fn, ...args) &#123;  &#x2F;&#x2F; 创建一个instance对象，该对象的原型是fn.prototype  let instance &#x3D; Object.create(fn.prototype);  &#x2F;&#x2F; 调用构造函数，使用apply，将this指向新生成的对象  let res &#x3D; fn.apply(instance, args);  &#x2F;&#x2F; 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象  return typeof res &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof res &#x3D;&#x3D;&#x3D; &quot;function&quot; ? res : instance;&#125;</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>多种继承方式</strong></p><p>1）原型链继承，缺点：引用类型的属性被所有实例共享<br>2）借用构造函数（经典继承）<br>3）原型式继承<br>4）寄生式继承<br>5）组合继承<br>6）寄生组合式继承</p><p><strong>寄生组合式继承的优势</strong></p><p>优势：借用父类的构造函数，在不需要生成父类实例的情况下，继承了父类原型上的属性和方法</p><p><strong>手写寄生组合式继承</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 精简版</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父类的构造函数</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 利用Object.create生成一个对象，新生成对象的原型是父类的原型，并将该对象作为子类构造函数的原型，继承了父类原型上的属性和方法</span>    <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 原型对象的constructor指向子类的构造函数</span>    <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通用版</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 调用父类的构造函数</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 目的是为了继承父类原型上的属性和方法，在不需要实例化父类构造函数的情况下，避免生成父类的实例，如new Parent()</span>  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token comment">// 创建一个空对象，该对象原型指向父类的原型对象</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 等同于 Child.prototype = Object.create(Parent.prototype)</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tom</span></code></pre><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p><strong>Class 类可以看作是构造函数的语法糖</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Point <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p><strong>Class 类中定义的方法，都是定义在该构造函数的原型上</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 等同于</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p><strong>使用 <code>static</code>关键字，作为静态方法</strong>（静态方法，只能通过类调用，实例不能调用）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Foo<span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'hello'</span></code></pre><p><strong>实例属性的简写写法</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  bar <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  baz <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 等同于</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong><code>extends</code> 关键字，底层是利用的寄生组合式继承</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// li</span></code></pre><p>ES6的 Class 内部是基于寄生组合式继承，它是目前最理想的继承方式<br>ES6的 Class 允许子类继承父类的静态方法和静态属性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/03/15/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/15/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包：就是函数引用了外部作用域的变量</strong></p><p><strong>闭包常见的两种情况：</strong></p><p>一是函数作为返回值； 另一个是函数作为参数传递</p><p><strong>闭包的作用：</strong></p><p>可以让局部变量的值始终保持在内存中；对内部变量进行保护，使外部访问不到</p><p>最常见的案例：<code>函数节流和防抖</code></p><p><strong>闭包的垃圾回收：</strong></p><p>副作用：不合理的使用闭包，会造成内存泄露(就是该内存空间使用完毕之后未被回收)</p><p>闭包中引用的变量直到闭包被销毁时才会被垃圾回收</p><p><strong>闭包的示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 原始题目</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1s后打印出5个5</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ⬅️利用闭包，将上述题目改成1s后，打印0,1,2,3,4</span><span class="token comment">// 方法一：</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 方法二：</span><span class="token comment">// 利用setTimeout的第三个参数，第三个参数将作为setTimeout第一个参数的参数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三个参数i,将作为fn的参数</span><span class="token punctuation">&#125;</span><span class="token comment">// ⬅️将上述题目改成每间隔1s后，依次打印0,1,2,3,4</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2023/03/15/this/"/>
      <url>/2023/03/15/this/</url>
      
        <content type="html"><![CDATA[<h1 id="this的5种绑定方式"><a href="#this的5种绑定方式" class="headerlink" title="this的5种绑定方式"></a><strong>this的5种绑定方式</strong></h1><p>1）默认绑定(非严格模式下this指向全局对象，严格模式下函数内的this指向 <code>undefined</code>)</p><p>2）隐式绑定(当函数引用有上下文对象时, 如 <code>obj.foo()</code>的调用方式, foo内的this指向obj)</p><p>3）显示绑定(通过call或者apply方法直接指定this的绑定对象, 如 <code>foo.call(obj)</code>)</p><p>4）new构造函数绑定，this指向新生成的对象</p><p>5）箭头函数，this指向的是定义该函数时，外层环境中的this，<strong>箭头函数的this在定义时就决定了，不能改变</strong></p><p><strong>this 题目1</strong></p><pre class="language-none"><code class="language-none">&quot;use strict&quot;;var a &#x3D; 10; &#x2F;&#x2F; var定义的a变量挂载到window对象上function foo () &#123;  console.log(&#39;this1&#39;, this)  &#x2F;&#x2F; undefined  console.log(window.a)  &#x2F;&#x2F; 10  console.log(this.a)  &#x2F;&#x2F;  报错，Uncaught TypeError: Cannot read properties of undefined (reading &#39;a&#39;)&#125;console.log(&#39;this2&#39;, this)  &#x2F;&#x2F; windowfoo();</code></pre><p>注意：开启了严格模式，只是使得函数内的this指向 <code>undefined</code>，它并不会改变全局中this的指向。因此 <code>this1</code>中打印的是 <code>undefined</code>，而 <code>this2</code>还是 <code>window</code>对象。</p><p><strong>this 题目2</strong></p><pre class="language-none"><code class="language-none">let a &#x3D; 10const b &#x3D; 20function foo () &#123;  console.log(this.a)  &#x2F;&#x2F; undefined  console.log(this.b)  &#x2F;&#x2F; undefined&#125;foo();console.log(window.a) &#x2F;&#x2F; undefined  </code></pre><p>如果把 var 改成了 let 或 const，变量是不会被绑定到window上的，所以此时会打印出三个undefined</p><p><strong>this 题目3</strong></p><pre class="language-none"><code class="language-none">var a &#x3D; 1function foo () &#123;  var a &#x3D; 2  console.log(this)  &#x2F;&#x2F; window  console.log(this.a) &#x2F;&#x2F; 1&#125;foo()</code></pre><p>foo()函数内的this指向的是window，因为是window调用的foo，打印出的 <code>this.a</code>是window下的 <code>a</code></p><p><strong>this 题目4</strong></p><pre class="language-none"><code class="language-none">var obj2 &#x3D; &#123;    a: 2,    foo1: function () &#123;      console.log(this.a) &#x2F;&#x2F; 2    &#125;,    foo2: function () &#123;      setTimeout(function () &#123;        console.log(this) &#x2F;&#x2F; window        console.log(this.a) &#x2F;&#x2F; 3      &#125;, 0)    &#125;  &#125;  var a &#x3D; 3    obj2.foo1()  obj2.foo2() </code></pre><p>对于 <code>setTimeout</code>中的函数，这里存在隐式绑定的this丢失，也就是当我们将函数作为参数传递时,会被隐式赋值，回调函数丢失this绑定，因此这时候setTimeout中函数内的this是指向 <code>window</code></p><p><strong>this 题目5</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'obj'</span><span class="token punctuation">,</span> <span class="token function-variable function">foo1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// window</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function-variable function">foo2</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// obj</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// obj</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'window'</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这道题非常经典，它证明了<strong>箭头函数内的this是由外层作用域决定的</strong></p><p><strong>题目5解析：</strong></p><p>1）对于 <code>obj.foo1()</code>函数的调用，它的外层作用域是window，对象obj当然不属于作用域了(作用域只有全局作用域、函数作用域、块级作用域)，所以会打印出 <code>window</code></p><p>2）<code>obj.foo2()()</code>，首先会执行 <code>obj.foo2()</code>，这不是个箭头函数，所以它里面的this是调用它的obj对象，因此第二个打印为 <code>obj</code>，而返回的匿名函数是一个箭头函数， <strong>它的this由外层作用域决定</strong> ，那也就是它的this会和foo2函数里的this一样，第三个打印也是 <code>obj</code></p><h1 id="call-apply-bind三者的区别"><a href="#call-apply-bind三者的区别" class="headerlink" title="call apply bind三者的区别"></a>call apply bind三者的区别</h1><ol><li>三者都可以显式绑定函数的this指向</li><li>三者第一个参数都是this要指向的对象，若该参数为undefined或null，this则默认指向全局window传参不同：apply是数组、call是参数列表，而bind可以分为多次传入，实现参数的合并</li><li>call、apply是立即执行，bind是返回绑定this之后的函数，如果这个新的函数作为构造函数被调用，那么this不再指向传入给bind的第一个参数，而是指向新生成的对象</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var_let_const</title>
      <link href="/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h1><h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>var定义的变量，没有块的概念，可以跨块访问, 可以变量提升</li><li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明</li><li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明</li></ol><p><strong>let和const声明的变量只在块级作用域内有效，示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 "i is not defined"</span><span class="token punctuation">&#125;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="var与let的经典案例"><a href="#var与let的经典案例" class="headerlink" title="var与let的经典案例"></a>var与let的经典案例</h2><p>用var定义i变量，循环后打印i的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 案例1</span><span class="token comment">// i是var声明的，在全局范围内都有效，全局只有一个变量i，输出的是最后一轮的i值，也就是 10</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span></code></pre><p>用let定义i变量，循环后打印i的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 案例2</span><span class="token comment">// 用let声明i，for循环体内部是一个单独的块级作用域，相互独立，不会相互覆盖</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></code></pre><h2 id="let-实现原理"><a href="#let-实现原理" class="headerlink" title="let 实现原理"></a>let 实现原理</h2><p><strong>借助闭包和函数作用域来实现块级作用域的效果</strong></p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 用var实现案例2的效果var a &#x3D; [];var _loop &#x3D; function _loop(i) &#123;  a[i] &#x3D; function() &#123;    console.log(i);  &#125;;&#125;;for (var i &#x3D; 0; i &lt; 10; i++) &#123;  _loop(i);&#125;a[0](); &#x2F;&#x2F; 0</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域：可访问变量的集合</p><p>作用域最大的用处就是 <code>隔离变量</code>，不同作用域下同名变量不会有冲突</p><h2 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a>作用域类型</h2><p><code>全局作用域</code>、<code>函数作用域</code>、ES6中新增了 <code>块级作用域</code></p><p><strong>函数作用域</strong></p><p>是指声明在函数内部的变量，函数的作用域在函数定义的时候就决定了</p><p><strong>块作用域</strong></p><p>1）块作用域由 <code>&#123; &#125;</code>包括，if和for语句里面的 <code>&#123; &#125;</code>也属于块作用域</p><p>2）在块级作用域中，可通过let和const声明变量，该变量在指定块的作用域外无法被访问</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，首先会先从当前上下文的变量对象（作用域）中查找，如果没有找到，就会从父级的执行上下文的变量对象中查找，如果还没有找到，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 <code>作用域链</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3</title>
      <link href="/2023/03/13/vue3/"/>
      <url>/2023/03/13/vue3/</url>
      
        <content type="html"><![CDATA[<p>MVVM: Model-View-View Model</p><p>vue负责vm的工作(视图模型)，通过vue可以将视图和模型相关联</p><p>vue思想：</p><ul><li>组件化开发</li><li>声明式编程</li></ul><p>在vue3中，组件就是一个普通的js对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS注意点</title>
      <link href="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><h3 id="怎么创建BFC"><a href="#怎么创建BFC" class="headerlink" title="怎么创建BFC"></a>怎么创建BFC</h3><ol><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block、table-cell、table-caption、flex、inline-flex</li><li>overflow不为visible</li></ol><blockquote><p>虽然添加上述的任意一条都能创建BFC，但会有一些副作用</p></blockquote><ol><li>float: left 将把元素移至左侧，并被其他元素环绕</li><li>display: table 可能引发响应性问题</li><li>overflow: scroll 可能产生多余的滚动条</li></ol><p><strong>最常用是overflow为hidden，这种方式的副作用最小，其他三种方式的副作用较大</strong></p><h3 id="BFC中盒子怎么对齐"><a href="#BFC中盒子怎么对齐" class="headerlink" title="BFC中盒子怎么对齐"></a>BFC中盒子怎么对齐</h3><p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。</p><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>常规流布局时，盒子都是垂直排列，两者之间的间距由各自的外边距所决定，但不是二者外边距之和。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>p<span class="token operator">></span>Sibling <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span>p<span class="token operator">></span>Sibling <span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment">//对应的CSS</span><span class="token punctuation">.</span>container <span class="token punctuation">&#123;</span>  background<span class="token operator">-</span>color<span class="token operator">:</span> red<span class="token punctuation">;</span>  <span class="token literal-property property">overflow</span><span class="token operator">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* creates a block formatting context */</span><span class="token punctuation">&#125;</span>p <span class="token punctuation">&#123;</span>  background<span class="token operator">-</span>color<span class="token operator">:</span> lightgreen<span class="token punctuation">;</span>  <span class="token literal-property property">margin</span><span class="token operator">:</span> 10px <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>渲染结果图：</p><p><img src="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/1.PNG" alt="1678677743829"></p><p>在上图中，一个红盒子（div）包含着两个兄弟元素（p），一个BFC已经创建了出来。</p><p>理论上，两个p元素之间的外边距应当是二者外边距之和（20px）但实际上却是10px，这是外边距折叠(Collapsing Margins)的结果。</p><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果按照如下规则计算：</p><ol><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ol><p>产生折叠的必备条件：margin必须是邻接的!</p><h2 id="sticky-粘性布局"><a href="#sticky-粘性布局" class="headerlink" title="sticky 粘性布局"></a>sticky 粘性布局</h2><p><code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是 <code>position:relative</code>和 <code>position:fixed</code>的结合体——当元素在屏幕内，表现为 <code>relative</code>，就要滚出显示器屏幕的时候，表现为 <code>fixed</code></p><p><img src="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/sticky-layout-s.gif" alt="1678679237721"></p><p>正如大家看到，随着页面的滚动，当导航距离上边缘0距离的时候，黏在了上边缘，表现如同 <code>position:fixed</code>。</p><p>这就是 <code>position:sticky</code>最基本的表现，特别适合导航的跟随定位效果。</p><h3 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position:sticky"></a>position:sticky</h3><p><code>position:sticky</code>有个非常重要的特性，那就是 <strong>sticky元素效果完全受制于父级元素们</strong> 。</p><p>这和 <code>position:fixed</code>定位有着根本性的不同，fixed元素直抵页面根元素，其他父元素对其left/top定位无法限制。</p><p><strong>发现了sticky元素一些特性表现：</strong></p><ol><li>父级元素不能有任何 <code>overflow:visible</code>以外的overflow设置，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）。因此，如果你的 <code>position:sticky</code>无效，看看是不是某一个祖先元素设置了 <code>overflow:hidden</code>，移除之即可。</li><li>父级元素设置和粘性定位元素等高的固定的 <code>height</code>高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果。</li><li>同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，且这些父元素正好紧密相连，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li><li>sticky定位，不仅可以设置 <code>top</code>，基于滚动容器上边缘定位；还可以设置 <code>bottom</code>，也就是相对底部粘滞。如果是水平滚动，也可以设置 <code>left</code>和 <code>right</code>值。</li></ol><h3 id="层次滚动实现原理"><a href="#层次滚动实现原理" class="headerlink" title="层次滚动实现原理"></a>层次滚动实现原理</h3><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;article&gt;    &lt;section&gt;        &lt;h4&gt;网曝王宝强殴打马蓉&lt;&#x2F;h4&gt;        &lt;content&gt;            &lt;p&gt;12月2日，有网友爆料称...&lt;&#x2F;p&gt;        &lt;&#x2F;content&gt;        &lt;footer&gt;网友评论：...&lt;&#x2F;footer&gt;    &lt;&#x2F;section&gt;    &lt;section&gt;        &lt;h4&gt;知情人爆料称马蓉闯入王宝强家拿剪刀对峙&lt;&#x2F;h4&gt;        &lt;content&gt;            &lt;p&gt;...&lt;&#x2F;p&gt;        &lt;&#x2F;content&gt;        &lt;footer&gt;网友评论：...&lt;&#x2F;footer&gt;    &lt;&#x2F;section&gt;    ...&lt;&#x2F;article&gt;</code></pre><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">article h4, h4</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">content</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">footer</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> 50vh<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>由于每一段短新闻都在section标签中，属于不同的父元素，因此，滚动的时候，后面的新闻标题才能把前面已经sticky定位的新闻标题推开，这是sticky定位天然的特性，无需任何JavaScript的帮助。所以，<code>position:sticky</code>布局的时候，使用合适的HTML结构很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2023/03/12/webpack/"/>
      <url>/2023/03/12/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="构建工具介绍"><a href="#构建工具介绍" class="headerlink" title="构建工具介绍"></a>构建工具介绍</h2><p>当我们习惯了在node中编写代码的方式后，再回到前端写html、css、js时会感到各种不便。比如：不能放心地使用模块化规范（浏览器兼容性问题），即使可以使用模块化规范也会面临模块过多时的加载问题。因此迫切希望有一款工具可以对代码进行打包，将多个模块打包成一个文件，这样既可以解决兼容性问题，又可以解决模块过多的问题。</p><p>通过构建工具可以将使用ESM规范编写的代码转换为旧的JS语法，可以使得所有浏览器都支持代码。</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>使用步骤：</p><ol><li>初始化项目 npm init -y</li><li>安装依赖webpack、webpack-cli</li><li>在项目中创建src目录，然后编写代码</li><li>执行npx webpack来对代码进行打包（打包后观察dist目录）</li></ol><p><img src="/2023/03/12/webpack/webpack.png" alt="1678633324626"></p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2023/03/10/nodejs/"/>
      <url>/2023/03/10/nodejs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nodejs.dev/en/">nodejs文档</a></p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程（厂房）：程序运行的环境</li><li>线程（工人）：实行进行运算的东西</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p><h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python 通过多线程来解决，成本高</p><p>node.js 通过异步方式解决</p><p>异步：一段代码的执行不会影响其它代码</p><ul><li>异步的问题：无法通过return设置返回值</li><li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li></ul><p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）</p><p>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p><ul><li>创建promise时，构造函数中需要一个函数作为参数。</li><li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li><li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li><li>通过promise的实例方法then来读取promise中存储的数据</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"哈哈"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p><pre class="language-JS" data-language="JS"><code class="language-JS">Promise.then((result)&#x3D;&gt;&#123;    console.log(&quot;promise中的数据&quot;,result)&#125;,(reason)&#x3D;&gt;&#123;    console.log(&quot;数据&quot;,reason)&#125;)</code></pre><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul><li>catch()用法和then类似，但是只需要一个回调函数作为参数</li><li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>finally()无论是正常存储还是出现异常了，都会执行</li><li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li></ul><h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><ul><li>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）</li><li>finally的返回值不会存到新的promise中</li></ul><h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p><ul><li>PromiseResult: 用来存储数据</li><li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p><h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><pre class="language-JS" data-language="JS"><code class="language-JS">function sum(a,b)&#123;    return new Promise((resolve,reject)&#x3D;&gt;&#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(a+b)        &#125;, 500);    &#125;)&#125;sum(123,456)    .then(result&#x3D;&gt;result+7)    .then(result&#x3D;&gt;result+8)    .then(result&#x3D;&gt;console.log(result))&#125;)</code></pre><p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p><h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul><li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li></ul><pre class="language-JS" data-language="JS"><code class="language-JS">new Promise((resolve,reject)&#x3D;&gt;&#123;            resolve()    &#125;)</code></pre><ul><li>Promise.reject() 创建一个立即拒绝的promise</li><li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误</li></ul><pre class="language-JS" data-language="JS"><code class="language-JS">function sum(a,b)&#123;    return new Promise((resolve,reject)&#x3D;&gt;&#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(a+b)        &#125;, 500);    &#125;)&#125;Promise.all([sum(123,456),sum(5,6),sum(3,4)])</code></pre><ul><li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li><li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li><li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p><p>调用栈：</p><ul><li>栈是一种数据结构，先进后出</li><li>调用栈中放的是要执行的代码<br>任务队列</li><li>队列是一种数据结构，先进先出</li><li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li></ul><p>JS中任务队列有两种</p><ul><li>宏任务队列（大部分代码都去宏任务队列中去排队）</li><li>微任务队列（Promise的回调函数（then、catch、finally））</li></ul><p>整个流程：</p><ol><li>执行调用栈中的代码</li><li>执行微任务队列中的任务</li><li>执行宏任务队列中的任务</li></ol><p>queueMicrotask()用来向微任务队列中添加一个任务</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span><span class="token function">resolve</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出4,33,1,2,3</span></code></pre><p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p><p>注意以下代码的运行顺序</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//输出1,2,3</span></code></pre><p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出1,2,4,3</span></code></pre><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p><ol><li>无法选择要引入模块的哪些内容</li><li>在复杂的场景下容易出错</li></ol><p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p><ul><li>使用require（“模块的路径”）函数引入模块</li><li>引入自定义模块时，模块名要以./或者../开头</li><li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li></ul><p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p><p>访问exports的方式有着两种：</p><ul><li>exports</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li>module.exports</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span></code></pre><p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span></code></pre><p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p><h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p><ul><li>使用.mjs作为扩展名</li><li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li></ul><p>向外部导出内容：export</p><p>导入内容：</p><ul><li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li></ul><p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p><p>导入：</p><ul><li>import 变量名 from “url” 变量名可以随意命名</li></ul><p>es模块都运行在严格模式下</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p><p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p><ul><li>process.exit()  结束当前进程</li><li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> process <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"process"</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出4、3、2、1</span></code></pre><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p><p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p><p>工作目录不同，所产生的绝对路径也就不同</p><p>最终形态：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token keyword">const</span> result <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./05.promise.js"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p><ul><li>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</li><li>fs.readFile()，异步的文件读取方法</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>    path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> buffer</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>主流用法：promise版本的fs</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"fs/promises"</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">buffer</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p><p>npm init 初始化项目，创建package.json文件（需要回答问题）</p><p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p><p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p><ul><li>将包下载到当前项目的node_modules目录下</li><li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li><li>会自动添加package-lock.json文件：加速npm下载的，不用动</li></ul><p>npm i 自动安装所有依赖</p><p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p><p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p><p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p><p>镜像的配置：</p><ul><li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p><p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p><p><a href="https://space.bilibili.com/1500126264">b站</a></p><p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p><p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p><h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p><p>第二步中客户端如何和服务器建立（断开）连接</p><p>答：<br>三次握手（建立连接）</p><ul><li>客户端发送请求连接（SYN:同步）</li><li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li><li>客户端向服务器发送同意连接的信息（ACK：同意）</li></ul><p>四次挥手（断开连接）</p><ul><li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li><li>服务器向客户端返回数据，知道了（ACK）</li><li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li><li>客户端向服务器发数据，可以断开了（ACK）</li></ul><p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p><p>TCP/IP协议族：规定了互联网中所有的通信细节</p><p>网络通信的过程由四层组成</p><ul><li>应用层<br>软件层面，浏览器、服务器都属于应用层</li><li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li><li>网络层<br>负责给数据包，添加信息</li><li>数据链路层<br>传输信息</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的（请求字符串是明文，不安全）</p><h3 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h3><p>客户端发送给服务器的报文称为请求报文</p><p>请求报文的格式：</p><ul><li>请求首行<br>第一部分  get/post：get请求主要用来向服务器请求资源，没有请求体，键值对为明文，安全性差，且不能发送较大的数据；post请求主要用来向服务器发送数据，post请求有请求体，无法在地址栏直接查看，安全性较好，请求体大小没有限制，可以发送任意大小的数据，所以尽量用post发送请求<br>第二部分  请求资源的路径，多个名值对用&amp;连接<br>第三部分  http协议版本</li><li>请求头<br>请求头也是名值对结构，用来告诉服务器我们浏览器的信息（浏览器可以接受的文件类型、浏览器允许的压缩的编码、浏览器的信息）</li><li>空行<br>用来分隔请求头和请求头</li><li>请求体<br>post请求直接通过请求体发送数据</li></ul><h3 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h3><p>服务器发送给客户端的报文称为请求报文</p><ul><li><p>响应首行<br>第一部分  http协议版本<br>第二部分  响应状态码<br>响应状态码的规则：</p><ul><li>1xx  请求处理中</li><li>2xx  请求成功</li><li>3xx  请求重定向</li><li>4xx  客户端错误</li><li>5xx  服务器错误<br>第三部分  对响应状态码的描述</li></ul></li><li><p>响应头<br>也是名值对结构，告诉浏览器响应的信息（响应体的类型、大小等）</p></li><li><p>空行<br>分隔响应头和响应体</p></li><li><p>响应体<br>服务器返回给客户端的内容</p></li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>express是node中的服务器软件，通过express可以快速在node中搭建一个web服务器</p><p>使用步骤：</p><ol><li>创建并初始化项目：npm init -y</li><li>安装express: npm add express</li><li>创建index.js编写代码</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入express</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token comment">// 获取服务器的实例（一起皆对象）</span><span class="token keyword">const</span> app<span class="token operator">=</span><span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// "/"相当于http://localhost:3000</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">// req：请求信息，res:响应信息</span>    <span class="token comment">// 在路由中，应该做两件事:读取用户的请求和根据请求返回响应</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"这是hello路由"</span>）<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//启动服务器(监听端口号)，启动后就可以通过3000端口来访问了</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>"服务器已启动“”）<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="nodemon使用"><a href="#nodemon使用" class="headerlink" title="nodemon使用"></a>nodemon使用</h3><p>代码修改后可以自动重启服务器</p><p>使用方式：全局安装</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">npm i nodemon -g</code></pre><p>启动：</p><ul><li>nodemon  运行index.js</li><li>nodemon xxx  运行指定的js</li></ul><h3 id="访问服务器呈现页面"><a href="#访问服务器呈现页面" class="headerlink" title="访问服务器呈现页面"></a>访问服务器呈现页面</h3><p>服务器器中的代码，对于外部来说是不可见的，所以写的html页面，浏览器无法直接访问，需要将页面所在的目录设置为静态资源的目录（public文件夹）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入express</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 设置static中间价后，浏览器访问时会自动去public目录寻找是否有匹配的静态资源</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"这是hello1路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"服务器已启动"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>在路径中以冒号命名的部分称为param,可以通过req.params获取。param一般不会传递很复杂的参数</p><h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><p>get请求通过req.query获取参数，post通过req.body获取参数</p><p>默认情况下，express不会自动解析请求头，需要通过中间价来为其增加功能</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入解析请求头的中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="错误路由"><a href="#错误路由" class="headerlink" title="错误路由"></a>错误路由</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 在所有路由后边配置错误路由</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"您访问的地址已被劫持"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h4><p>ejs是node中的一款模板引擎长得像个网页，可以嵌入变量</p><p>使用步骤：</p><ol><li>安装ejs</li><li>配置express的模板引擎为ejs</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 将ejs设置为默认的模板引擎</span>app<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"view engine"</span><span class="token punctuation">,</span><span class="token string">"ejs"</span><span class="token punctuation">)</span></code></pre><p><strong>注意</strong>模板引擎需要被express渲染后才能使用,res.render()用来渲染一个模板引擎，并将其返回给浏览器</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/students"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"students"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是express中创建的一个对象,实际上是一个中间件，可以在该中间件上绑定各种路由以及其他的中间件（便于管理）</p><p>新建routes文件夹，在该文件夹下存放各种路由数据的文件，再在服务器的主文件中引入使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> express<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token keyword">const</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"./list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hell0,我是list"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports<span class="token operator">=</span>router</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> userRouter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./routes/user"</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>userRouter<span class="token punctuation">)</span></code></pre><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</p><p>cookie是HTTP协议中用来解决无状态问题的技术，本质就是一个头，服务器以响应头的形式将cookie发送给客户端，客户端收到后会将其存储，并在下次向服务器发送请求时将其传回，这样服务器就可以根据cookie来识别出客户端</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// cookie解析</span><span class="token keyword">const</span> cookieParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"cookie-parser"</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cookieParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> username<span class="token punctuation">,</span> password <span class="token punctuation">&#125;</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>body    <span class="token keyword">if</span><span class="token punctuation">(</span>username <span class="token operator">===</span> <span class="token string">"admin"</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">===</span> <span class="token string">"123123"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 将用户名放入cookie</span>        res<span class="token punctuation">.</span><span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/students/list"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"stuents"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">stus</span><span class="token operator">:</span><span class="token constant">STU</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>cookie的不足：<br>cookie是由服务器创建，浏览器保存，每次浏览器访问服务器时都需要将cookie发回，这就导致我们不能在cookie存放较多的数据，并且cookie是直接存储在客户端，容易被篡改盗用，不能存储敏感数据</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>为了解决cookie的不足，希望可以将每个用户的数据都有一个对应的id，只需要通过cookie将id发送给浏览器，浏览器每次访问只需将id发回，即可读取到服务器中的数据。</p><p>session是服务器中的一个对象，这个对象用来存储用户的数据，每一个session对象都有一个唯一的id，会通过cookie的形式发送给客户端，客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入session</span><span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express-session"</span><span class="token punctuation">)</span><span class="token comment">// 设置session中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">session</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">secret</span><span class="token operator">:</span><span class="token string">"dazhaxie"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> username<span class="token punctuation">,</span> password <span class="token punctuation">&#125;</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>body    <span class="token keyword">if</span><span class="token punctuation">(</span>username <span class="token operator">===</span> <span class="token string">"admin"</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">===</span> <span class="token string">"123123"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 登录成功后，将用户名放入session，这里仅仅是添加到了内存中的session，而没有写入文件中</span>        req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>loginUser <span class="token operator">=</span> username        <span class="token comment">// 为了使得session可以立刻存储</span>        req<span class="token punctuation">.</span>session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/students/list"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//session的默认有效期是一次会话</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>loginUser<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"stuents"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">stus</span><span class="token operator">:</span><span class="token constant">STU</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>que</title>
      <link href="/2023/03/10/que/"/>
      <url>/2023/03/10/que/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>此项目为在线电商Web App (SPA)，包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块，使用Vue全家桶+ES6++Webpack+Axios等前端热门技术，采用模块化、组件化、工程化的模式开发</p><p>首先为每个单页面编写了html\css的静态页面，使用vue-cli脚手架搭建项目，根据模块将静态页面拆分成静态组件，为每个组件配置路由，建一个router文件夹,专门用来配置路由，在router的总文件中可以设置全局路由守卫，在某个具体的路由配置中可以设置路由独享守卫。组件分为路由组件和非路由组件，放在两个不同的文件夹中，其中非路由组件分为全局组件（三级联动、分页器、轮播图）和非全局组件（header、footer），全局组件在入口文件main.js中引入，可在任意组件中使用。</p><p>用axios发送ajax请求，首先对axios进行二次封装，配置基础路径以及请求超时的时间，另外配置请求拦截器和响应拦截器，同时配置请求进度条。引入vuex插件，在actions中发送请求，将获得的数据存放在state中，组件需要的时候，派发actions捞取数据进行展示，以此实现前后端交互、数据动态展示。</p><p>使用导航守卫实现以下功能：</p><ul><li>只有登陆了, 才能查看交易/支付/个人中心界面</li><li>只有没有登陆, 才能查看登陆界面</li><li>只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面</li><li>只能从购物车界面, 才能跳转到交易界面</li><li>只能从交易界面, 才能跳转到支付界面</li><li>只有从支付界面, 才能跳转到支付成功的界面</li></ul><h3 id="项目中的难点、亮点、挑战"><a href="#项目中的难点、亮点、挑战" class="headerlink" title="项目中的难点、亮点、挑战"></a>项目中的难点、亮点、挑战</h3><p>1 mock模拟数据，实现前后端分离开发<br>2 组件间通信：父组件给子组件传递数据用props、子组件给父组件用自定义事件、兄弟组件间通信用全局事件总线（$bus）<br>3 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误，是因为编程式导航中引入了promise语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，解决办法，重写push和replace，指定两个空回调<br>4 展示某用户的订单信息：携带token。携带手机号、验证码、密码等数据进行注册请求，注册成功后，服务器会下发token。当携带手机号和密码进行登录请求时，可获取相应的token，在请求拦截器中将token作为一个字段添加到响应头，此后发送的请求都会带着token获取数据。<br>5 表单验证：</p><h4 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h4><ol><li>三级联动中，鼠标移入添加背景颜色时，为了防止事件触发过于频繁，此处用了节流。</li></ol><h4 id="home组件"><a href="#home组件" class="headerlink" title="home组件"></a>home组件</h4><h5 id="三级联动"><a href="#三级联动" class="headerlink" title="三级联动"></a>三级联动</h5><p><strong>静态文件+过渡：</strong></p><p>CSS：确定过渡元素的起始状态、结束状态、过渡事件、过渡规律</p><p>HTML：用 <code>&lt;transation&gt;&lt;transation/&gt;</code> 包裹过渡元素</p><p>JS：绑定鼠标事件</p><p>对于一级列表，在home组件中，初始化v-show=true，在其他组建中初始化v-show=false</p><p>对于二、三级列表，在一级列表的每一项上绑定鼠标移入事件，在绑定函数中传入index，用该条件决定二、三级列表的display样式。</p><p><strong>路由跳转：</strong></p><p>在三级列表中点击某类商品需要跳转路由，如何跳转到对应路由：</p><ol><li>利用事件委派，在一二三级列表的父元素上绑定点击事件</li><li>在每个a标签上添加自定义属性（商品名：判断点击的是否是a标签；商品id：判断点击的是那个a标签），经过判断后再决定路由跳转</li></ol><p><strong>重难点说明</strong></p><ol><li>组件与vuex交互</li><li>事件控制二三级分类列表的显示与隐藏</li><li>优化高频事件触发处理: 利用lodash进行函数节流处理</li><li>优化减小打包文件: 对lodash库实现按需引入</li><li>解决快速移出后可能显示第一个分类的子分类列表的bug</li><li>优化减少组件对象数量: 使用编程式导航代替声明式导航</li><li>优化事件处理效率: 利用事件委托</li><li>利用标签自定义属性携带动态数据</li><li>控制一级列表的显示与隐藏</li><li>一级列表显示隐藏的过渡效果</li><li>优化请求执行的位置, 减少请求次数</li><li>合并分类query参数与搜索的关键字params参数</li></ol><h4 id="serach组件"><a href="#serach组件" class="headerlink" title="serach组件"></a>serach组件</h4><p>由面包屑区域、商品筛选框、商品列表、分页器组成</p><p>把商品的品牌和属性单独写一个商品筛选的组件，父组件由面包屑、商品筛选、商品详情。当点击品牌值或者属性值时，需要把值传递给父组件，以在面包屑中（此处需要去重）显示。此处涉及子组件给父组件传递信息，用到自定义事件，在父组件中用子组件时绑定自定义事件，子组件中发生点击事件时触发函数。</p><p>同时点击商品值或者属性值后要更新商品筛选组件和商品列表，此处需要在父组件中发送请求，因为发送请求需要带的参数在父组件中。请求获得的数据存放在vuex中，而商品筛选组件所需的数据是从vuex中取，所以会更新商品筛选框。注意：在header的搜索框中输入值点击搜索后，值会作为params参数参与路由跳转到search中，所以在search组件挂载前要将该参数合并到searchParams（发送请求需要带的参数）中</p><p>商品详情处会有综合排序或者价格排序，点击综合时，就按综合属性进行排序，如果原来是升序，就按降序排列，否则反之；点击价格时同理。</p><p><strong>分页器</strong></p><p>点击某一页时，把当前页数放入searchParams（发送请求需要带的参数）中，发送请求获取对应数据</p><p>父向子传递参数：当前页数，每页展示多少条数据、总共有多少条数据、中间的连续页数</p><p>如果当前页为1，则上一页按钮disable</p><p>如果连续页的第一页大于1，则显示第一页</p><p>如果连续页的第一页大于2，则显示省略号</p><p>如果连续页大于总页数，则首页为1，尾页为总页数；否则，连续页的首项为当前页-parseInt(连续页数/2),尾项为当前页+parseInt(连续页数/2)，如果首页小于1，取1，尾页为连续页数；如果尾页大于总页数，取最后一页，首页为总页数-连续页数+1</p><p>如果连续页的尾页小于总页数，则有总页数</p><p>如果连续页的尾页小于总页数-1，则有省略号</p><h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><p>手机号：</p><p>验证码：如果有了手机号，带上手机号发送请求，获取验证码</p><p>登录密码：</p><p>确认密码：</p><p>同意协议：</p><p><strong>表单验证:到b站看个视频</strong></p><p><strong>注册</strong></p><p>表单验证成功后，带着手机号、验证码、密码向服务器发送请求存储用户数据，并跳转路由到登录页</p><h4 id="登录组件"><a href="#登录组件" class="headerlink" title="登录组件"></a>登录组件</h4><p>携带手机号和密码发送登录请求，服务器会下发一个token，将其本地存储，在请求拦截器中判断是否有token,有则加入请求头中。</p><h4 id="详情组件"><a href="#详情组件" class="headerlink" title="详情组件"></a>详情组件</h4><p><strong>添加购物车</strong></p><p>携带商品id和数量向后端发送请求（后台会存储数据），同时将该商品的信息会话存储，跳转到成功添加购物车页面，展示会话存储的信息。从成功添加购物车页面，可以去购物车，进行结算</p><p><strong>放大镜</strong></p><p>放大镜下方有个图片列表，里面为该商品的一些图片，图片列表和放大镜是兄弟组件。在放大镜组件中首先获取兄弟组件中传过来的图片索引，此处用到了全局事件总线。</p><p>布局：图片框设置相对定位，遮罩层和放大的区域的display为none，鼠标移入的时候display为block。遮罩层的宽高都为图片框的一半，放大框和图片框大小相同，但是放大框中图片宽高为图片框中图片的2倍，鼠标移入图片框的时候，获取鼠标的位置，定位遮罩层的位置，同时设置放大框中图片的left和top属性为-2倍</p><h4 id="订单组件"><a href="#订单组件" class="headerlink" title="订单组件"></a>订单组件</h4><p>收件人信息、商品清单、买家留言等部分</p><p>点击去支付，跳转到支付页</p><h4 id="支付组件"><a href="#支付组件" class="headerlink" title="支付组件"></a>支付组件</h4><p>点击立即支付后，弹出二维码支付框（elementui），设置定时器，每过一秒钟获取以下支付信息，如果支付成功，则关闭支付框，跳转到支付成功组件</p><h4 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h4><p>我的订单</p><h4 id="支付成功组件"><a href="#支付成功组件" class="headerlink" title="支付成功组件"></a>支付成功组件</h4><p>该部分有组件内守卫，如果是从pay组件过来的，放行</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><ol><li>全局守卫：如果没有登录（没有token），则不能去trade\pay\center等页面，到直接去登录界面，同时将要去的页面路径作为重定向的参数传递，待登录后，判断路径中是否有重定向参数，再跳转至重定向页面<br>登录后，如果token过期了，则需要到登录界面重新登录</li><li>支付成功组件用到了组件内守卫，如果是从pay组件过来的，放行</li><li>路由独享守卫：只能从购物车界面跳转到交易界面，只能从交易界面跳转到支付界面</li></ol><h4 id="重写Push、replace"><a href="#重写Push、replace" class="headerlink" title="重写Push、replace"></a>重写Push、replace</h4><p>编程式路由跳转到当前路径且参数没有变化时会抛NavigationDuplicated 错误</p><p>原因：vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise</p><p>解决办法：如果没穿成功和失败的回调函数，传两个空函数</p><h4 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h4><p>二次封装即配置基础路径，设置请求超时时间</p><p>另外还可以配置请求拦截器和响应拦截器</p><p>请求拦截器：把token放入请求头、进度条开始</p><p>响应拦截器：进度条结束</p><h4 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h4><p>本项目自创了首页轮播图以及两个floor层的数据，数据为json格式。然后写一个mockserve服务器，引入数据，作为接口的响应数据。同二次封装axios一样封装一个mockajax，将基础路径配置为/mock。</p><p>注：以/api开头的接口在vue.config.js中配置proxy代理</p><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h4><p>项目中在轮播图处使用了，只有节点更新后才能使用第三方轮播图组件</p><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><ol><li>当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能 <strong>把不同路由对应的组件分割成不同的代码块</strong> ，然后当路由被访问的时候才加载对应组件，这样就更加高效了</li><li>本质就是<strong>Vue 的异步组件</strong>在路由组件上的应用</li><li>需要使用动态import语法, 也就是<strong>import()函数</strong></li></ol><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>编程式路由导航：</p><ul><li>push</li><li>replace</li></ul><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误"><a href="#编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误" class="headerlink" title="编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误"></a>编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误</h3><p>解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误<br>解决2: 修正Vue原型上的push和replace方法 (优秀)</p><h3 id="如何指定params参数可传可不传"><a href="#如何指定params参数可传可不传" class="headerlink" title="如何指定params参数可传可不传?"></a>如何指定params参数可传可不传?</h3><p>path: ‘/search/:keyword?’</p><h3 id="指定params参数时可不可以用path和params配置的组合"><a href="#指定params参数时可不可以用path和params配置的组合" class="headerlink" title=":指定params参数时可不可以用path和params配置的组合?"></a>:指定params参数时可不可以用path和params配置的组合?</h3><p>不可以,用path和params配置的组合, 只能用name和params配置的组合<br>query配置可以与path或name进行组合使用</p><h3 id="如果指定name与params配置-但params中数据是一个””-无法跳转"><a href="#如果指定name与params配置-但params中数据是一个””-无法跳转" class="headerlink" title="如果指定name与params配置, 但params中数据是一个””, 无法跳转"></a>如果指定name与params配置, 但params中数据是一个””, 无法跳转</h3><p>解决1: 不指定params<br>解决2: 指定params参数值为undefined</p><h3 id="路由组件能不能传递props数据"><a href="#路由组件能不能传递props数据" class="headerlink" title="路由组件能不能传递props数据?"></a>路由组件能不能传递props数据?</h3><p>可以: 可以将query或且params参数映射/转换成props传递给路由组件对象<br>实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p><h2 id="axios二次封装-1"><a href="#axios二次封装-1" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><ul><li>基础路径</li><li>请求超时时间</li><li>请求拦截器（请求进度条，携带token）</li><li>响应拦截器</li></ul><h2 id="路由守卫-1"><a href="#路由守卫-1" class="headerlink" title="路由守卫"></a>路由守卫</h2><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>在准备跳转到某个路由组件之前 (在开发中用的比较多)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//全局前置守卫（路由跳转之前进行判断）</span><span class="token comment">//登录后不能再进登录界面</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span>    <span class="token keyword">let</span> token <span class="token operator">=</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>token<span class="token punctuation">;</span>    <span class="token keyword">let</span> name <span class="token operator">=</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>userInfo<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果登录了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/login'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果还要去登录界面</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'./home'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 如果有用户信息</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">await</span> store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'getUserInfo'</span><span class="token punctuation">)</span>                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//token失效了，获取不到用户信息，重新登录</span>                    <span class="token keyword">await</span> store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'userLogout'</span><span class="token punctuation">)</span>                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 未登录，不能去交易相关的页面，若要去先登录</span>        <span class="token keyword">let</span> toPath<span class="token operator">=</span>to<span class="token punctuation">.</span>path        <span class="token keyword">if</span><span class="token punctuation">(</span>toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'./trade'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'./pay'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'/center'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'/login?redirect='</span><span class="token operator">+</span>toPath<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>说明: to:<br>目标route;<br>from: 起始route;</p><p>next: 放行函数</p><ul><li>next(): 执行下一个守卫回调, 如果没有跳转到目标路由</li><li>next(false)/不执行: 跳转流程在当前处中断, 不会跳转到目标路由组件</li><li>next(path): 跳转到指定的另一个路由</li></ul><ol start="2"><li>全局后置守卫: 在跳转到某个路由组件之后</li></ol><p>router.afterEach((to, from) =&gt; {})</p><ol start="3"><li>路由独享守卫</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 路由独享守卫</span>        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 去交易页面，必须是从购物车来的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>from<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">"/shopcart"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span></code></pre><p>3 组件守卫</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 组件内守卫</span>    <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 在渲染该组件的路由被confirm前调用</span>      <span class="token comment">// 不能获取组件实例this，因为当守卫执行前，组件实例还没被创建</span>      <span class="token comment">// 但可以通过next(component => &#123;&#125;), 在回调函数中访问组件对象</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>from<span class="token punctuation">.</span>path<span class="token operator">==</span><span class="token string">'/pay'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 当前组件对象将要更新前调用, 可以访问this</span><span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 在当前组件离开前调用, 可以访问this</span><span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 商城项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/02/25/git/"/>
      <url>/2023/02/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p><ul><li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li><li>在不影响现行开发工作的情况下对代码进行维护</li><li>开发时，某段代码被多人修改时，处理代码的冲突问题</li></ul><p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。<img src="/2023/02/25/git/1.png" alt="1682601512635"></p><p>远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p><p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p><h2 id="下载和配置"><a href="#下载和配置" class="headerlink" title="下载和配置"></a>下载和配置</h2><p><a href="https://git-scm.com/">Git</a>无脑下载</p><p>下载Git后，首先要配置个人用户名称和电子邮件地址。这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">git config --global [user.name]git config --global [user.email]</code></pre><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>被git管理的文件有三种状态：</p><ul><li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li><li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li><li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li></ul><p>可以通过git status查看文件的状态</p><p>新添加的文件处于未跟踪状态（未被git管理）:</p><ul><li>未跟踪-&gt;暂存：git add <code>&lt;filename&gt;</code></li><li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li><li>未修改-&gt;修改：修改代码后，转为修改状态</li><li>修改-&gt;暂存：git add <code>&lt;filename&gt;</code></li></ul><p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p><h2 id="将文件提交至远程仓库："><a href="#将文件提交至远程仓库：" class="headerlink" title="将文件提交至远程仓库："></a>将文件提交至远程仓库：</h2><ol><li>在总文件夹中右键选择 <code>git bash here</code>，初始化git。</li></ol><pre class="language-cmd" data-language="cmd"><code class="language-cmd">$ git init</code></pre><ol start="2"><li>连接远程仓库</li></ol><pre class="language-cmd" data-language="cmd"><code class="language-cmd">$ git remote add origin &quot;仓库地址&quot;</code></pre><ol start="3"><li>上传文件</li></ol><pre class="language-none"><code class="language-none">$ git add &quot;文件名&quot;&#x2F;git add *  把工作区某个文件提交至暂存区&#x2F;把工作区所有文件提交至暂存区$ git commit -m &quot;版本名&quot;  把暂存区文件提交至本地仓库$ git push origin master  把本地仓库的文件推送到远程仓库的某一分支上</code></pre><h2 id="从远程仓库下载文件：fork、clone"><a href="#从远程仓库下载文件：fork、clone" class="headerlink" title="从远程仓库下载文件：fork、clone"></a>从远程仓库下载文件：fork、clone</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork包含了原来的仓库所有内容，如分支、Tag、提交</p><p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p><p>执行 <code>clone</code>命令后，会在当前目录下创建一个名为 <code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p><p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p><h3 id="使用fork和clone"><a href="#使用fork和clone" class="headerlink" title="使用fork和clone"></a>使用fork和clone</h3><p>当你在 <code>github</code>发现感兴趣开源项目的时候，可以通过点击 <code>github</code>仓库中右上角 <code>fork</code>标识的按钮，如下图：</p><p><img src="/2023/02/25/git/2.png" alt="1682602188024"></p><p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的 <code>github</code>仓库中，而你本地仓库是不会存在任何更改</p><p>然后你就可以通过 <code>git clone</code>对你这个复制的远程仓库进行克隆,在 <code>github</code>中，开源项目右侧存在 <code>code</code>按钮，点击后则会显示开源项目 <code>url</code>信息，如下图所示：通过 <code>git clone xxx</code>则能完成远程项目的下载</p><p><img src="/2023/02/25/git/5.png" alt="1682602404998"></p><p>后续更改任何东西都可以在本地完成，如 <code>git add</code>、<code>git commit</code>一系列的操作，然后通过 <code>push</code>命令推到自己的远程仓库</p><p>如果希望对方接受你的修改，可以通过发送 <code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p><p><img src="/2023/02/25/git/3.png" alt="1682602282691"></p><p>整体流程如下图：</p><p><img src="/2023/02/25/git/4.png" alt="1682602320048"></p><p>fork和clone的区别</p><h3 id="其三者区别如下："><a href="#其三者区别如下：" class="headerlink" title="其三者区别如下："></a>其三者区别如下：</h3><ul><li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li><li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p><code>git</code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p><p><img src="/2023/02/25/git/6.png" alt="1682603560111"></p><p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的 <code>git</code>命令</p><h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>一个 <code>git</code>项目的初始有两个途径，分别是：</p><ul><li>git init [project-name]：创建或在当前目录初始化一个git代码库</li><li>git clone url：下载一个项目和它的整个代码历史</li></ul><h4 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h4><p>在日常工作中，代码常用的基本操作如下：</p><ul><li>git init 初始化仓库，默认为 master 分支</li><li>git add . 提交全部文件修改到缓存区</li><li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li><li>git diff 查看当前代码 add后，会 add 哪些内容</li><li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li><li>git status 查看当前分支状态</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li><li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li><li>git commit -v 提交时显示所有diff信息</li><li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li></ul><p>关于提交信息的格式，可以遵循以下的规则：</p><ul><li>feat: 新特性，添加功能</li><li>fix: 修改 bug</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理</li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p><ul><li>git branch 查看本地所有分支</li><li>git branch -r 查看远程所有分支</li><li>git branch -a 查看本地和远程所有分支</li><li>git merge &lt;分支名&gt; 合并分支</li><li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li><li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li><li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li><li>git branch -D &lt;分支名&gt; 删除本地某个分支</li><li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li><li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li><li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li><li>git checkout &lt;分支名&gt; 切换到本地某个分支</li><li>git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</li><li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li></ul><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><p>远程操作常见的命令：</p><ul><li>git fetch [remote] 下载远程仓库的所有变动</li><li>git remote -v 显示所有远程仓库</li><li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li><li>git fetch 获取线上最新版信息记录，不合并</li><li>git push [remote] [branch] 上传本地指定分支到远程仓库</li><li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li><li>git push [remote] –all 推送所有分支到远程仓库</li></ul><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul><li>git checkout [file] 恢复暂存区的指定文件到工作区</li><li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li><li>git checkout . 恢复暂存区的所有文件到工作区</li><li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li><li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li><li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li><li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li></ul><blockquote><p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p><p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p></blockquote><h4 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h4><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p><ul><li>git stash 暂时将未提交的变化移除</li><li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li><li>git stash list 查看所有储藏中的工作</li><li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li><li>git stash clear 清空所有储藏中的工作</li><li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li></ul><h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p><p>而 <code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p><p>在我们本地的 <code>git</code>文件中对应也存储了 <code>git</code>本地仓库分支的 <code>commit ID</code>和 跟踪的远程分支的 <code>commit ID</code>，对应文件如下：</p><ul><li>.git/refs/head/[本地分支]</li><li>.git/refs/remotes/[正在跟踪的分支]</li></ul><p>使用 <code>git fetch</code>更新代码，本地的库中 <code>master</code>的 <code>commitID</code>不变</p><p>但是与 <code>git</code>上面关联的那个 <code>orign/master</code>的 <code>commit ID</code>发生改变</p><p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过 <code>merge</code>去合并这两个不同的代码版本</p><p><img src="/2023/02/25/git/7.png" alt="1682604231981"></p><p>也就是 <code>fetch</code>的时候本地的 <code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地 <code>merge</code>合并这两个版本号的代码</p><p>相比之下，使用 <code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p><p><img src="/2023/02/25/git/8.png" alt="1682604272380"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到 <code>git pull</code>或者 <code>git fetch</code>命令</p><p><strong>fetch</strong></p><p>用法如下：</p><pre class="language-none"><code class="language-none">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>例如从远程的 <code>origin</code>仓库的 <code>master</code>分支下载代码到本地并新建一个 <code>temp</code>分支</p><pre class="language-none"><code class="language-none">git fetch origin master:temp</code></pre><p>如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来到本地当前分支</p><p>这里 <code>git fetch</code>不会进行合并，执行后需要手动执行 <code>git merge</code>合并，如下：</p><p><strong>pull</strong></p><p>两者的用法十分相似，<code>pull</code>用法如下：</p><pre class="language-none"><code class="language-none">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>例如将远程主机 <code>origin</code>的 <code>master</code>分支拉取过来，与本地的 <code>branchtest</code>分支合并，命令如下：</p><pre class="language-none"><code class="language-none">git pull origin master:branchtest</code></pre><pre class="language-text" data-language="text"><code class="language-text">git pull origin master:branchtest</code></pre><p>同样如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来与本地当前分支合并</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>相同点：</p><ul><li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li></ul><p>不同点：</p><ul><li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge</li><li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li></ul><h2 id="git-rebase-和-git-merge"><a href="#git-rebase-和-git-merge" class="headerlink" title="git rebase 和 git merge"></a>git rebase 和 git merge</h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p><ul><li>git merge</li><li>git rebase</li></ul><p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p><p><strong>git merge</strong></p><p>将当前分支合并到指定分支，命令用法如下：</p><pre class="language-none"><code class="language-none">git merge xxx</code></pre><p>通过 <code>git merge</code>将当前分支与 <code>xxx</code>分支合并，产生的新的 <code>commit</code>对象有两个父节点</p><p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p><p>举个例子，<code>bugfix</code>分支是从 <code>master</code>分支分叉出来的，如下所示：</p><p><img src="/2023/02/25/git/9.png" alt="1682604971963"></p><p>合并 <code>bugfix</code>分支到 <code>master</code>分支时，如果 <code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含 <code>master</code>分支所有的历史记录</p><p>所以通过把 <code>master</code>分支的位置移动到 <code>bugfix</code>的最新分支上，就完成合并</p><p>如果 <code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="/2023/02/25/git/10.png" alt="1682605021939"></p><p>这时候使用 <code>git merge</code>的时候，会生成一个新的提交，并且 <code>master</code>分支的 <code>HEAD</code>会移动到新的分支上，如下：</p><p><img src="/2023/02/25/git/11.png" alt="1682605062943"></p><p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p><p><strong>git rebase（变基）</strong></p><p>将当前分支移植到指定分支或指定 <code>commit</code>之上，用法如下：</p><pre class="language-none"><code class="language-none">git rebase -i &lt;commit&gt;</code></pre><p>同样，<code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="/2023/02/25/git/12.png" alt="1682605154719"></p><p>通过 <code>git rebase</code>，会变成如下情况：</p><p><img src="/2023/02/25/git/13.png" alt="1682605189602"></p><p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p><p><img src="/2023/02/25/git/14.png" alt="1682605269640"></p><p><code>rebase</code>之后，<code>master</code>的 <code>HEAD</code>位置不变。因此，要合并 <code>master</code>分支和 <code>bugfix</code>分支</p><p><img src="/2023/02/25/git/15.png" alt="1682605347300"></p><p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的 <code>B</code></p><h2 id="然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交-X和-Y也没有被销毁，只是简单地不能再被访问或者使用）"><a href="#然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交-X和-Y也没有被销毁，只是简单地不能再被访问或者使用）" class="headerlink" title="然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交 X和 Y也没有被销毁，只是简单地不能再被访问或者使用）"></a>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交 <code>X</code>和 <code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</h2><p>然后将当前分支指向目标最新位置 <code>D</code>, 然后将之前另存为临时文件的修改依序应用</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>从上面可以看到，<code>merge</code>和 <code>rebasea</code>都是合并历史记录，但是各自特性不同：</p><p><strong>merge</strong></p><p>通过 <code>merge</code>合并分支会新增一个 <code>merge commit</code>，然后将两个分支的历史联系起来</p><p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p><p><strong>rebase</strong></p><p><code>rebase</code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p><p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 <code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p><p>解决冲突就是把 <code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p><h2 id="git-reset-和-git-revert"><a href="#git-reset-和-git-revert" class="headerlink" title="git reset 和 git revert"></a>git reset 和 git revert</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p><p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p><p><img src="/2023/02/25/git/16.png" alt="1682605761698"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p><p><img src="/2023/02/25/git/17.png" alt="1682605793002"></p><h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p><p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p><p>两者主要区别如下：</p><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li><li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li></ul><blockquote><p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p><p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p></blockquote><ul><li>如果回退分支的代码以后还需要的情况则使用 <code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用 <code>git reset</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
