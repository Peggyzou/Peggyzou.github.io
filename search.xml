<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo相关问题</title>
      <link href="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="将文章部署到远程仓库不成功时，可能的问题："><a href="#将文章部署到远程仓库不成功时，可能的问题：" class="headerlink" title="将文章部署到远程仓库不成功时，可能的问题："></a>将文章部署到远程仓库不成功时，可能的问题：</h2><p>如果出现下图中的问题，说明未连接到远程仓库</p><p><img src="/image/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1679554899216.png" alt="1679554899216"></p><p>右键选择Git Bash Here，输入以下命令进行连接</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:yourName/repositoryname.git</code></pre><p>yourName是用户名，repositoryname是仓库名字，地址也可以直接在github中复制</p><p><img src="/image/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1679554369659.png" alt="1679554369659"></p><p>连接到远程仓库后，重新生成一次ssh key，在Git Hub Here中输入ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#117;&#x72;&#101;&#x6d;&#97;&#105;&#x6c;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#x79;&#111;&#117;&#x72;&#101;&#x6d;&#97;&#105;&#x6c;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>“</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail@example.com"</span></code></pre><p>xxxxxx<a href="mailto:youremail@example.com">@example.com</a>改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key），此时会提醒密钥所在位置，如下图所示</p><p><img src="/image/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1679555216959.png" alt="1679555216959"></p><p>找到密钥后，复制粘贴到github中：个人头像-setting-SSH and GPG keys</p><p><img src="/image/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1679556436250.png" alt="1679556436250"></p><p>即可成功部署文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/15/1/"/>
      <url>/2023/03/15/1/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=, initial-scale=1.0">    <title>Document</title></head><body>    <script>        var str = '{"name":"孙悟空","age":18,"gender":"男"}';        var obj = eval("(" + str + ")");        console.log(obj)    </script></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原型/原型链</title>
      <link href="/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a><strong>原型的作用</strong></h2><p>原型被定义为给其它对象提供共享属性的对象，函数的实例可以共享原型上的属性和方法</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>它的作用就是当你在访问一个对象上属性的时候，如果该对象内部不存在这个属性，那么就会去它 <code>__proto__</code>属性所指向的对象（原型对象）上查找。如果原型对象依旧不存在这个属性，那么就会去其原型的 <code>__proto__</code>属性所指向的原型对象上去查找。以此类推，直到找到 <code>null</code>，而这个查找的线路，也就构成了我们常说的<strong>原型链</strong></p><p><strong>原型链和作用域的区别：</strong> 原型链是查找对象上的属性，作用域链是查找当前上下文中的变量</p><h2 id="proto-、prototype、constructor属性介绍"><a href="#proto-、prototype、constructor属性介绍" class="headerlink" title="proto 、prototype、constructor属性介绍"></a><strong>proto</strong> 、prototype、constructor属性介绍</h2><ol><li>js中对象分为两种，普通对象和函数对象</li><li><code>__proto__</code>和 <code>constructor</code>是对象独有的。<code>prototype</code>属性是函数独有的，它的作用是包含可以给特定类型的所有实例提供共享的属性和方法；但是在 JS 中，函数也是对象，所以函数也拥有 <code>__proto__</code>和 <code>constructor</code>属性</li><li><code>constructor</code>属性是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数 <code>构造函数.prototype.constructor === 该构造函数本身</code></li><li>一个对象的 <code>__proto__</code>指向其构造函数的 <code>prototype</code>,<code>函数创建的对象.__proto__ === 该函数.prototype</code></li><li>特殊的 <code>Object</code>、<code>Function</code></li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 的基本用法，它可以判断一个对象的原型链上是否包含该构造函数的原型，经常用来判断对象是否为该构造函数的实例</p><p><strong>特殊示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre><p><strong>手写instanceof方法</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> proto <span class="token operator">=</span> obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">instanceOf</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> Dog<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">instanceOf</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true true</span></code></pre><h2 id="instanceof与typeof的区别"><a href="#instanceof与typeof的区别" class="headerlink" title="instanceof与typeof的区别"></a><strong>instanceof与typeof的区别</strong></h2><p>1）<code>typeof</code>一般被用于来判断一个变量的类型</p><p>typeof可以用来判断 <code>number、undefined、symbol、string、function、boolean、object</code> 这七种数据类型，特殊情况：<code>typeof null === &#39;object&#39;</code></p><p>2）<code>instanceof</code>判断一个对象的原型链上是否包含该构造函数的原型</p><h2 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h2><p><strong>new一个对象，到底发生什么？</strong></p><p>1）创建一个对象，该对象的原型指向构造函数的原型</p><p>2）调用该构造函数，构造函数的this指向新生成的对象</p><p>3）判断构造函数是否有返回值，如果有返回值且返回值是一个对象或一个方法，则返回该值；否则返回新生成的对象</p><p><strong>构造函数有返回值的案例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"ming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;test:1&#125; </span></code></pre><p><strong>手写new</strong></p><pre class="language-none"><code class="language-none">function selfNew(fn, ...args) &#123;  &#x2F;&#x2F; 创建一个instance对象，该对象的原型是fn.prototype  let instance &#x3D; Object.create(fn.prototype);  &#x2F;&#x2F; 调用构造函数，使用apply，将this指向新生成的对象  let res &#x3D; fn.apply(instance, args);  &#x2F;&#x2F; 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象  return typeof res &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof res &#x3D;&#x3D;&#x3D; &quot;function&quot; ? res : instance;&#125;</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>多种继承方式</strong></p><p>1）原型链继承，缺点：引用类型的属性被所有实例共享<br>2）借用构造函数（经典继承）<br>3）原型式继承<br>4）寄生式继承<br>5）组合继承<br>6）寄生组合式继承</p><p><strong>寄生组合式继承的优势</strong></p><p>优势：借用父类的构造函数，在不需要生成父类实例的情况下，继承了父类原型上的属性和方法</p><p><strong>手写寄生组合式继承</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 精简版</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用父类的构造函数</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 利用Object.create生成一个对象，新生成对象的原型是父类的原型，并将该对象作为子类构造函数的原型，继承了父类原型上的属性和方法</span>    <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 原型对象的constructor指向子类的构造函数</span>    <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通用版</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 调用父类的构造函数</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 目的是为了继承父类原型上的属性和方法，在不需要实例化父类构造函数的情况下，避免生成父类的实例，如new Parent()</span>  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token comment">// 创建一个空对象，该对象原型指向父类的原型对象</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 等同于 Child.prototype = Object.create(Parent.prototype)</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tom</span></code></pre><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p><strong>Class 类可以看作是构造函数的语法糖</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Point <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p><strong>Class 类中定义的方法，都是定义在该构造函数的原型上</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 等同于</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p><strong>使用 <code>static</code>关键字，作为静态方法</strong>（静态方法，只能通过类调用，实例不能调用）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Foo<span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'hello'</span></code></pre><p><strong>实例属性的简写写法</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  bar <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  baz <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 等同于</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong><code>extends</code> 关键字，底层是利用的寄生组合式继承</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// li</span></code></pre><p>ES6的 Class 内部是基于寄生组合式继承，它是目前最理想的继承方式<br>ES6的 Class 允许子类继承父类的静态方法和静态属性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/03/15/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/15/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包：就是函数引用了外部作用域的变量</strong></p><p><strong>闭包常见的两种情况：</strong></p><p>一是函数作为返回值； 另一个是函数作为参数传递</p><p><strong>闭包的作用：</strong></p><p>可以让局部变量的值始终保持在内存中；对内部变量进行保护，使外部访问不到</p><p>最常见的案例：<code>函数节流和防抖</code></p><p><strong>闭包的垃圾回收：</strong></p><p>副作用：不合理的使用闭包，会造成内存泄露(就是该内存空间使用完毕之后未被回收)</p><p>闭包中引用的变量直到闭包被销毁时才会被垃圾回收</p><p><strong>闭包的示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 原始题目</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1s后打印出5个5</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ⬅️利用闭包，将上述题目改成1s后，打印0,1,2,3,4</span><span class="token comment">// 方法一：</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 方法二：</span><span class="token comment">// 利用setTimeout的第三个参数，第三个参数将作为setTimeout第一个参数的参数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三个参数i,将作为fn的参数</span><span class="token punctuation">&#125;</span><span class="token comment">// ⬅️将上述题目改成每间隔1s后，依次打印0,1,2,3,4</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2023/03/15/this/"/>
      <url>/2023/03/15/this/</url>
      
        <content type="html"><![CDATA[<h1 id="this的5种绑定方式"><a href="#this的5种绑定方式" class="headerlink" title="this的5种绑定方式"></a><strong>this的5种绑定方式</strong></h1><p>1）默认绑定(非严格模式下this指向全局对象，严格模式下函数内的this指向 <code>undefined</code>)</p><p>2）隐式绑定(当函数引用有上下文对象时, 如 <code>obj.foo()</code>的调用方式, foo内的this指向obj)</p><p>3）显示绑定(通过call或者apply方法直接指定this的绑定对象, 如 <code>foo.call(obj)</code>)</p><p>4）new构造函数绑定，this指向新生成的对象</p><p>5）箭头函数，this指向的是定义该函数时，外层环境中的this，<strong>箭头函数的this在定义时就决定了，不能改变</strong></p><p><strong>this 题目1</strong></p><pre class="language-none"><code class="language-none">&quot;use strict&quot;;var a &#x3D; 10; &#x2F;&#x2F; var定义的a变量挂载到window对象上function foo () &#123;  console.log(&#39;this1&#39;, this)  &#x2F;&#x2F; undefined  console.log(window.a)  &#x2F;&#x2F; 10  console.log(this.a)  &#x2F;&#x2F;  报错，Uncaught TypeError: Cannot read properties of undefined (reading &#39;a&#39;)&#125;console.log(&#39;this2&#39;, this)  &#x2F;&#x2F; windowfoo();</code></pre><p>注意：开启了严格模式，只是使得函数内的this指向 <code>undefined</code>，它并不会改变全局中this的指向。因此 <code>this1</code>中打印的是 <code>undefined</code>，而 <code>this2</code>还是 <code>window</code>对象。</p><p><strong>this 题目2</strong></p><pre class="language-none"><code class="language-none">let a &#x3D; 10const b &#x3D; 20function foo () &#123;  console.log(this.a)  &#x2F;&#x2F; undefined  console.log(this.b)  &#x2F;&#x2F; undefined&#125;foo();console.log(window.a) &#x2F;&#x2F; undefined  </code></pre><p>如果把 var 改成了 let 或 const，变量是不会被绑定到window上的，所以此时会打印出三个undefined</p><p><strong>this 题目3</strong></p><pre class="language-none"><code class="language-none">var a &#x3D; 1function foo () &#123;  var a &#x3D; 2  console.log(this)  &#x2F;&#x2F; window  console.log(this.a) &#x2F;&#x2F; 1&#125;foo()</code></pre><p>foo()函数内的this指向的是window，因为是window调用的foo，打印出的 <code>this.a</code>是window下的 <code>a</code></p><p><strong>this 题目4</strong></p><pre class="language-none"><code class="language-none">var obj2 &#x3D; &#123;    a: 2,    foo1: function () &#123;      console.log(this.a) &#x2F;&#x2F; 2    &#125;,    foo2: function () &#123;      setTimeout(function () &#123;        console.log(this) &#x2F;&#x2F; window        console.log(this.a) &#x2F;&#x2F; 3      &#125;, 0)    &#125;  &#125;  var a &#x3D; 3    obj2.foo1()  obj2.foo2() </code></pre><p>对于 <code>setTimeout</code>中的函数，这里存在隐式绑定的this丢失，也就是当我们将函数作为参数传递时,会被隐式赋值，回调函数丢失this绑定，因此这时候setTimeout中函数内的this是指向 <code>window</code></p><p><strong>this 题目5</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'obj'</span><span class="token punctuation">,</span> <span class="token function-variable function">foo1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// window</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function-variable function">foo2</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// obj</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// obj</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'window'</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这道题非常经典，它证明了<strong>箭头函数内的this是由外层作用域决定的</strong></p><p><strong>题目5解析：</strong></p><p>1）对于 <code>obj.foo1()</code>函数的调用，它的外层作用域是window，对象obj当然不属于作用域了(作用域只有全局作用域、函数作用域、块级作用域)，所以会打印出 <code>window</code></p><p>2）<code>obj.foo2()()</code>，首先会执行 <code>obj.foo2()</code>，这不是个箭头函数，所以它里面的this是调用它的obj对象，因此第二个打印为 <code>obj</code>，而返回的匿名函数是一个箭头函数， <strong>它的this由外层作用域决定</strong> ，那也就是它的this会和foo2函数里的this一样，第三个打印也是 <code>obj</code></p><h1 id="call-apply-bind三者的区别"><a href="#call-apply-bind三者的区别" class="headerlink" title="call apply bind三者的区别"></a>call apply bind三者的区别</h1><ol><li>三者都可以显式绑定函数的this指向</li><li>三者第一个参数都是this要指向的对象，若该参数为undefined或null，this则默认指向全局window传参不同：apply是数组、call是参数列表，而bind可以分为多次传入，实现参数的合并</li><li>call、apply是立即执行，bind是返回绑定this之后的函数，如果这个新的函数作为构造函数被调用，那么this不再指向传入给bind的第一个参数，而是指向新生成的对象</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>var_let_const</title>
      <link href="/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h1><h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>var定义的变量，没有块的概念，可以跨块访问, 可以变量提升</li><li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明</li><li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明</li></ol><p><strong>let和const声明的变量只在块级作用域内有效，示例</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 "i is not defined"</span><span class="token punctuation">&#125;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="var与let的经典案例"><a href="#var与let的经典案例" class="headerlink" title="var与let的经典案例"></a>var与let的经典案例</h2><p>用var定义i变量，循环后打印i的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 案例1</span><span class="token comment">// i是var声明的，在全局范围内都有效，全局只有一个变量i，输出的是最后一轮的i值，也就是 10</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span></code></pre><p>用let定义i变量，循环后打印i的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 案例2</span><span class="token comment">// 用let声明i，for循环体内部是一个单独的块级作用域，相互独立，不会相互覆盖</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></code></pre><h2 id="let-实现原理"><a href="#let-实现原理" class="headerlink" title="let 实现原理"></a>let 实现原理</h2><p><strong>借助闭包和函数作用域来实现块级作用域的效果</strong></p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 用var实现案例2的效果var a &#x3D; [];var _loop &#x3D; function _loop(i) &#123;  a[i] &#x3D; function() &#123;    console.log(i);  &#125;;&#125;;for (var i &#x3D; 0; i &lt; 10; i++) &#123;  _loop(i);&#125;a[0](); &#x2F;&#x2F; 0</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域：可访问变量的集合</p><p>作用域最大的用处就是 <code>隔离变量</code>，不同作用域下同名变量不会有冲突</p><h2 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a>作用域类型</h2><p><code>全局作用域</code>、<code>函数作用域</code>、ES6中新增了 <code>块级作用域</code></p><p><strong>函数作用域</strong></p><p>是指声明在函数内部的变量，函数的作用域在函数定义的时候就决定了</p><p><strong>块作用域</strong></p><p>1）块作用域由 <code>&#123; &#125;</code>包括，if和for语句里面的 <code>&#123; &#125;</code>也属于块作用域</p><p>2）在块级作用域中，可通过let和const声明变量，该变量在指定块的作用域外无法被访问</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，首先会先从当前上下文的变量对象（作用域）中查找，如果没有找到，就会从父级的执行上下文的变量对象中查找，如果还没有找到，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 <code>作用域链</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue3</title>
      <link href="/2023/03/13/vue3/"/>
      <url>/2023/03/13/vue3/</url>
      
        <content type="html"><![CDATA[<p>MVVM: Model-View-View Model</p><p>vue负责vm的工作(视图模型)，通过vue可以将视图和模型相关联</p><p>vue思想：</p><ul><li>组件化开发</li><li>声明式编程</li></ul><p>在vue3中，组件就是一个普通的js对象</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS注意点</title>
      <link href="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><h3 id="怎么创建BFC"><a href="#怎么创建BFC" class="headerlink" title="怎么创建BFC"></a>怎么创建BFC</h3><ol><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block、table-cell、table-caption、flex、inline-flex</li><li>overflow不为visible</li></ol><blockquote><p>虽然添加上述的任意一条都能创建BFC，但会有一些副作用</p></blockquote><ol><li>float: left 将把元素移至左侧，并被其他元素环绕</li><li>display: table 可能引发响应性问题</li><li>overflow: scroll 可能产生多余的滚动条</li></ol><p><strong>最常用是overflow为hidden，这种方式的副作用最小，其他三种方式的副作用较大</strong></p><h3 id="BFC中盒子怎么对齐"><a href="#BFC中盒子怎么对齐" class="headerlink" title="BFC中盒子怎么对齐"></a>BFC中盒子怎么对齐</h3><p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。</p><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>常规流布局时，盒子都是垂直排列，两者之间的间距由各自的外边距所决定，但不是二者外边距之和。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>p<span class="token operator">></span>Sibling <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span>p<span class="token operator">></span>Sibling <span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment">//对应的CSS</span><span class="token punctuation">.</span>container <span class="token punctuation">&#123;</span>  background<span class="token operator">-</span>color<span class="token operator">:</span> red<span class="token punctuation">;</span>  <span class="token literal-property property">overflow</span><span class="token operator">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* creates a block formatting context */</span><span class="token punctuation">&#125;</span>p <span class="token punctuation">&#123;</span>  background<span class="token operator">-</span>color<span class="token operator">:</span> lightgreen<span class="token punctuation">;</span>  <span class="token literal-property property">margin</span><span class="token operator">:</span> 10px <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>渲染结果图：</p><p><img src="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/1.PNG" alt="1678677743829"></p><p>在上图中，一个红盒子（div）包含着两个兄弟元素（p），一个BFC已经创建了出来。</p><p>理论上，两个p元素之间的外边距应当是二者外边距之和（20px）但实际上却是10px，这是外边距折叠(Collapsing Margins)的结果。</p><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果按照如下规则计算：</p><ol><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ol><p>产生折叠的必备条件：margin必须是邻接的!</p><h2 id="sticky-粘性布局"><a href="#sticky-粘性布局" class="headerlink" title="sticky 粘性布局"></a>sticky 粘性布局</h2><p><code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是 <code>position:relative</code>和 <code>position:fixed</code>的结合体——当元素在屏幕内，表现为 <code>relative</code>，就要滚出显示器屏幕的时候，表现为 <code>fixed</code></p><p><img src="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/sticky-layout-s.gif" alt="1678679237721"></p><p>正如大家看到，随着页面的滚动，当导航距离上边缘0距离的时候，黏在了上边缘，表现如同 <code>position:fixed</code>。</p><p>这就是 <code>position:sticky</code>最基本的表现，特别适合导航的跟随定位效果。</p><h3 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position:sticky"></a>position:sticky</h3><p><code>position:sticky</code>有个非常重要的特性，那就是 <strong>sticky元素效果完全受制于父级元素们</strong> 。</p><p>这和 <code>position:fixed</code>定位有着根本性的不同，fixed元素直抵页面根元素，其他父元素对其left/top定位无法限制。</p><p><strong>发现了sticky元素一些特性表现：</strong></p><ol><li>父级元素不能有任何 <code>overflow:visible</code>以外的overflow设置，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）。因此，如果你的 <code>position:sticky</code>无效，看看是不是某一个祖先元素设置了 <code>overflow:hidden</code>，移除之即可。</li><li>父级元素设置和粘性定位元素等高的固定的 <code>height</code>高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果。</li><li>同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，且这些父元素正好紧密相连，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li><li>sticky定位，不仅可以设置 <code>top</code>，基于滚动容器上边缘定位；还可以设置 <code>bottom</code>，也就是相对底部粘滞。如果是水平滚动，也可以设置 <code>left</code>和 <code>right</code>值。</li></ol><h3 id="层次滚动实现原理"><a href="#层次滚动实现原理" class="headerlink" title="层次滚动实现原理"></a>层次滚动实现原理</h3><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;article&gt;    &lt;section&gt;        &lt;h4&gt;网曝王宝强殴打马蓉&lt;&#x2F;h4&gt;        &lt;content&gt;            &lt;p&gt;12月2日，有网友爆料称...&lt;&#x2F;p&gt;        &lt;&#x2F;content&gt;        &lt;footer&gt;网友评论：...&lt;&#x2F;footer&gt;    &lt;&#x2F;section&gt;    &lt;section&gt;        &lt;h4&gt;知情人爆料称马蓉闯入王宝强家拿剪刀对峙&lt;&#x2F;h4&gt;        &lt;content&gt;            &lt;p&gt;...&lt;&#x2F;p&gt;        &lt;&#x2F;content&gt;        &lt;footer&gt;网友评论：...&lt;&#x2F;footer&gt;    &lt;&#x2F;section&gt;    ...&lt;&#x2F;article&gt;</code></pre><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">article h4, h4</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">content</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">footer</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> 50vh<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>由于每一段短新闻都在section标签中，属于不同的父元素，因此，滚动的时候，后面的新闻标题才能把前面已经sticky定位的新闻标题推开，这是sticky定位天然的特性，无需任何JavaScript的帮助。所以，<code>position:sticky</code>布局的时候，使用合适的HTML结构很重要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2023/03/12/webpack/"/>
      <url>/2023/03/12/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="构建工具介绍"><a href="#构建工具介绍" class="headerlink" title="构建工具介绍"></a>构建工具介绍</h2><p>当我们习惯了在node中编写代码的方式后，再回到前端写html、css、js时会感到各种不便。比如：不能放心地使用模块化规范（浏览器兼容性问题），即使可以使用模块化规范也会面临模块过多时的加载问题。因此迫切希望有一款工具可以对代码进行打包，将多个模块打包成一个文件，这样既可以解决兼容性问题，又可以解决模块过多的问题。</p><p>通过构建工具可以将使用ESM规范编写的代码转换为旧的JS语法，可以使得所有浏览器都支持代码。</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>使用步骤：</p><ol><li>初始化项目 npm init -y</li><li>安装依赖webpack、webpack-cli</li><li>在项目中创建src目录，然后编写代码</li><li>执行npx webpack来对代码进行打包（打包后观察dist目录）</li></ol><p><img src="/2023/03/12/webpack/webpack.png" alt="1678633324626"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2023/03/10/nodejs/"/>
      <url>/2023/03/10/nodejs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nodejs.dev/en/">nodejs文档</a></p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程（厂房）：程序运行的环境</li><li>线程（工人）：实行进行运算的东西</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p><h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python 通过多线程来解决，成本高</p><p>node.js 通过异步方式解决</p><p>异步：一段代码的执行不会影响其它代码</p><ul><li>异步的问题：无法通过return设置返回值</li><li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li></ul><p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）</p><p>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p><ul><li>创建promise时，构造函数中需要一个函数作为参数。</li><li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li><li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li><li>通过promise的实例方法then来读取promise中存储的数据</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"哈哈"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p><pre class="language-JS" data-language="JS"><code class="language-JS">Promise.then((result)&#x3D;&gt;&#123;    console.log(&quot;promise中的数据&quot;,result)&#125;,(reason)&#x3D;&gt;&#123;    console.log(&quot;数据&quot;,reason)&#125;)</code></pre><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul><li>catch()用法和then类似，但是只需要一个回调函数作为参数</li><li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>finally()无论是正常存储还是出现异常了，都会执行</li><li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li></ul><h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><ul><li>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）</li><li>finally的返回值不会存到新的promise中</li></ul><h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p><ul><li>PromiseResult: 用来存储数据</li><li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p><h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><pre class="language-JS" data-language="JS"><code class="language-JS">function sum(a,b)&#123;    return new Promise((resolve,reject)&#x3D;&gt;&#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(a+b)        &#125;, 500);    &#125;)&#125;sum(123,456)    .then(result&#x3D;&gt;result+7)    .then(result&#x3D;&gt;result+8)    .then(result&#x3D;&gt;console.log(result))&#125;)</code></pre><p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p><h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul><li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li></ul><pre class="language-JS" data-language="JS"><code class="language-JS">new Promise((resolve,reject)&#x3D;&gt;&#123;            resolve()    &#125;)</code></pre><ul><li>Promise.reject() 创建一个立即拒绝的promise</li><li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误 </li></ul><pre class="language-JS" data-language="JS"><code class="language-JS">function sum(a,b)&#123;    return new Promise((resolve,reject)&#x3D;&gt;&#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(a+b)        &#125;, 500);    &#125;)&#125;Promise.all([sum(123,456),sum(5,6),sum(3,4)])</code></pre><ul><li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li><li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li><li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p><p>调用栈：</p><ul><li>栈是一种数据结构，先进后出</li><li>调用栈中放的是要执行的代码<br>任务队列</li><li>队列是一种数据结构，先进先出</li><li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li></ul><p>JS中任务队列有两种</p><ul><li>宏任务队列（大部分代码都去宏任务队列中去排队）</li><li>微任务队列（Promise的回调函数（then、catch、finally））</li></ul><p>整个流程：</p><ol><li>执行调用栈中的代码</li><li>执行微任务队列中的任务</li><li>执行宏任务队列中的任务</li></ol><p>queueMicrotask()用来向微任务队列中添加一个任务</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span><span class="token function">resolve</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出4,33,1,2,3</span></code></pre><p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p><p>注意以下代码的运行顺序</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//输出1,2,3</span></code></pre><p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出1,2,4,3</span></code></pre><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p><ol><li>无法选择要引入模块的哪些内容</li><li>在复杂的场景下容易出错</li></ol><p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p><ul><li>使用require（“模块的路径”）函数引入模块</li><li>引入自定义模块时，模块名要以./或者../开头</li><li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li></ul><p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p><p>访问exports的方式有着两种：</p><ul><li>exports</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li>module.exports</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span></code></pre><p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path<span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span></code></pre><p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p><h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p><ul><li>使用.mjs作为扩展名</li><li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li></ul><p>向外部导出内容：export</p><p>导入内容：</p><ul><li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li></ul><p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p><p>导入：</p><ul><li>import 变量名 from “url” 变量名可以随意命名</li></ul><p>es模块都运行在严格模式下</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p><p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p><ul><li>process.exit()  结束当前进程</li><li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> process <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"process"</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//输出4、3、2、1</span></code></pre><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p><p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p><p>工作目录不同，所产生的绝对路径也就不同</p><p>最终形态：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token keyword">const</span> result <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./05.promise.js"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p><ul><li><p>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</p></li><li><p>fs.readFile()，异步的文件读取方法</p></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>    path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> buffer</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>主流用法：promise版本的fs</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"fs/promises"</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span> <span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">buffer</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p><p>npm init 初始化项目，创建package.json文件（需要回答问题）</p><p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p><p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p><ul><li>将包下载到当前项目的node_modules目录下</li><li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li><li>会自动添加package-lock.json文件：加速npm下载的，不用动</li></ul><p>npm i 自动安装所有依赖</p><p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p><p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p><p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p><p>镜像的配置：</p><ul><li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p><p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p><p><a href="https://space.bilibili.com/1500126264">b站</a></p><p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p><p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p><h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p><p>第二步中客户端如何和服务器建立（断开）连接</p><p>答：<br>三次握手（建立连接）  </p><ul><li>客户端发送请求连接（SYN:同步）</li><li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li><li>客户端向服务器发送同意连接的信息（ACK：同意）</li></ul><p>四次挥手（断开连接）</p><ul><li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li><li>服务器向客户端返回数据，知道了（ACK）</li><li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li><li>客户端向服务器发数据，可以断开了（ACK）</li></ul><p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p><p>TCP/IP协议族：规定了互联网中所有的通信细节</p><p>网络通信的过程由四层组成</p><ul><li>应用层<br>软件层面，浏览器、服务器都属于应用层</li><li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li><li>网络层<br>负责给数据包，添加信息</li><li>数据链路层<br>传输信息</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的（请求字符串是明文，不安全）</p><h3 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h3><p>客户端发送给服务器的报文称为请求报文</p><p>请求报文的格式：</p><ul><li><p>请求首行<br>第一部分  get/post：get请求主要用来向服务器请求资源，没有请求体，键值对为明文，安全性差，且不能发送较大的数据；post请求主要用来向服务器发送数据，post请求有请求体，无法在地址栏直接查看，安全性较好，请求体大小没有限制，可以发送任意大小的数据，所以尽量用post发送请求<br>第二部分  请求资源的路径，多个名值对用&amp;连接<br>第三部分  http协议版本</p></li><li><p>请求头<br>请求头也是名值对结构，用来告诉服务器我们浏览器的信息（浏览器可以接受的文件类型、浏览器允许的压缩的编码、浏览器的信息）</p></li><li><p>空行<br>用来分隔请求头和请求头</p></li><li><p>请求体<br>post请求直接通过请求体发送数据</p></li></ul><h3 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h3><p>服务器发送给客户端的报文称为请求报文</p><ul><li><p>响应首行<br>第一部分  http协议版本<br>第二部分  响应状态码<br>响应状态码的规则：</p><ul><li>1xx  请求处理中</li><li>2xx  请求成功</li><li>3xx  请求重定向</li><li>4xx  客户端错误</li><li>5xx  服务器错误<br>第三部分  对响应状态码的描述</li></ul></li><li><p>响应头<br>也是名值对结构，告诉浏览器响应的信息（响应体的类型、大小等）</p></li><li><p>空行<br>分隔响应头和响应体</p></li><li><p>响应体<br>服务器返回给客户端的内容</p></li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>express是node中的服务器软件，通过express可以快速在node中搭建一个web服务器</p><p>使用步骤：</p><ol><li>创建并初始化项目：npm init -y</li><li>安装express: npm add express</li><li>创建index.js编写代码</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入express</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token comment">// 获取服务器的实例（一起皆对象）</span><span class="token keyword">const</span> app<span class="token operator">=</span><span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// "/"相当于http://localhost:3000</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">// req：请求信息，res:响应信息</span>    <span class="token comment">// 在路由中，应该做两件事:读取用户的请求和根据请求返回响应</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"这是hello路由"</span>）<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//启动服务器(监听端口号)，启动后就可以通过3000端口来访问了</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>"服务器已启动“”）<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="nodemon使用"><a href="#nodemon使用" class="headerlink" title="nodemon使用"></a>nodemon使用</h3><p>代码修改后可以自动重启服务器</p><p>使用方式：全局安装</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">npm i nodemon -g</code></pre><p>启动：</p><ul><li>nodemon  运行index.js</li><li>nodemon xxx  运行指定的js</li></ul><h3 id="访问服务器呈现页面"><a href="#访问服务器呈现页面" class="headerlink" title="访问服务器呈现页面"></a>访问服务器呈现页面</h3><p>服务器器中的代码，对于外部来说是不可见的，所以写的html页面，浏览器无法直接访问，需要将页面所在的目录设置为静态资源的目录（public文件夹）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入express</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 设置static中间价后，浏览器访问时会自动去public目录寻找是否有匹配的静态资源</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">static</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"这是hello1路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"服务器已启动"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>在路径中以冒号命名的部分称为param,可以通过req.params获取。param一般不会传递很复杂的参数</p><h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><p>get请求通过req.query获取参数，post通过req.body获取参数</p><p>默认情况下，express不会自动解析请求头，需要通过中间价来为其增加功能</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入解析请求头的中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="错误路由"><a href="#错误路由" class="headerlink" title="错误路由"></a>错误路由</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 在所有路由后边配置错误路由</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"您访问的地址已被劫持"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h4><p>ejs是node中的一款模板引擎长得像个网页，可以嵌入变量</p><p>使用步骤：</p><ol><li>安装ejs</li><li>配置express的模板引擎为ejs</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 将ejs设置为默认的模板引擎</span>app<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"view engine"</span><span class="token punctuation">,</span><span class="token string">"ejs"</span><span class="token punctuation">)</span></code></pre><p><strong>注意</strong>模板引擎需要被express渲染后才能使用,res.render()用来渲染一个模板引擎，并将其返回给浏览器</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/students"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"students"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是express中创建的一个对象,实际上是一个中间件，可以在该中间件上绑定各种路由以及其他的中间件（便于管理）</p><p>新建routes文件夹，在该文件夹下存放各种路由数据的文件，再在服务器的主文件中引入使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> express<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token keyword">const</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"./list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hell0,我是list"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports<span class="token operator">=</span>router</code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> userRouter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./routes/user"</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>userRouter<span class="token punctuation">)</span></code></pre><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</p><p>cookie是HTTP协议中用来解决无状态问题的技术，本质就是一个头，服务器以响应头的形式将cookie发送给客户端，客户端收到后会将其存储，并在下次向服务器发送请求时将其传回，这样服务器就可以根据cookie来识别出客户端</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// cookie解析</span><span class="token keyword">const</span> cookieParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"cookie-parser"</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cookieParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> username<span class="token punctuation">,</span> password <span class="token punctuation">&#125;</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>body    <span class="token keyword">if</span><span class="token punctuation">(</span>username <span class="token operator">===</span> <span class="token string">"admin"</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">===</span> <span class="token string">"123123"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 将用户名放入cookie</span>        res<span class="token punctuation">.</span><span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/students/list"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"stuents"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">stus</span><span class="token operator">:</span><span class="token constant">STU</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>cookie的不足：<br>cookie是由服务器创建，浏览器保存，每次浏览器访问服务器时都需要将cookie发回，这就导致我们不能在cookie存放较多的数据，并且cookie是直接存储在客户端，容易被篡改盗用，不能存储敏感数据</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>为了解决cookie的不足，希望可以将每个用户的数据都有一个对应的id，只需要通过cookie将id发送给浏览器，浏览器每次访问只需将id发回，即可读取到服务器中的数据。</p><p>session是服务器中的一个对象，这个对象用来存储用户的数据，每一个session对象都有一个唯一的id，会通过cookie的形式发送给客户端，客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 引入session</span><span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express-session"</span><span class="token punctuation">)</span><span class="token comment">// 设置session中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">session</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">secret</span><span class="token operator">:</span><span class="token string">"dazhaxie"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> username<span class="token punctuation">,</span> password <span class="token punctuation">&#125;</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>body    <span class="token keyword">if</span><span class="token punctuation">(</span>username <span class="token operator">===</span> <span class="token string">"admin"</span> <span class="token operator">&amp;&amp;</span> password <span class="token operator">===</span> <span class="token string">"123123"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 登录成功后，将用户名放入session，这里仅仅是添加到了内存中的session，而没有写入文件中</span>        req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>loginUser <span class="token operator">=</span> username        <span class="token comment">// 为了使得session可以立刻存储</span>        req<span class="token punctuation">.</span>session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/students/list"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello路由"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token comment">//session的默认有效期是一次会话</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>loginUser<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">"stuents"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token literal-property property">stus</span><span class="token operator">:</span><span class="token constant">STU</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>que</title>
      <link href="/2023/03/10/que/"/>
      <url>/2023/03/10/que/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>此项目为在线电商Web App (SPA)，包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块，使用Vue全家桶+ES6++Webpack+Axios等前端热门技术，采用模块化、组件化、工程化的模式开发</p><p>首先为每个单页面编写了html\css的静态页面，使用vue-cli脚手架搭建项目，根据模块将静态页面拆分成静态组件，为每个组件配置路由，建一个router文件夹,专门用来配置路由，在router的总文件中可以设置全局路由守卫，在某个具体的路由配置中可以设置路由独享守卫。组件分为路由组件和非路由组件，放在两个不同的文件夹中，其中非路由组件分为全局组件（三级联动、分页器、轮播图）和非全局组件（header、footer），全局组件在入口文件main.js中引入，可在任意组件中使用。</p><p>用axios发送ajax请求，首先对axios进行二次封装，配置基础路径以及请求超时的时间，另外配置请求拦截器和响应拦截器，同时配置请求进度条。引入vuex插件，在actions中发送请求，将获得的数据存放在state中，组件需要的时候，派发actions捞取数据进行展示，以此实现前后端交互、数据动态展示。</p><p>使用导航守卫实现以下功能：</p><ul><li>只有登陆了, 才能查看交易/支付/个人中心界面</li><li>只有没有登陆, 才能查看登陆界面</li><li>只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面</li><li>只能从购物车界面, 才能跳转到交易界面</li><li>只能从交易界面, 才能跳转到支付界面</li><li>只有从支付界面, 才能跳转到支付成功的界面</li></ul><h3 id="项目中的难点、亮点、挑战"><a href="#项目中的难点、亮点、挑战" class="headerlink" title="项目中的难点、亮点、挑战"></a>项目中的难点、亮点、挑战</h3><p>1 mock模拟数据，实现前后端分离开发<br>2 组件间通信：父组件给子组件传递数据用props、子组件给父组件用自定义事件、兄弟组件间通信用全局事件总线（$bus）<br>3 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误，是因为编程式导航中引入了promise语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，解决办法，重写push和replace，指定两个空回调<br>4 展示某用户的订单信息：携带token。携带手机号、验证码、密码等数据进行注册请求，注册成功后，服务器会下发token。当携带手机号和密码进行登录请求时，可获取相应的token，在请求拦截器中将token作为一个字段添加到响应头，此后发送的请求都会带着token获取数据。<br>5 表单验证：</p><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>编程式路由导航：</p><ul><li>push</li><li>replace</li></ul><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误"><a href="#编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误" class="headerlink" title="编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误"></a>编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误</h3><p>解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误<br>解决2: 修正Vue原型上的push和replace方法 (优秀)</p><h3 id="如何指定params参数可传可不传"><a href="#如何指定params参数可传可不传" class="headerlink" title="如何指定params参数可传可不传?"></a>如何指定params参数可传可不传?</h3><p>path: ‘/search/:keyword?’</p><h3 id="指定params参数时可不可以用path和params配置的组合"><a href="#指定params参数时可不可以用path和params配置的组合" class="headerlink" title=":指定params参数时可不可以用path和params配置的组合?"></a>:指定params参数时可不可以用path和params配置的组合?</h3><p>不可以,用path和params配置的组合, 只能用name和params配置的组合<br>query配置可以与path或name进行组合使用</p><h3 id="如果指定name与params配置-但params中数据是一个””-无法跳转"><a href="#如果指定name与params配置-但params中数据是一个””-无法跳转" class="headerlink" title="如果指定name与params配置, 但params中数据是一个””, 无法跳转"></a>如果指定name与params配置, 但params中数据是一个””, 无法跳转</h3><p>解决1: 不指定params<br>解决2: 指定params参数值为undefined</p><h3 id="路由组件能不能传递props数据"><a href="#路由组件能不能传递props数据" class="headerlink" title="路由组件能不能传递props数据?"></a>路由组件能不能传递props数据?</h3><p>可以: 可以将query或且params参数映射/转换成props传递给路由组件对象<br>实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p><h2 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><ul><li>基础路径</li><li>请求超时时间</li><li>请求拦截器（请求进度条，携带token）</li><li>响应拦截器</li></ul><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>在准备跳转到某个路由组件之前 (在开发中用的比较多)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//全局前置守卫（路由跳转之前进行判断）</span><span class="token comment">//登录后不能再进登录界面</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span>    <span class="token keyword">let</span> token <span class="token operator">=</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>token<span class="token punctuation">;</span>    <span class="token keyword">let</span> name <span class="token operator">=</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>userInfo<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果登录了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/login'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果还要去登录界面</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'./home'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 如果有用户信息</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">await</span> store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'getUserInfo'</span><span class="token punctuation">)</span>                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//token失效了，获取不到用户信息，重新登录</span>                    <span class="token keyword">await</span> store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'userLogout'</span><span class="token punctuation">)</span>                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 未登录，不能去交易相关的页面，若要去先登录</span>        <span class="token keyword">let</span> toPath<span class="token operator">=</span>to<span class="token punctuation">.</span>path        <span class="token keyword">if</span><span class="token punctuation">(</span>toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'./trade'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'./pay'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>toPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'/center'</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'/login?redirect='</span><span class="token operator">+</span>toPath<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>说明: to:<br>目标route;<br>from: 起始route;</p><p>next: 放行函数</p><ul><li>next(): 执行下一个守卫回调, 如果没有跳转到目标路由</li><li>next(false)/不执行: 跳转流程在当前处中断, 不会跳转到目标路由组件</li><li>next(path): 跳转到指定的另一个路由</li></ul><ol start="2"><li>全局后置守卫: 在跳转到某个路由组件之后</li></ol><p>router.afterEach((to, from) =&gt; {})</p><ol start="3"><li>路由独享守卫</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 路由独享守卫</span>        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 去交易页面，必须是从购物车来的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>from<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">"/shopcart"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span></code></pre><p>3 组件守卫</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 组件内守卫</span>    <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 在渲染该组件的路由被confirm前调用</span>      <span class="token comment">// 不能获取组件实例this，因为当守卫执行前，组件实例还没被创建</span>      <span class="token comment">// 但可以通过next(component => &#123;&#125;), 在回调函数中访问组件对象</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>from<span class="token punctuation">.</span>path<span class="token operator">==</span><span class="token string">'/pay'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 当前组件对象将要更新前调用, 可以访问this</span><span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">// 在当前组件离开前调用, 可以访问this</span><span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/02/25/git/"/>
      <url>/2023/02/25/git/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p><ul><li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li><li>在不影响现行开发工作的情况下对代码进行维护</li><li>开发时，某段代码被多人修改时，处理代码的冲突问题</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://git-scm.com/">Git</a>无脑下载</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre class="language-cmd" data-language="cmd"><code class="language-cmd">git config --global user.name &quot;zoujingke&quot;git config --global user.name &quot;zoujk640852@163.com&quot;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>git status：查看当前仓库的状态，是否被git管理<br>git init：初始化仓库<br>git log: 查看操作日志</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>被git管理的文件有三种状态：</p><ul><li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li><li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li><li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li></ul><p>可以通过git status查看文件的状态</p><p>新添加的文件处于未跟踪状态（未被git管理）:</p><ul><li>未跟踪-&gt;暂存：git add <code>&lt;filename&gt;</code></li><li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li><li>未修改-&gt;修改：修改代码后，转为修改状</li><li>修改-&gt;暂存：git add <code>&lt;filename&gt;</code></li></ul><p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>恢复文件：<br>git restore <code>&lt;filename&gt;</code> | git restore *<br>删除文件：<br>git rm <code>&lt;filename&gt;</code> 若文件当前是修改状态，不会删除文件。<br>git rm <code>&lt;filename&gt;</code> -f 强制删除<br>取消暂存状态：<br>git restore –stage<br>移动文件：（重命名）<br>git mv <code>&lt;oldfilename&gt;</code> <code>&lt;newfilename&gt;</code></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p><p>git branch 查看所有分支<br>git branch &lt;分支名&gt; 创建分支<br>git branch -d &lt;分支名&gt; 删除分支<br>git switch &lt;分支名&gt; 切换当前所处分支<br>git branch -c &lt;分支名&gt; 创建分支且设为当前所处分支<br>git merge &lt;分支名&gt; 将该分支合并到主分支上</p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>开发中，除了通过merge合并分支外，还可以通过变基完成分支的合并。merge合并分支时，在提交记录中会将所有的分支创建和分支合并的过程全部都显示出来，这样当项目比较复杂，开发过程比较波折时，必须要反复地创建、合并、删除分支。但是这样会使得代码的提交记录会变得极其混乱。</p><p>变基原理：</p><ol><li>当发起变基时，git会首先找到两条分支的最近的共同祖先。</li><li>对比当前分支相对于祖先的历史提交，并且将它们提取处理存储到一个临时文件中</li><li>将当前部分指向目标的基底</li><li>以当前基底开始，重新执行历史操作</li></ol><p>变基和merge对于合并分支来说最终的结果是一样的，但是变基会使得代码的提交记录会更整洁更清晰。注意！大部分情况下合并和变基是可以互换的，但是如果分支已经提交给了远程仓库，尽量不要使用变基。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>以上对于git的所有操作都是在本地进行的。在开发中，我们需要一个远程的git仓库。远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p><p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p><p>将本地库上传git：</p><p>git remote add origin <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:Peggyzou/-.git   origin：远程库的名字   后面为远程库的url<br>git branch -M main   修改分支的名字<br>git push -u origin main   将代码上传到服务器上</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/12/hello-world/"/>
      <url>/2023/02/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
