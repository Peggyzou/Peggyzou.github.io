<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解浏览器中的进程和线程</title>
      <link href="/2023/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程的联系和区别"><a href="#进程和线程的联系和区别" class="headerlink" title="进程和线程的联系和区别"></a>进程和线程的联系和区别</h1><p>当我们启动某个程序时，操作系统会给该程序创建一块内存(当程序关闭时，该内存空间就会被回收)，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境就叫 <code>进程</code></p><p>而 <code>线程</code>是依附于进程的，在进程中使用多线程并行处理能提升运算效率，进程将任务分成很多细小的任务，再创建多个线程，在里面并行分别执行</p><p>进程和线程的关系特点是这样的：</p><ul><li>进程与进程之间完全隔离，互不干扰，一个进程崩溃不会影响其他进程，避免一个进程出错影响整个程序</li><li>进程与进程之间需要传递某些数据的话，就需要通过 <code>进程通信管道IPC</code>来传递</li><li>一个进程中可以并发多个线程，每个线程并行执行不同的任务</li><li>一个进程中的任意一个线程执行出错，会导致这个进程崩溃</li><li>同一进程下的线程之间可以直接通信和共享数据</li><li>当一个进程关闭之后，操作系统会回收该进程的内存空间</li></ul><p><strong>早期浏览器</strong></p><p>2007年以前浏览器并不是多进程的结构，而是单进程的结构，一个进程中包含了网络、JS运行环境、渲染引擎、页面、插件等，这也导致单进程的结构引发了很多问题</p><ul><li>一是 <code>不稳定</code>，其中一个线程卡死，可能会导致整个程序出问题，比如打开多个标签页，其中一个标签页卡死可能会导致整个浏览器无法正常运行</li><li>二是 <code>不安全</code>，浏览器一个进程里是可以共享数据的，那JS线程岂不是可以随意访问浏览器进程内的所有数据，这显然不合理</li><li>三是 <code>不流畅</code>，一个进程需要负责太多事情，会导致运行效率问题</li></ul><p>所以为了解决这些问题，才发展出了多进程结构</p><p>我们来看一下目前最新的Chrom有进程架构</p><h1 id="Chrome-打开一个页面有多少进程？分别是哪些"><a href="#Chrome-打开一个页面有多少进程？分别是哪些" class="headerlink" title="Chrome 打开一个页面有多少进程？分别是哪些"></a>Chrome 打开一个页面有多少进程？分别是哪些</h1><p>浏览器从关闭到启动，然后新开一个页面至少需要： <strong>1个浏览器进程，1个GPU进程，1个网络进程，和1个渲染进程，一共4个进程</strong> ；</p><p>后续如果再打开新的标签页：浏览器进程，GPU进程，网络进程是共享的，不会重新启动，然后默认情况下会为每一个标签页配置一个渲染进程，但是也有 <code>例外</code>，比如从A页面里面打开一个新的页面B页面，而A页面和B页面又属于同一站点的话，A和B就共用一个渲染进程，其他情况就为B创建一个新的渲染进程</p><p>所以，最新的Chrome浏览器包括：<code>1个浏览器主进程</code>，<code>1个GPU进程</code>，<code>1个网络进程</code>，<code>多个渲染进程</code>，和 <code>多个插件进程</code></p><ul><li><code>浏览器进程</code>： 负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能</li><li><code>GPU进程</code>：负责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程</li><li><code>网络进程</code>：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程</li><li><code>插件进程</code>：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响</li><li><code>渲染进程</code>：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程</li></ul><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，所以我们来看一下渲染进程中的线程</p><h2 id="渲染进程中的线程"><a href="#渲染进程中的线程" class="headerlink" title="渲染进程中的线程"></a>渲染进程中的线程</h2><ul><li><code>GUI渲染线程</code>：负责渲染页面，解析html和CSS、构建DOM树、CSSOM树、渲染树、和绘制页面，重绘重排也是在该线程执行</li><li><code>JS引擎线程</code>：一个tab页中只有一个JS引擎线程(单线程)，负责解析和执行JS。<strong>它GUI渲染进程不能同时执行，只能一个一个来，如果JS执行过长就会导致阻塞掉帧</strong></li><li><code>计时器线程</code>：指setInterval和setTimeout，因为JS引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作</li><li><code>异步http请求线程</code>： XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行</li><li><code>事件触发线程</code>：主要用来控制事件循环，比如JS执行遇到计时器，AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等JS引擎处理</li></ul><h1 id="说下浏览器的进程、线程模型，线程模型中的每个线程都是干嘛用的？"><a href="#说下浏览器的进程、线程模型，线程模型中的每个线程都是干嘛用的？" class="headerlink" title="说下浏览器的进程、线程模型，线程模型中的每个线程都是干嘛用的？"></a>说下浏览器的进程、线程模型，线程模型中的每个线程都是干嘛用的？</h1><p>Chrome为例，有四种 <code>进程模型</code>，分别是</p><ul><li><code>Process-per-site-instance</code>：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程不会创建</li><li><code>Process-per-site</code>：同一站点使用同一进程</li><li><code>Process-per-tab</code>：每一个标签页都创建新的进程</li><li><code>Single Process</code>：单进程模式</li></ul><p>线程模型中的线程都是干嘛的呢？</p><ul><li><code>MessagePumpForIO</code>：处理进程间通信的线程，在Chrome中，这类线程都叫做IO线程</li><li><code>MessagePumpForUI</code>：处理UI的线程用的</li><li><code>MessagePumpDefault</code>：一般的线程用到的</li></ul><p><strong>每一个Chrome的线程，入口函数都差不多，都是启动一个消息循环，等待并执行任务</strong></p><h1 id="你知道哪些进程间通信的方式？"><a href="#你知道哪些进程间通信的方式？" class="headerlink" title="你知道哪些进程间通信的方式？"></a>你知道哪些进程间通信的方式？</h1><ul><li><code>管道通信</code>：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了</li><li><code>消息队列通信</code>：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制</li><li><code>共享内存通信</code>：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是 <code>IPC</code>方式</li><li><code>信号量通信</code>：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了</li><li><code>socket</code>：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据</li></ul><h1 id="多标签之间怎么通信？"><a href="#多标签之间怎么通信？" class="headerlink" title="多标签之间怎么通信？"></a>多标签之间怎么通信？</h1><p>没有办法直接通信，需要有一个类似中介者进行消息的转发和接收，比如</p><ul><li><code>localStorage</code>：在一个标签页监听localStorage的变化，然后当另一个标签页修改的时候，可以通过监听获取新数据</li><li><code>WebSocket</code>：因为websocket可以实现实时服务器推送，所以服务器就可以来当这个中介者。标签页通过向服务器发送数据，然后服务器再向其他标签推送转发</li><li><code>ShareWorker</code>：会在页面的生命周期内创建一个唯一的线程，并开启多个页面也只会使用同一个线程，标签页共享一个线程</li><li><code>postMessage</code>：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">parent</span>().<span class="title function_">pastMessage</span>(<span class="string">&#x27;发送的数据&#x27;</span>,<span class="string">&#x27;http://接收的址&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收方</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123; <span class="keyword">let</span> data = e.<span class="property">data</span> &#125;)</span><br></pre></td></tr></table></figure><h1 id="你知道僵尸进程和孤儿进程吗？"><a href="#你知道僵尸进程和孤儿进程吗？" class="headerlink" title="你知道僵尸进程和孤儿进程吗？"></a>你知道僵尸进程和孤儿进程吗？</h1><ul><li><code>孤儿进程</code>：故名思义，就是没爹的孩子。父进程退出了，而它的一个或多个进程还在运行，那么这些子进程都会成为孤儿进程。这些孤儿都将被init进程收养，并负责这些孤儿的以后</li><li><code>僵尸进程</code>：就是子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的描述还留在系统中，这种进程就是僵尸进程</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入Url到页面渲染的过程</title>
      <link href="/2023/11/09/%E4%BB%8E%E8%BE%93%E5%85%A5Url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/11/09/%E4%BB%8E%E8%BE%93%E5%85%A5Url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>从输入 <code>URL</code>到页面渲染需要 <code>Chrome</code>浏览器的多个进程配合，所以我们先来谈谈现阶段 <code>Chrome</code>浏览器的多进程架构。</p><h1 id="一、Chrome架构"><a href="#一、Chrome架构" class="headerlink" title="一、Chrome架构"></a>一、<code>Chrome</code>架构</h1><p>目前 <code>Chrome</code>采用的是多进程的架构模式，可分为主要的五类进程，分别是：浏览器（<code>Browser</code>）主进程、 <code>GPU</code> 进程、网络（<code>NetWork</code>）进程、多个渲染进程和多个插件进程；</p><p><img src="%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg" alt="1699491201471"></p><ul><li><strong>浏览器进程</strong> 。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong> 。核心任务是将 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code>转换为用户可以与之交互的网页，排版引擎 <code>Blink</code>和 <code>JavaScript</code>引擎 <code>V8</code>都是运行在该进程中，默认情况下，<code>Chrome</code>会为每个 <code>Tab</code>标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong><code>GPU</code>进程</strong> 。其实，<code>Chrome</code>刚开始发布的时候是没有 <code>GPU</code>进程的。而 <code>GPU</code>的使用初衷是为了实现 <code>3D CSS</code>的效果，只是随后网页、<code>Chrome</code>的 <code>UI</code>界面都选择采用 <code>GPU</code>来绘制，这使得 <code>GPU</code>成为浏览器普遍的需求。最后，<code>Chrome</code>在其多进程架构上也引入了 <code>GPU</code>进程。</li><li><strong>网络进程</strong> 。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong> 。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul><p>了解了 <code>Chrome</code>的多进程架构，就能够从宏观上理解从输入 <code>URL</code>到页面渲染的过程了，这个过程主要分为<strong>导航阶段</strong>和 <strong>渲染阶段</strong> 。</p><h1 id="二、导航阶段"><a href="#二、导航阶段" class="headerlink" title="二、导航阶段"></a>二、导航阶段</h1><h2 id="Ⅰ-浏览器主进程"><a href="#Ⅰ-浏览器主进程" class="headerlink" title="Ⅰ.浏览器主进程"></a>Ⅰ.浏览器主进程</h2><h3 id="1-用户输入-URL"><a href="#1-用户输入-URL" class="headerlink" title="1.用户输入 URL"></a>1.用户输入 <code>URL</code></h3><p><strong>1</strong> 、浏览器进程检查 <code>url</code>，组装协议，构成完整的 <code>url</code>，这时候有两种情况：</p><p>输入的是搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 <code>URL</code>。</p><p>输入的是请求 <code>URL</code>：地址栏会根据规则，给这段内容加上协议，合成为完整的 <code>URL</code>；</p><p><strong>2</strong> 、浏览器进程通过进程间通信（<code>IPC</code>）把 <code>url</code>请求发送给网络进程；</p><h2 id="Ⅱ-网络进程"><a href="#Ⅱ-网络进程" class="headerlink" title="Ⅱ.网络进程"></a>Ⅱ.网络进程</h2><h3 id="2-URL请求过程"><a href="#2-URL请求过程" class="headerlink" title="2.URL请求过程"></a>2.<code>URL</code>请求过程</h3><p><strong>3</strong> 、网络进程接收到 <code>url</code>请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程；</p><blockquote><p>这里涉及到浏览器与HTTP协议的缓存策略问题，有兴趣的可以看这篇文章：<a href="https://juejin.cn/post/7068485552059711519" title="https://juejin.cn/post/7068485552059711519">详解HTTP协议</a></p></blockquote><p><strong>4</strong> 、准备 <code>IP</code>地址和端口：进行 <code>DNS</code>解析时先查找缓存，没有再使用 <code>DNS</code>服务器解析，查找顺序为：</p><ul><li>浏览器缓存；</li><li>本机缓存；</li><li><code>hosts</code>文件；</li><li>路由器缓存；</li><li><code>ISP DNS</code>缓存；</li><li><code>DNS</code>递归查询（本地 <code>DNS</code>服务器 -&gt; 权限 <code>DNS</code>服务器 -&gt; 顶级 <code>DNS</code>服务器 -&gt; <code>13</code>台根 <code>DNS</code>服务器）</li></ul><p><strong>5</strong> 、等待 <code>TCP</code>队列：浏览器会为每个域名最多维护 <code>6</code>个 <code>TCP</code>连接，如果发起一个 <code>HTTP</code>请求时，这 <code>6</code>个 <code>TCP</code>连接都处于忙碌状态，那么这个请求就会处于排队状态；解决方案：</p><p>采用域名分片技术：将一个站点的资源放在多个（<code>CDN</code>）域名下面。</p><p>升级为 <code>HTTP2</code>，就没有 <code>6</code>个 <code>TCP</code>连接的限制了；</p><p><strong>6</strong> 、通过三次握手建立 <code>TCP</code>连接：</p><p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="1699493847394"></p><ul><li><strong>第一次</strong> ：客户端先向服务器端发送一个同步数据包，报文的 <code>TCP</code>首部中：标志位：**同步 <code>SYN</code>**为 <code>1</code>，表示这是一个请求建立连接的数据包；序号 <code>Seq=x</code>，<code>x</code>为所传送数据的第一个字节的序号，随后进入 <code>SYN-SENT</code>状态；</li></ul><blockquote><p>标志位值为 <code>1</code>表示该标志位有效。</p></blockquote><ul><li><strong>第二次</strong> ：服务器根据收到数据包的 <code>SYN</code>标志位判断为建立连接的请求，随后返回一个确认数据包，其中标志位 <code>SYN=1</code>，<code>ACK=1</code>，序号 <code>seq=y</code>，确认号 <code>ack=x + 1</code>表示收到了客户端传输过来的 <code>x</code>字节数据，并希望下次从 <code>x+1</code>个字节开始传，并进入 <code>SYN-RCVD</code>状态；</li></ul><blockquote><p>这里要区分标志位 <code>ACK</code>和确认号 <code>ack</code>；</p></blockquote><ul><li><strong>第三次</strong> ：客户端收到后，再给服务器发送一个确认数据包，标志位 <code>ACK=1</code>，序号 <code>seq=x+1</code>，确认号 <code>ack=y+1</code>，随后进入 <code>ESTABLISHED</code>状态；</li></ul><p>服务器端收到后，也进入 <code>ESTABLISHED</code>状态，由此成功建立了 <code>TCP</code>连接，可以开始数据传送；</p><ul><li><strong>为什么要第三次挥手？</strong>避免服务器等待造成<strong>资源浪费</strong> ，具体原因：</li></ul><blockquote><p>如果没有最后一个数据包确认（第三次握手），<code>A</code>先发出一个建立连接的请求数据包，由于网络原因绕远路了。<code>A</code>经过设定的超时时间后还未收到 <code>B</code>的确认数据包。</p><p>于是发出第二个建立连接的请求数据包，这次网路通畅，<code>B</code>的确认数据包也很快就到达 <code>A</code>。于是 <code>A</code>与 <code>B</code>开始传输数据；</p><p>过了一会 <code>A</code>第一次发出的建立连接的请求数据包到达了 <code>B</code>，<code>B</code>以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略 <code>B</code>发来的第二个确认数据包，但是 <code>B</code>发出确认数据包之后就要一直等待 <code>A</code>的回复，而 <code>A</code>永远也不会回复。</p><p>由此造成服务器资源浪费，这种情况多了 <code>B</code>计算机可能就停止响应了。</p></blockquote><p><strong>7</strong> 、构建并发送 <code>HTTP</code>请求信息；</p><p><strong>8</strong> 、服务器端处理请求；</p><p><strong>9</strong> 、客户端处理响应，首先检查服务器响应报文的状态码：</p><p>如果是 <code>301/302</code>表示服务器已更换域名需要重定向，这时网络进程会从响应头的 <code>Location</code>字段里面读取重定向的地址，然后再发起新的 <code>HTTP</code>或者 <code>HTTPS</code>请求，跳回第 <code>4</code>步。</p><p><img src="%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="1699493964091"></p><p><strong>10</strong> 、请求结束，当通用首部字段 <code>Conection</code>不是 <code>Keep-Alive</code>时，即不为 <code>TCP</code>长连接时，通过四次挥手断开 <code>TCP</code>连接：</p><p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="1699495192304"></p><ul><li><strong>第一次</strong> ：客户端（主动断开连接）发送数据包给服务器，其中标志位 <code>FIN=1</code>，序号位 <code>seq=u</code>，并停止发送数据；</li><li><strong>第二次</strong> ：服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回一个标志位 <code>ACK=1</code>，序号 <code>seq=v</code>，确认号 <code>ack=u+1</code>的数据包；</li><li><strong>第三次</strong> ：服务器准备好断开连接后，返回一个数据包，其中标志位 <code>FIN=1</code>，标志位 <code>ACK=1</code>，序号 <code>seq=w</code>，确认号 <code>ack=u+1</code>；</li><li><strong>第四次</strong> ：客户端收到数据包后，返回一个标志位 <code>ACK=1</code>，序号 <code>seq=u+1</code>，确认号 <code>ack=w+1</code>的数据包。</li></ul><p>由此通过四次挥手断开 <code>TCP</code>连接。</p><blockquote><p>这里涉及到TCP的三次握手和四次挥手问题，有兴趣的可以看这篇文章：<a href="https://juejin.cn/post/7071542934394372110" title="https://juejin.cn/post/7071542934394372110">详解TCP连接的“三次握手”与“四次挥手”</a></p></blockquote><ul><li><strong>为什么要四次挥手</strong> ？由于服务器不能马上断开连接，导致 <code>FIN</code>释放连接报文与 <code>ACK</code>确认接收报文需要分两次传输，即第二次和第三次”挥手”；</li></ul><h3 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="3.准备渲染进程"></a>3.准备渲染进程</h3><p><strong>11</strong> 、准备渲染进程：浏览器进程检查当前 <code>url</code>是否与之前打开了渲染进程的页面的根域名相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程；</p><h3 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="4.提交文档"></a>4.提交文档</h3><p><strong>12</strong> 、提交文档：</p><p><strong>渲染进程</strong>准备好后，<strong>浏览器</strong>向<strong>渲染进程</strong>发起“ <strong>提交文档</strong> ”的消息，<strong>渲染进程</strong>接收到消息后与<strong>网络进程</strong>建立传输数据的“ <strong>管道</strong> ”</p><p><strong>渲染进程</strong>接收完数据后，向浏览器发送“ <strong>确认提交</strong> ”</p><p><strong>浏览器进程</strong>接收到确认消息后更新浏览器界面状态： <strong>安全状态</strong> 、 <strong>地址栏 <code>url</code></strong> 、 <strong>前进后退的历史状态</strong> 、<strong>更新 <code>web</code>页面</strong></p><p><img src="%E6%9B%B4%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81.png" alt="1699495329475"></p><h1 id="三、渲染阶段"><a href="#三、渲染阶段" class="headerlink" title="三、渲染阶段"></a>三、渲染阶段</h1><p>在渲染阶段通过<strong>渲染流水线</strong>在渲染进程的主线程和合成线程配合下，完成页面的渲染；</p><h2 id="Ⅲ-渲染进程"><a href="#Ⅲ-渲染进程" class="headerlink" title="Ⅲ.渲染进程"></a>Ⅲ.渲染进程</h2><p><img src="%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png" alt="1699495463609"></p><h3 id="5-构建-DOM树"><a href="#5-构建-DOM树" class="headerlink" title="5.构建 DOM树"></a>5.构建 <code>DOM</code>树</h3><p><strong>13、</strong>先将请求回来的数据解压，随后 <code>HTML</code>解析器将其中的 <code>HTML</code><strong>字节流</strong>通过<strong>分词器</strong>拆分为一个个 <code>Token</code>，然后生成节点 <code>Node</code>，最后解析成浏览器识别的 <code>DOM</code>树结构。<br>可以通过 <code>Chrome</code>调试工具的 <code>Console</code>选项打开控制台输入 <code>document</code>查看 <code>DOM</code>树；</p><blockquote><p>渲染引擎还有一个<strong>安全检查模块</strong>叫 <code>XSSAuditor</code>，是用来<strong>检测词法安全</strong>的。在分词器解析出来 <code>Token</code> 之后，它会检测这些模块是否安全，比如 <strong>是否引用了外部脚本</strong> ， <strong>是否符合 <code>CSP</code> 规范</strong> ，<strong>是否存在跨站点请求</strong>等。如果出现不符合规范的内容，<code>XSSAuditor</code> 会对该脚本或者下载任务 <strong>进行拦截</strong> 。</p></blockquote><p>首次解析 <code>HTML</code>时<strong>渲染进程</strong>会开启一个 <strong>预解析线程</strong> ，遇到 <code>HTML</code>文档中内嵌的 <code>JavaScript</code>和 <code>CSS</code>外部引用就会同步提前下载这些文件，下载时间以最后下载完的文件为准。</p><p><img src="%E8%A7%A3%E6%9E%90HTML.png" alt="1699495620757"></p><h3 id="6-构建-CSSOM"><a href="#6-构建-CSSOM" class="headerlink" title="6.构建 CSSOM"></a>6.构建 <code>CSSOM</code></h3><p><strong>14</strong> 、 <code>CSS</code>解析器将 <code>CSS</code>转换为浏览器能识别的 <code>styleSheets</code>也就是 <code>CSSOM</code>：可以通过控制台输入 <code>document.styleSheets</code>查看；<br>这里要考虑一下阻塞的问题，由于 <code>JavaScript</code>有修改 <code>CSS</code>和 <code>HTML</code>的能力，所以，需要先等到 <code>CSS</code> 文件下载完成并生成 <code>CSSOM</code>，然后再执行 <code>JavaScript</code> 脚本，最后再继续构建 <code>DOM</code>。由于这种阻塞，导致了 <strong>解析白屏</strong> ；</p><blockquote><p><strong>优化方案：</strong></p><ul><li><strong>移除 <code>js</code>和 <code>css</code>的文件下载</strong> ：通过内联 <code>JavaScript</code>、内联 <code>CSS</code>；</li><li><strong>尽量减少文件大小</strong> ：如通过 <code>webpack</code> 等工具<strong>移除</strong>不必要的 <strong>注释</strong> ，并 <strong>压缩 <code>js</code> 文件</strong> ；</li><li>将不进行 <code>DOM</code>操作或 <code>CSS</code>样式修改的 <code>JavaScript</code> 标记上 <code>sync</code> 或者 <code>defer</code>异步引入；</li><li><strong>使用媒体查询属性</strong> ：将大的 <code>CSS</code>文件拆分成多个不同用途的 <code>CSS</code> 文件，只有在特定的场景下才会加载特定的 <code>CSS</code> 文件。</li></ul></blockquote><p>可以通过浏览器调试工具的 <code>Network</code>面板中的 <code>DOMContentLoaded</code>查看最后生成 <code>DOM</code>树所需的时间；</p><p><img src="%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png" alt="1699495731794"></p><p><img src="%E7%94%9F%E6%88%90DOM%E6%A0%91%E6%97%B6%E9%97%B4.png" alt="1699495817130"></p><h3 id="7-样式计算"><a href="#7-样式计算" class="headerlink" title="7.样式计算"></a>7.样式计算</h3><p><strong>15</strong> 、转换样式表中的属性值，使其标准化。比如将 <code>em</code>转换为 <code>px</code>，<code>color</code>转换为 <code>rgb</code>；</p><p><strong>16</strong> 、计算 <code>DOM</code>树中每个节点的具体样式，这里遵循 <code>CSS</code>的继承和层叠规则；可以通过 <code>Chrome</code>调试工具的 <code>Elements</code>选项的 <code>Computed</code>查看某一标签的最终样式；</p><h3 id="8-布局阶段"><a href="#8-布局阶段" class="headerlink" title="8.布局阶段"></a>8.布局阶段</h3><p><strong>17</strong> 、创建布局树，遍历 <code>DOM</code>树中的所有节点，去掉所有隐藏的节点（比如 <code>head</code>，添加了 <code>display:none</code>的节点），只在布局树中保留可见的节点。</p><p><strong>18</strong> 、计算布局树中节点的坐标位置（较复杂，这里不展开）；</p><h3 id="9-分层"><a href="#9-分层" class="headerlink" title="9.分层"></a>9.分层</h3><p><strong>19</strong> 、对布局树进行分层，并生成分层树（<code>Layer Tree</code>），可以通过 <code>Chrome</code>调试工具的 <code>Layer</code>选项查看。分层树中每一个节点都直接或间接的属于一个图层（如果一个节点没有对应的层，那么这个节点就从属于父节点的图层）</p><p><img src="%E5%88%86%E5%B1%82.png" alt="1699495949091"></p><h3 id="10-图层绘制"><a href="#10-图层绘制" class="headerlink" title="10.图层绘制"></a>10.图层绘制</h3><p><strong>20</strong> 、为每个图层生成绘制列表（即绘制指令），并将其提交到合成线程。以上操作都是在渲染进程中的主线程中进行的，提交到合成线程后就不阻塞主线程了；</p><p><img src="%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6.png" alt="1699496032733"></p><p>渲染进程中的合成线程部分：</p><p><img src="%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B.png" alt="1699496124695"></p><h3 id="11-切分图块"><a href="#11-切分图块" class="headerlink" title="11.切分图块"></a>11.切分图块</h3><p><strong>21、</strong>合成线程将图层切分成大小固定的图块（<code>256x256</code>或者 <code>512x512</code>）然后<strong>优先绘制</strong>靠近视口的图块，这样就可以大大加速页面的显示速度；</p><p><img src="%E5%9B%BE%E5%9D%97.png" alt="1699496219772"></p><h3 id="Ⅳ-GPU进程"><a href="#Ⅳ-GPU进程" class="headerlink" title="Ⅳ.GPU进程"></a>Ⅳ.<code>GPU</code>进程</h3><h3 id="12-栅格化操作"><a href="#12-栅格化操作" class="headerlink" title="12.栅格化操作"></a>12.栅格化操作</h3><p><strong>22、</strong>在<strong>光栅化线程池</strong>中将<strong>图块</strong>转换成 <strong>位图</strong> ，通常这个过程都会使用 <code>GPU</code>来加速生成，使用 <code>GPU</code>生成位图的过程叫 <strong>快速栅格化</strong> ，或者 <code>GPU</code>栅格化，生成的位图被保存在 <code>GPU</code>内存中。</p><p><img src="%E6%A0%85%E6%A0%BC%E5%8C%96.png" alt="1699496324080"></p><h2 id="Ⅴ-浏览器主进程"><a href="#Ⅴ-浏览器主进程" class="headerlink" title="Ⅴ.浏览器主进程"></a>Ⅴ.浏览器主进程</h2><h3 id="13-合成与显示"><a href="#13-合成与显示" class="headerlink" title="13.合成与显示"></a>13.合成与显示</h3><p><strong>23</strong> 、合成：一旦所有图块都被光栅化，<strong>合成线程</strong>就会将它们合成为一张图片，并生成一个绘制图块的命令——“<code>DrawQuad</code>”，然后将该命令提交给浏览器进程。</p><blockquote><p><strong>注意了：</strong>合成的过程是在渲染进程的<strong>合成线程</strong>中完成的，不会影响到渲染进程的<strong>主线程</strong>执行；</p></blockquote><p><strong>24</strong> 、显示：浏览器进程里面有一个叫 <code>viz</code>的组件，用来接收合成线程发过来的 <code>DrawQuad</code>命令，然后根据 <code>DrawQuad</code>命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>到这里，经过这一系列的阶段，编写好的 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>等文件，经过浏览器就会显示出漂亮的页面了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染</title>
      <link href="/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/2023/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核主要分成两部分：</p><p>渲染引擎：职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p><p>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</p><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h1 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h1><ol><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li></ol><p><img src="1.png" alt="1693397452036"></p><ol start="2"><li>对 CSS 进行解析，生成 CSSOM 规则树。</li></ol><p>在解析的过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件。 <code>注意：下载CSS文件是不会影响DOM的解析的；</code>浏览器下载完CSS文件后，就会对CSS文件进行解析，解析出对应的规则树，我们可以称之为 CSSOM（CSS Object Model，CSS对象模型）；</p><p><img src="2.png" alt="1693398076262"></p><ol start="3"><li>根据 DOM 树和 CSSOM 规则树构建渲染树。</li></ol><p>渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p><p><img src="3.png" alt="1693398229799"></p><p><code>注意：link元素不会阻塞DOM Tree的构建过程，但是会阻塞Render Tree的构建过程</code>，这是因为Render Tree在构建时，需要对应的CSSOM Tree。</p><p>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切宽度、高度和位置信息，通常这一行为也被称为“自动重排”。</p><p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p><ul><li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；</li><li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）。</li></ul><p><img src="4.png" alt="1693400190162"></p><p>大致过程：</p><p><img src="5.jpeg" alt="1693400357976"></p><p><code>注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</code></p><h1 id="回流-重绘-合成"><a href="#回流-重绘-合成" class="headerlink" title="回流-重绘-合成"></a>回流-重绘-合成</h1><ol><li>回流</li></ol><p>另一个叫法是重排，回流触发的条件就是：对DOM结构的修改引发DOM几何尺寸的变化的时候，会发生回流过程。</p><p>具体有以下的操作会触发回流：</p><ul><li>一个DOM元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border等</li><li>使DOM节点发生增减或者移动</li><li>窗口resize（修改了窗口的尺寸等）</li><li>调用getComputedStyle方法获取尺寸、位置信息</li><li>读写offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li>调用window。getComputedStyle方法</li><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><ol start="2"><li>重绘</li></ol><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><p>根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。</p><p>具体有以下的操作会触发重绘：</p><p>比如修改背景色、文字颜色、边框颜色、样式等；</p><p><code>重绘不一定导致回流，但回流一定发生了重绘，所以回流是一很消耗性能的事情。</code></p><ol start="3"><li>composite合成</li></ol><p>还有一种情况：就是更改了一个既不要布局也不要绘制的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的合成操作，这个过程就叫合成。</p><p>举个例子：比如使用CSS的transform来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><p>默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的；而一些特殊的属性，会创建一个新的合成（CompositingLayer ），并且新的图层可以利用GPU来加速绘制，因为每个合成层都是单独渲染的。</p><p>常见可以形成新的合成层的属性：</p><ul><li>3D transforms</li><li>video、canvas、iframe</li><li>opacity 动画转换时</li><li>position: fixed</li><li>will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化</li><li>animation 或 transition 设置了opacity、transform</li></ul><h1 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h1><ol><li>针对JavaScript</li></ol><p>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p><ul><li>尽量将JavaScript文件放在body的最后</li><li>body中间尽量不要写 <code>&lt;script&gt;</code>标签</li><li><code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：<br>（1）script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面。<br>（2）async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序。<br>（3）defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li></ul><ol start="2"><li>针对CSS</li></ol><p>css要放在顶部，它不会阻塞html的解析</p><p>使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：</p><p>link：浏览器会派发一个新的线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</p><p>@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</p><p>style：GUI直接渲染</p><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在head中，让浏览器尽快发送请求去获取css样式。</p><p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p><p><strong>style样式解析</strong><br>style中的样式不解析完毕，页面不会渲染。</p><ul><li>由html解析器解析</li><li>不会阻塞浏览器渲染，但可能出现闪屏现象</li><li>不会阻塞DOM解析</li></ul><p>通过style标签引入会一般解析，一边渲染。</p><p><strong>link引入</strong></p><ul><li>link进来的样式，由css解析器去解析，并且是同步解析的。</li><li>css解析器会阻塞页面的渲染。(link引入的外部样式会阻塞页面渲染，可以利用这种阻塞避免”闪屏现象”)</li><li>推荐使用link引入样式。</li><li>阻塞后面的js语句的执行</li></ul><ol start="3"><li>针对DOM树、CSSOM树</li></ol><p>可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li></ul><ol start="4"><li>减少回流和重绘</li></ol><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用table布局， 一个小的改动可能会使整个table进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</li><li>浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列</li></ul><p>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p><p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><ol start="5"><li>defer和async属性</li></ol><p><strong>derfer</strong><br>defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree。</p><p>脚本会由浏览器来进行下载，但是不会阻塞DOM Tree的构建过程；如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码；另外多个带defer的脚本是可以保持正确的顺序执行的。 从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中；<br><code>注意：defer仅适用于外部脚本，对于script默认内容会被忽略</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">defer</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>async</strong><br>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。async是让一个脚本完全独立的：</p><p>浏览器不会因 async 脚本而阻塞（与 defer 类似），但async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本；async不能保证在DOMContentLoaded之前或者之后执行；</p><ul><li>defer通常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求的；</li><li>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/2023/08/13/typescript/"/>
      <url>/2023/08/13/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="TS简介"><a href="#TS简介" class="headerlink" title="TS简介"></a>TS简介</h2><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。它扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作。TypeScript 是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</p><h2 id="TypeScript-与-JavaScript-的区别"><a href="#TypeScript-与-JavaScript-的区别" class="headerlink" title="TypeScript 与 JavaScript 的区别"></a><strong>TypeScript 与 JavaScript 的区别</strong></h2><ol><li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法。</li><li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</li><li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js。</li><li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件。</li><li>TypeScript 在开发时就能给出编译错误，而 JavaScript 错误则需要在运行时才能暴露。作为强类型语言，你可以明确知道数据的类型，代码可读性极强。</li></ol><h2 id="安装使用-TypeScript"><a href="#安装使用-TypeScript" class="headerlink" title="安装使用 TypeScript"></a><strong>安装使用 TypeScript</strong></h2><p>打开终端 terminal 输入全局安装命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g typescript </span><br></pre></td></tr></table></figure><p>新建一个文件 index.ts，在终端输入 tsc index.ts 编译文件，编译成功则会生成一个同名的 js 文件。</p><h2 id="TypeScript数据类型"><a href="#TypeScript数据类型" class="headerlink" title="TypeScript数据类型"></a>TypeScript数据类型</h2><p>原始数据类型：</p><ul><li>boolean 布尔值</li><li>number 数值</li><li>string 字符串</li><li>null 空值</li><li>undefined 未定义</li><li>Symbol （ES6 中的新类型）</li></ul><p>非原始数据类型：</p><ul><li>数组</li><li>Tuple 元祖</li><li>enum 枚举</li><li>never 永不存在的值的类型</li><li>void</li><li>any 任意类型</li><li>联合类型</li><li>函数类型</li><li>对象类型</li></ul><p>其中元组、枚举、任意值、void 类型和 never 类型是 TypeScript 有别于 JavaScript 的特有类型。在 TypeScript 中声明变量，需要加上类型声明，例如 boolean 和 string 等。通过静态类型约束，在编译时执行类型检查，可以避免一些类型混用的低级错误。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">bo</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">0b1000</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">c</span>: <span class="built_in">number</span> = <span class="number">0o102</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>和 JavaScript 一样，可以使用双引号（ <code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串，还可以使用模板字符串。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">myName</span>: <span class="built_in">string</span> = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">myAge</span>: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>，可以用 <code>void</code> 表示没有任何返回值的函数。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unde</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">nu</span>: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;My name is Tom&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试把一个数字赋值给声明了 <code>void</code>类型的变量，这个时候就会给出错误提示。</p><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型，与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">nu</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">number</span> = un;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义数组有两种方式。</p><p><strong>第一种：普通方式。</strong></p><p>可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组，数组的项中不允许出现其他的类型：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p><strong>第二种:泛型方式 <code>Array&lt;元素类型&gt;</code>。</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;Hello&quot;</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">rat</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cattle</span>: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tiger</span>: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">rabbit</span>: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dragon</span>: <span class="built_in">number</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>上述只声明了 5 个，如果声明全排位，需要声明 12 个变量，并且注明类型，但是却多了很多重复性工作，利用数字枚举，我们可以轻松声明同样的一组常量。</p><p><strong>数字枚举</strong></p><p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ChineseZodiac</span> &#123;</span><br><span class="line">  rat,</span><br><span class="line">  cattle,</span><br><span class="line">  tiger,</span><br><span class="line">  rabbit,</span><br><span class="line">  dragon,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为js:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ChineseZodiac</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">ChineseZodiac</span>) &#123;</span><br><span class="line">    <span class="title class_">ChineseZodiac</span>[<span class="title class_">ChineseZodiac</span>[<span class="string">&quot;rat&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;rat&quot;</span>;</span><br><span class="line">    <span class="title class_">ChineseZodiac</span>[<span class="title class_">ChineseZodiac</span>[<span class="string">&quot;cattle&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;cattle&quot;</span>;</span><br><span class="line">    <span class="title class_">ChineseZodiac</span>[<span class="title class_">ChineseZodiac</span>[<span class="string">&quot;tiger&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line">    <span class="title class_">ChineseZodiac</span>[<span class="title class_">ChineseZodiac</span>[<span class="string">&quot;rabbit&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;rabbit&quot;</span>;</span><br><span class="line">    <span class="title class_">ChineseZodiac</span>[<span class="title class_">ChineseZodiac</span>[<span class="string">&quot;dragon&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;dragon&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">ChineseZodiac</span> || (<span class="title class_">ChineseZodiac</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p><strong>字符串枚举</strong></p><p>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;NAME&quot;</span>,</span><br><span class="line">  age = <span class="string">&quot;AGE&quot;</span>,</span><br><span class="line">  love = <span class="string">&quot;LOVE&quot;</span>,</span><br><span class="line">  hobby = <span class="string">&quot;HOBBY&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// NAME</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">hobby</span>); <span class="comment">// HOBBY</span></span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never 类型是任何类型的子类型，也可以赋值给任何类型，一般作为函数返回值。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="any-任意类型"><a href="#any-任意类型" class="headerlink" title="any 任意类型"></a>any 任意类型</h3><p>任意值（Any）用来表示允许赋值为任意类型。声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;这是字符串&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>当你不希望类型检查器对某些值进行检查而是直接让它们通过编译阶段的检查可以使用 any 类型来标记这些变量。</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">num = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">num = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。这里的 <code>let num: string | number</code> 的含义是，允许 <code>num</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">name</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">2</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;字符串&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。</p><p>语法格式：<code>&lt;类型&gt;值 或 值as类型</code></p><p><strong>方式一</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someAny</span>: <span class="built_in">any</span> = <span class="string">&quot;my name is tony&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someAny).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p><code>someAny</code> 作为 <code>any</code> 类型是不可以使用字符串方法的，所以这个时候我们可以使用类型断言对此进行转换。</p><p><strong>方式二</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someAny</span>: <span class="built_in">any</span> = <span class="string">&quot;my name is tony&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someAny <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><p>效果是一样的。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p><p><strong>接口的作用：</strong></p><ol><li>对类的一部分行为进行抽象（类的部分后续会讲到）</li><li>描述对象的形状</li></ol><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p><p><strong>注意：</strong></p><p>接口一般首字母大写，也可以在接口之前加大写 <code>I</code> ，赋值的时候，变量的形状必须和接口的形状保持一致。不允许添加未定义的属性。</p><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在属性后使用 <code>?</code> 表示这个属性是可选属性，可选属性的含义是该属性可以不存在，但是仍然不允许添加未定义的属性。</p><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式。使用 <code>[propName: string]</code> 定义任意属性取 <code>string</code> 类型的值。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性，如果使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，那么就会报错了。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承，而在 ES6 中，我们能够使用 <code>class</code>。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p><p>如果你有其他面向对象语言的经验，那么（Class） 类就是比较简单的常用的类型，如果你之前没有使用过，那么先介绍一下概念方便理解。</p><p><strong>类（Class）</strong></p><p>定义了一件事物的抽象特点，包含它的属性和方法。</p><p><strong>对象（Object）</strong></p><p>类的实例，通过 new 生成。</p><p><strong>面向对象（OOP）的三大特性</strong></p><p>封装、继承、多态。</p><p><strong>封装（Encapsulation）</strong></p><p>将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据。</p><p><strong>继承（Inheritance）</strong></p><p>子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性。</p><p><strong>多态（Polymorphism）</strong></p><p>由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 run 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 run 方法，程序会自动判断出来应该如何执行 run。</p><p><strong>存取器（getter &amp; setter）</strong></p><p>用以改变属性的读取和赋值行为。</p><p><strong>抽象类（Abstract Class）</strong></p><p>抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现。</p><p><strong>修饰符（Modifiers）</strong></p><p>修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法。</p><p><strong>接口（Interfaces）</strong></p><p>不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口。</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。类一般包括属性 + 方法。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">greeter.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数，实例化类的时候触发的方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;父亲&quot;</span>);</span><br><span class="line">p.<span class="title function_">run</span>(); <span class="comment">// 父亲在运动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name); <span class="comment">// 初始化父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;儿子&quot;</span>);</span><br><span class="line">c.<span class="title function_">run</span>(); <span class="comment">// 儿子在运动</span></span><br></pre></td></tr></table></figure><h3 id="类里面的修饰符"><a href="#类里面的修饰符" class="headerlink" title="类里面的修饰符"></a>类里面的修饰符</h3><p>Typescript 里面定义属性的时候给我们提供了三种修饰符：</p><ul><li>public：公有，在当前类里面、子类、类外面都可以访问。</li><li>protected：保护类型，在当前类里面、子类里面可以访问，在类外部没法访问。</li><li>private：私有，在当前类里面可以访问，子类、类外部都没法访问。</li></ul><p>注意：属性如果不加修饰符，默认就是公有（public）。</p><p><strong>public</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 公有</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>); <span class="comment">// 在类里能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">p.<span class="title function_">run</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// 在类外面能访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动--子类`</span>); <span class="comment">// 子类能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">c.<span class="title function_">run</span>(); <span class="comment">// 李四在运动--子类</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">name</span>); <span class="comment">// 在类外面能访问</span></span><br></pre></td></tr></table></figure><p><strong>protected</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 保护</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>); <span class="comment">// 在类里能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">p.<span class="title function_">run</span>();</span><br><span class="line"><span class="comment">// console.log(p.name); // 报错，在类外面不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动--子类`</span>); <span class="comment">// 子类能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">c.<span class="title function_">run</span>(); <span class="comment">// 李四在运动--子类</span></span><br><span class="line"><span class="comment">// console.log(c.name); // 报错，在类外面不能访问</span></span><br></pre></td></tr></table></figure><p><strong>private</strong></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 私有</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>); <span class="comment">// 在类里能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">p.<span class="title function_">run</span>();</span><br><span class="line"><span class="comment">// console.log(p.name); // 报错，在类外面不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(`$&#123;this.name&#125;在运动--子类`); // 报错，子类不能访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">c.<span class="title function_">run</span>(); <span class="comment">// 李四在运动--子类</span></span><br><span class="line"><span class="comment">// console.log(c.name); // 报错，在类外面不能访问</span></span><br></pre></td></tr></table></figure><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用，若加上修饰符，和其他属性和方法效果一样。</p><p>ES5 中的静态方法、静态属性：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">run1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 实例方法，实例化后调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">run2</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 静态方法，类名直接调用</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&quot;lucy&quot;</span>; <span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">run2</span>(); <span class="comment">// 静态方法的调用</span></span><br></pre></td></tr></table></figure><p>TypeScript 中的静态方法、静态属性：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">static</span> sex = <span class="string">&quot;男&quot;</span>; <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在工作`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;print静态方法&quot;</span> + <span class="title class_">Person</span>.<span class="property">sex</span>); <span class="comment">// 静态方法，没法直接调用类的属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">p.<span class="title function_">work</span>();</span><br><span class="line">p.<span class="title function_">run</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">sex</span>; <span class="comment">// 男</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p><p>什么是抽象类？</p><p>首先，抽象类是不允许被实例化的：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;tony&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候会报错。</p><p>其次，抽象类中的抽象方法必须被子类实现：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译会报错。</p><p>正确使用：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">cat.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 JavaScript 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 TypeScript 里，函数仍然是主要的定义行为的地方。 TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p><p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p><p>ES5 函数定义：函数声明、匿名函数、传参。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">456</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：<span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn3</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>TypeScript 函数定义：函数声明、匿名函数、传参。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// number 是函数返回值类型，没有返回值为 void</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有返回值&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">456</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：<span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn3</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p><strong>可选参数</strong></p><p>ES5 里面方法的实参和行参可以不一样，但是 TypeScript 中必须一样，如果不一样就需要配置可选参数。</p><p><strong>注意</strong> ：可选参数必须配置到参数的最后面。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// age 为可选参数</span></span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：保密`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&quot;李四&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>默认参数</strong></p><p>ES5 里面不能设置默认参数，ES6 和 TypeScript 中都可以设置默认参数。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span> = <span class="number">20</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// age 默认为20</span></span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：保密`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)); <span class="comment">// 姓名：张三，年龄：18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&quot;李四&quot;</span>)); <span class="comment">// 姓名：李四，年龄：20</span></span><br></pre></td></tr></table></figure><p><strong>剩余参数</strong></p><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line">  items.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    array.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">alert</span>(a);</span><br></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它，在 TypeScript 里，你可以把所有参数收集到一个变量里：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  items.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    array.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">alert</span>(a);</span><br></pre></td></tr></table></figure><p><strong>用接口定义函数的形状</strong></p><p>我们也可以使用接口的方式来定义一个函数需要符合的形状。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">//左边表示函数的输入类型，右边表示输出类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn</span>: <span class="title class_">Fn</span>;</span><br><span class="line">fn = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>函数重载</strong></p><p>JavaScript 中方法的重载：重载指的是两个或者两个以上同名函数，但它们的参数不一样，这时会出现函数重载的情况。</p><p>Typescript 中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的。</p><p>ES5 中出现同名方法，下面的会替换上面的方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name, age</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Typescript 中的重载：</p><ul><li>单个参数，不同类型。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">age: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">str: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`姓名：<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`年龄：<span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getInfo</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="title function_">getInfo</span>(<span class="number">18</span>);</span><br><span class="line"><span class="title function_">getInfo</span>(<span class="literal">true</span>); <span class="comment">// 错误的写法</span></span><br></pre></td></tr></table></figure><ul><li>多个参数，可选参数。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>，年龄：<span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`姓名：<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getInfo</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="title function_">getInfo</span>(<span class="number">18</span>); <span class="comment">// 错误</span></span><br><span class="line"><span class="title function_">getInfo</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>从 ECMAScript 2015 开始，JavaScript 引入了模块的概念。 TypeScript 也沿用这个概念。模块在其自身的作用域里执行，而不是在全局作用域里。这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你使用 export 导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你可以通过 import 导入它们。</p><p><strong>模块的导入与导出</strong></p><p>模块是自声明的。在 TypeScript 里，两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。下面是一个基本例子：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">show</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Animal</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">dog.<span class="property">name</span> = <span class="string">&quot;狗狗&quot;</span>;</span><br><span class="line">dog.<span class="title function_">show</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>上面的例子里，在 <code>a.ts</code> 里声明了一个类 Animal，通过 export 导出。在 <code>b.ts</code> 里，指定相对文件路径，通过 import 导入，就可以使用 Animal 类。</p><p><strong>导入和导出的重命名</strong></p><p>模块导入和导出时默认使用的内部对象的名称。TypeScript 也支持在导出前和导入后进行重命名。将上面的例子修改一下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.ts</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">show</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Animal</span> <span class="keyword">as</span> <span class="variable constant_">ANI</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">ANI</span> <span class="keyword">as</span> <span class="title class_">Animal</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">dog.<span class="property">name</span> = <span class="string">&quot;狗狗&quot;</span>;</span><br><span class="line">dog.<span class="title function_">show</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;重命名-狗狗&quot;</span>);</span><br></pre></td></tr></table></figure><p>导入和导出时，通过 <code>as</code> 关键字对模块进行重命名。这个地方有一点要注意，当导出的模块重命名后，导入时重命名前的模块名要与导出重命名后的模块名保持一致，否则编译器将提示错误信息。以上面的这个例子为例，导出的模块被重命名为 <code>ANI</code>，将此模块在另外一个文件 <code>b.ts</code>里导入时，<code>as</code> 关键字前面的模块名必须是 <code>ANI</code>。</p><p>如果不知道导入模块的名称，则可以用 <code>*</code> 号代替。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> animal_module <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> animal_module.<span class="title function_">ANI</span>();</span><br><span class="line">dog.<span class="property">name</span> = <span class="string">&quot;狗狗&quot;</span>;</span><br><span class="line">dog.<span class="title function_">show</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;重命名-狗狗-*&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>导入和导出多个对象</strong></p><p>通常情况，模块里会定义多个类型对象，然后一并导出。而导入的模块里也可能会有多个。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.ts</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="string">&quot;Red&quot;</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="string">&quot;Blue&quot;</span>,</span><br><span class="line">  <span class="title class_">White</span> = <span class="string">&quot;White&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">color</span>: <span class="title class_">Color</span>;</span><br><span class="line">  <span class="title function_">show</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Animal</span>, <span class="title class_">Color</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> animal_module <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> animal_module.<span class="title class_">Animal</span>();</span><br><span class="line">dog.<span class="property">name</span> = <span class="string">&quot;狗狗&quot;</span>;</span><br><span class="line">dog.<span class="property">color</span> = animal_module.<span class="property">Color</span>.<span class="property">Red</span>;</span><br><span class="line">dog.<span class="title function_">show</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span> + dog.<span class="property">color</span>);</span><br></pre></td></tr></table></figure><p><strong>默认导出</strong></p><p>对于导出内容的命名无关紧要，只要给定名称即可，但默认导出只有一个。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.ts</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">show</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Animal</span>;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Animal</span> <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">dog.<span class="property">name</span> = <span class="string">&quot;狗狗&quot;</span>;</span><br><span class="line">dog.<span class="title function_">show</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2023/06/02/MongoDB/"/>
      <url>/2023/06/02/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Mongodb-是什么"><a href="#Mongodb-是什么" class="headerlink" title="Mongodb 是什么"></a>Mongodb 是什么</h3><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库，官方地址 <a href="https://www.mongodb.com/">https://www.mongodb.com/</a></p></blockquote><h3 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h3><p>数据库（DataBase）是按照数据结构来组织、存储和管理数据的 <code>应用程序</code></p><h3 id="数据库的作用"><a href="#数据库的作用" class="headerlink" title="数据库的作用"></a>数据库的作用</h3><p>数据库的主要作用就是 <code>管理数据</code>，对数据进行 <code>增（c）、删（d）、改（u）、查（r）</code></p><h3 id="数据库管理数据的特点"><a href="#数据库管理数据的特点" class="headerlink" title="数据库管理数据的特点"></a>数据库管理数据的特点</h3><p>相比于纯文件管理数据，数据库管理数据有如下特点：</p><ol><li>速度更快</li><li>扩展性更强</li><li>安全性更强</li></ol><h3 id="为什么选择-Mongodb"><a href="#为什么选择-Mongodb" class="headerlink" title="为什么选择 Mongodb"></a>为什么选择 Mongodb</h3><p>操作语法与 JavaScript 类似，容易上手，学习成本低</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Mongodb 中有三个重要概念需要掌握</p><ul><li>数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合</li><li>集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档</li><li>文档（document）   文档是数据库中的最小单位，类似于 JS 中的对象</li></ul><img src="./assets/f9e871ef89956cc15ef0e89aa7ac8e7839da10d6.jpg" alt="09_mongodb" style="zoom: 67%;" /><p>JSON 文件示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;accounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3-YLju5f3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;买电脑&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-02-08&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5500&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;remarks&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为了上网课&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3-YLju5f4&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请女朋友吃饭&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-02-08&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;214&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remarks&quot;</span><span class="punctuation">:</span> <span class="string">&quot;情人节聚餐&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mRQiD4s3K&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;发工资&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-02-19&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4396&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remarks&quot;</span><span class="punctuation">:</span> <span class="string">&quot;终于发工资啦!~~&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lisi&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wangwu&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">22</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>大家可以通过 JSON 文件来理解 Mongodb 中的概念</p><ul><li>一个 <code>JSON 文件</code> 好比是一个 <code>数据库</code>，一个 Mongodb 服务下可以有 N 个数据库</li><li>JSON 文件中的 <code>一级属性的数组值</code> 好比是 <code>集合</code></li><li>数组中的对象好比是 <code>文档</code></li><li>对象中的属性有时也称之为 <code>字段</code></li></ul><blockquote><p>一般情况下</p><ul><li>一个项目使用一个数据库</li><li>一个集合会存储同一种类型的数据</li></ul></blockquote><h2 id="下载安装与启动"><a href="#下载安装与启动" class="headerlink" title="下载安装与启动"></a>下载安装与启动</h2><p>下载地址： <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>建议选择 <code>zip</code> 类型， 通用性更强</p><p>配置步骤如下:</p><pre><code>1&gt; 将压缩包移动到`C:\Program Files` 下，然后解压2&gt; 创建`C:\data\db` 目录，mongodb 会将数据默认保存在这个文件夹3&gt; 以 mongodb 中 bin 目录作为工作目录，启动命令行4&gt; 运行命令`mongod`</code></pre><p><img src="./assets/e036cbab1d55c5ade9389e3f7a4664847803cecf.jpg" alt="09_mongodb"></p><p>看到最后的 <code>waiting for connections</code> 则表明服务 <code>已经启动成功</code></p><p>然后可以使用 <code>mongo</code> 命令连接本机的 mongodb 服务</p><p><img src="./assets/06fcfe57e7ec2be01971894e0fb15bb14e3dfec0.jpg" alt="09_mongodb"></p><blockquote><p>注意：</p><ul><li>为了方便后续方便使用 mongod 命令，可以将 bin 目录配置到环境变量 Path 中</li><li><code>千万不要选中服务端窗口的内容</code>，选中会停止服务，可以 <code>敲回车</code> 取消选中</li></ul></blockquote><p>配置windows服务: <a href="https://www.shuzhiduo.com/A/E35pAE6Ydv/">https://www.shuzhiduo.com/A/E35pAE6Ydv/</a></p><p>修改 <code>mongodb</code>数据库位置</p><p><img src="./assets/image-20230327010148369.png" alt="image-20230327010148369"></p><h2 id="命令行交互"><a href="#命令行交互" class="headerlink" title="命令行交互"></a>命令行交互</h2><p>命令行交互一般是学习数据库的第一步，不过这些命令在后续用的比较少，所以大家了解即可</p><h3 id="数据库命令"><a href="#数据库命令" class="headerlink" title="数据库命令"></a>数据库命令</h3><ol><li><p>显示所有的数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> dbs</span><br></pre></td></tr></table></figure></li><li><p>切换到指定的数据库，如果数据库不存在会自动创建数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure></li><li><p>显示当前所在的数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure></li><li><p>删除当前数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 库名</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></li></ol><h3 id="集合命令"><a href="#集合命令" class="headerlink" title="集合命令"></a>集合命令</h3><ol><li><p>创建集合</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.createCollection(<span class="string">&#x27;集合名称&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>显示当前数据库中的所有集合</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> collections</span><br></pre></td></tr></table></figure></li><li><p>删除某个集合</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.集合名.<span class="keyword">drop</span>()</span><br></pre></td></tr></table></figure></li><li><p>重命名集合</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.集合名.renameCollection(<span class="string">&#x27;newName&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="文档命令"><a href="#文档命令" class="headerlink" title="文档命令"></a>文档命令</h3><ol><li><p>插入文档</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.集合名.<span class="keyword">insert</span>(文档对象);</span><br></pre></td></tr></table></figure></li><li><p>查询文档</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.集合名.<span class="title function_">find</span>(查询条件)</span><br></pre></td></tr></table></figure><p><code>&lt;span style=&quot;color:red&quot;&gt;</code>_id 是 mongodb 自动生成的唯一编号，用来唯一标识文档</p></li><li><p>更新文档</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.集合名.<span class="keyword">update</span>(查询条件,新的文档)</span><br><span class="line">db.集合名.<span class="keyword">update</span>(&#123;name:<span class="string">&#x27;张三&#x27;</span>&#125;,&#123;$<span class="keyword">set</span>:&#123;age:<span class="number">19</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>删除文档</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.集合名.remove(查询条件)</span><br></pre></td></tr></table></figure></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><ul><li>用户注册</li><li>发布视频</li><li>发布商品</li><li>发朋友圈</li><li>发评论</li><li>发微博</li><li>发弹幕</li><li>…….</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除评论</li><li>删除商品</li><li>删除文章</li><li>删除视频</li><li>删除微博</li><li>……</li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li>更新个人信息</li><li>修改商品价格</li><li>修改文章内容</li><li>……</li></ul><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li>商品列表</li><li>视频列表</li><li>朋友圈列表</li><li>微博列表</li><li>搜索功能</li><li>……</li></ul><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> Mongoose 是一个对象文档模型库，官网 <a href="http://www.mongoosejs.net/">http://www.mongoosejs.net/</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>方便使用代码操作 mongodb 数据库</p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1. 安装 mongoose</span></span><br><span class="line"> <span class="comment">//2. 导入 mongoose</span></span><br><span class="line"> <span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3. 连接数据库                              数据库名称</span></span><br><span class="line"> mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://127.0.0.1:27017/bilibili&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4. 设置连接回调</span></span><br><span class="line"> <span class="comment">//连接成功   once 一次   事件回调函数只执行一次</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接成功&#x27;</span>);</span><br><span class="line"> <span class="comment">//5. 创建文档结构对象</span></span><br><span class="line">    <span class="comment">// 设置集合中 文档的属性以及属性值得类型</span></span><br><span class="line"> <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="title class_">String</span>,</span><br><span class="line"> <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line"> <span class="attr">price</span>: <span class="title class_">Number</span></span><br><span class="line"> &#125;);</span><br><span class="line">   </span><br><span class="line"> <span class="comment">//6. 创建文档模型对象  对文档操作的封装对象  mongoose会使用集合名称的复数，创建集合</span></span><br><span class="line"> <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;book&#x27;</span>, <span class="title class_">BookSchema</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//7. 插入文档</span></span><br><span class="line"> <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line"> <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,</span><br><span class="line"><span class="attr">price</span>: <span class="number">19.9</span></span><br><span class="line"> &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否有错误</span></span><br><span class="line"> <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="comment">//输出 data 对象  如果没有出错，则输出插入后的文档对象</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line"> <span class="comment">//8. 断开连接  关闭数据链接 (项目运行过程中，不会添加该代码)</span></span><br><span class="line"> mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接出错</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接出错~~&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接关闭&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>文档结构可选的常用字段类型列表</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>字符串</td></tr><tr><td>Number</td><td>数字</td></tr><tr><td>Boolean</td><td>布尔值</td></tr><tr><td>Array</td><td>数组，也可以使用 <code>[]</code> 来标识</td></tr><tr><td>Date</td><td>日期</td></tr><tr><td>Buffer</td><td>Buffer 对象</td></tr><tr><td>Mixed</td><td>任意类型，需要使用 <code>mongoose.Schema.Types.Mixed</code> 指定</td></tr><tr><td>ObjectId</td><td>对象 ID，需要使用 <code>mongoose.Schema.Types.ObjectId</code> 指定</td></tr><tr><td>Decimal128</td><td>高精度数字，需要使用 <code>mongoose.Schema.Types.Decimal128</code> 指定</td></tr></tbody></table><h3 id="字段值验证"><a href="#字段值验证" class="headerlink" title="字段值验证"></a>字段值验证</h3><p>Mongoose 有一些内建验证器，可以对字段值进行验证</p><h4 id="必填项"><a href="#必填项" class="headerlink" title="必填项"></a>必填项</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">title</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"> <span class="attr">required</span>: <span class="literal">true</span> <span class="comment">// 设置必填项</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">author</span>: &#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"> <span class="attr">default</span>: <span class="string">&#x27;匿名&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">gender</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">enum</span>: [<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>] <span class="comment">//设置的值必须是数组中的</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="唯一值"><a href="#唯一值" class="headerlink" title="唯一值"></a>唯一值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"> <span class="attr">unique</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>unique 需要 <code>重建集合</code> 才能有效果</p><p>永远不要相信用户的输入</p></blockquote><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><p>数据库的基本操作包括四个，增加（create），删除（delete），修改（update），查（read）</p><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>插入一条</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">title</span>:<span class="string">&#x27;给我一首歌的时间&#x27;</span>,</span><br><span class="line"> <span class="attr">author</span>: <span class="string">&#x27;Jay&#x27;</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line"><span class="comment">//插入后的数据对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>批量插入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.引入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.链接mongodb数据库 connect 连接</span></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://127.0.0.1:27017/project&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设置连接的回调</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//4.声明文档结构</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PhoneSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line"><span class="attr">brand</span>:<span class="title class_">String</span>,</span><br><span class="line"><span class="attr">color</span>:<span class="title class_">String</span>,</span><br><span class="line"><span class="attr">price</span>:<span class="title class_">Number</span>,</span><br><span class="line"> <span class="attr">tags</span>:<span class="title class_">Array</span></span><br><span class="line">&#125;)</span><br><span class="line"> <span class="comment">//6.创建模型对象</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title class_">PhoneModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;phone&#x27;</span>,<span class="title class_">PhoneSchema</span>);</span><br><span class="line"> <span class="title class_">PhoneModel</span>.<span class="title function_">insertMany</span>([</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">brand</span>:<span class="string">&#x27;华为&#x27;</span>,</span><br><span class="line"> <span class="attr">color</span>:<span class="string">&#x27;灰色&#x27;</span>,</span><br><span class="line"> <span class="attr">price</span>:<span class="number">2399</span>,</span><br><span class="line"> <span class="attr">tags</span>:[<span class="string">&#x27;电量大&#x27;</span>,<span class="string">&#x27;屏幕大&#x27;</span>,<span class="string">&#x27;信号好&#x27;</span>]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">brand</span>:<span class="string">&#x27;小米&#x27;</span>,</span><br><span class="line"> <span class="attr">color</span>:<span class="string">&#x27;白色&#x27;</span>,</span><br><span class="line"> <span class="attr">price</span>:<span class="number">2099</span>,</span><br><span class="line"> <span class="attr">tags</span>:[<span class="string">&#x27;电量大&#x27;</span>,<span class="string">&#x27;屏幕大&#x27;</span>,<span class="string">&#x27;信号好&#x27;</span>]</span><br><span class="line">         &#125;</span><br><span class="line">],<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">         mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除一条数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">deleteOne</span>(&#123;<span class="attr">_id</span>:<span class="string">&#x27;5dd65f32be6401035cb5b1ed&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"> <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>批量删除</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">deleteMany</span>(&#123;<span class="attr">author</span>:<span class="string">&#x27;Jay&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"> <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>更新一条数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">updateOne</span>(&#123;<span class="attr">author</span>: <span class="string">&#x27;JJ Lin&#x27;</span>&#125;, &#123;<span class="attr">author</span>: <span class="string">&#x27;林俊杰&#x27;</span>&#125;, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>批量更新数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">updateMany</span>(&#123;<span class="attr">author</span>: <span class="string">&#x27;Leehom Wang&#x27;</span>&#125;, &#123;<span class="attr">author</span>: <span class="string">&#x27;王力宏&#x27;</span>&#125;, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>查询一条数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">author</span>: <span class="string">&#x27;王力宏&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//根据 id 查询数据</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">findById</span>(<span class="string">&#x27;5dd662b5381fc316b44ce167&#x27;</span>,<span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>批量查询数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不加条件查询</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//加条件查询</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">find</span>(&#123;<span class="attr">author</span>: <span class="string">&#x27;王力宏&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>在 mongodb 不能 &gt; &lt; &gt;= &lt;= !== 等运算符，需要使用替代符号</p><ul><li><code>&gt;</code>使用 <code>$gt</code></li><li><code>&lt;</code> 使用 <code>$lt</code></li><li><code>=</code> 使用 <code>$gte</code></li><li><code>&lt;=</code> 使用 <code>$lte</code></li><li><code>!==</code> 使用 <code>$ne</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="property">students</span>.<span class="title function_">find</span>(&#123;<span class="attr">id</span>:&#123;<span class="attr">$gt</span>:<span class="number">3</span>&#125;&#125;); id号比<span class="number">3</span>大的所有的记录</span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格小于 20 的图书</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123; <span class="attr">price</span>: &#123; <span class="attr">$lt</span>: <span class="number">20</span> &#125; &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p><code>$or</code> 逻辑或的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="property">students</span>.<span class="title function_">find</span>(&#123;<span class="attr">$or</span>:[&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">24</span>&#125;]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曹雪芹 或者 余华的书</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123; <span class="attr">$or</span>: [&#123; <span class="attr">author</span>: <span class="string">&#x27;曹雪芹&#x27;</span> &#125;, &#123; <span class="attr">author</span>: <span class="string">&#x27;余华&#x27;</span> &#125;] &#125;, <span class="function">(<span class="params">err, data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>$and</code> 逻辑与的情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="property">students</span>.<span class="title function_">find</span>(&#123;<span class="attr">$and</span>: [&#123;<span class="attr">age</span>: &#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;, &#123;<span class="attr">age</span>: &#123;<span class="attr">$gt</span>: <span class="number">15</span>&#125;&#125;]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格大于 30 且 小于 70</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123; <span class="attr">$and</span>: [&#123; <span class="attr">price</span>: &#123; <span class="attr">$gt</span>: <span class="number">30</span> &#125; &#125;, &#123; <span class="attr">price</span>: &#123; <span class="attr">$lt</span>: <span class="number">70</span> &#125; &#125;] &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="property">students</span>.<span class="title function_">find</span>(&#123;<span class="attr">name</span>:<span class="regexp">/imissyou/</span>&#125;);</span><br><span class="line"></span><br><span class="line">正则表达式，搜索书籍名称中带有 <span class="string">&#x27;三&#x27;</span> 的图书</span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123; <span class="attr">name</span>: <span class="regexp">/三/</span> &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123; <span class="attr">name</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;三&#x27;</span>) &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="个性化读取"><a href="#个性化读取" class="headerlink" title="个性化读取"></a>个性化读取</h3><h4 id="字段筛选"><a href="#字段筛选" class="headerlink" title="字段筛选"></a>字段筛选</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0:不要的字段</span></span><br><span class="line"><span class="comment">//1:要的字段</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;<span class="attr">_id</span>:<span class="number">0</span>,<span class="attr">title</span>:<span class="number">1</span>&#125;).<span class="title function_">exec</span>(<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort 排序</span></span><br><span class="line"><span class="comment">// 1:升序</span></span><br><span class="line"><span class="comment">// -1:倒序</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">find</span>().<span class="title function_">sort</span>(&#123;<span class="attr">hot</span>:<span class="number">1</span>&#125;).<span class="title function_">exec</span>(<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数据截取"><a href="#数据截取" class="headerlink" title="数据截取"></a>数据截取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//skip 跳过   limit 限定</span></span><br><span class="line"><span class="title class_">SongModel</span>.<span class="title function_">find</span>().<span class="title function_">skip</span>(<span class="number">10</span>).<span class="title function_">limit</span>(<span class="number">10</span>).<span class="title function_">exec</span>(<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="图形化管理工具"><a href="#图形化管理工具" class="headerlink" title="图形化管理工具"></a>图形化管理工具</h2><p>我们可以使用图形化的管理工具来对 Mongodb 进行交互，这里演示两个图形化工具</p><ul><li>Robo 3T 免费 <a href="https://github.com/Studio3T/robomongo/releases">https://github.com/Studio3T/robomongo/releases</a></li><li>Navicat 收费 <a href="https://www.navicat.com.cn/">https://www.navicat.com.cn/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express框架</title>
      <link href="/2023/06/02/express%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/06/02/express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="express-介绍"><a href="#express-介绍" class="headerlink" title="express 介绍"></a>express 介绍</h2><blockquote><p>express 是一个基于 Node.js 平台的极简、灵活的 WEB 应用开发框架，官方网址： <a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></p></blockquote><p>简单来说，express 是一个封装好的工具包，封装了很多功能，便于我们开发 WEB 应用(HTTP 服务)</p><h2 id="express-使用"><a href="#express-使用" class="headerlink" title="express 使用"></a>express 使用</h2><h3 id="express-下载"><a href="#express-下载" class="headerlink" title="express 下载"></a>express 下载</h3><p>express 本身是一个 npm 包，所以可以通过 npm 安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm i express</span><br></pre></td></tr></table></figure><h3 id="express-初体验"><a href="#express-初体验" class="headerlink" title="express 初体验"></a>express 初体验</h3><p>大家可以按照这个步骤进行操作：</p><ol><li>创建 JS 文件，键入如下代码</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">end</span>(<span class="string">&#x27;hello express server&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//4. 监听端口 启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动, 端口监听为 3000...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>命令行下执行该脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. node &lt;文件名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">nodemon &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li><li><p>然后在浏览器就可以访问 <a href="http://127.0.0.1:3000/home">http://127.0.0.1:3000/home</a> 👌</p></li></ol><h2 id="express-路由"><a href="#express-路由" class="headerlink" title="express 路由"></a>express 路由</h2><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><blockquote><p>官方定义： <code>&lt;span style=&quot;color:red&quot;&gt;</code>路由确定了应用程序如何响应客户端对特定端点的请求</p></blockquote><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>一个路由的组成有 <code>请求方法</code>， <code>路径</code> 和 <code>回调函数</code> 组成</p><p>express 中提供了一系列方法，可以很方便的使用路由，使用格式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.&lt;method&gt;(path，callback)</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 get 路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;网站首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首页路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;我才是真正的首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 post 路由</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有的请求方法</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/search&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;1 秒钟为您找到相关结果约 100,000,000 个&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义 404 路由</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口 启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动, 端口监听为 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><p>express 框架封装了一些 API 来方便获取请求报文中的数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取请求的路由规则</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. 获取报文的方式与原生 HTTP 获取方式是兼容的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">method</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">url</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">httpVersion</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. express 独有的获取报文的方式</span></span><br><span class="line">    <span class="comment">// 获取路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">path</span>)</span><br><span class="line">    <span class="comment">//获取查询字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>); <span class="comment">// 『相对重要』对象形式返回所有的查询字符串</span></span><br><span class="line"><span class="comment">// 获取指定的请求头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="title function_">get</span>(<span class="string">&#x27;host&#x27;</span>));</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;请求报文的获取&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动成功....&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取路由参数"><a href="#获取路由参数" class="headerlink" title="获取路由参数"></a>获取路由参数</h3><p>路由参数指的是 <code>&lt;span style=&quot;color:red&quot;&gt;</code>URL 路径中的参数（数据）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/:id.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;商品详情, 商品 id 为&#x27;</span> + req.<span class="property">params</span>.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="express-响应设置"><a href="#express-响应设置" class="headerlink" title="express 响应设置"></a>express 响应设置</h2><p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求的路由规则</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/response&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1. express 中设置响应的方式兼容 HTTP 模块的方式</span></span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">  res.<span class="property">statusMessage</span> = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;xyz&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;响应体&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2. express 的响应方法</span></span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">500</span>); <span class="comment">//设置响应状态码</span></span><br><span class="line">  res.<span class="title function_">set</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="string">&#x27;yyy&#x27;</span>);<span class="comment">//设置响应头</span></span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;中文响应不乱码&#x27;</span>);<span class="comment">//设置响应体</span></span><br><span class="line">  <span class="comment">//连贯操作</span></span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">set</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="string">&#x27;yyy&#x27;</span>).<span class="title function_">send</span>(<span class="string">&#x27;你好朋友&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//3. 其他响应</span></span><br><span class="line">  res.<span class="title function_">redirect</span>(<span class="string">&#x27;http://atguigu.com&#x27;</span>)<span class="comment">//重定向</span></span><br><span class="line">  res.<span class="title function_">download</span>(<span class="string">&#x27;./package.json&#x27;</span>);<span class="comment">//下载响应</span></span><br><span class="line">  res.<span class="title function_">json</span>();<span class="comment">//响应 JSON</span></span><br><span class="line">  res.<span class="title function_">sendFile</span>(__dirname + <span class="string">&#x27;/home.html&#x27;</span>) <span class="comment">//响应文件内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="express-中间件"><a href="#express-中间件" class="headerlink" title="express 中间件"></a>express 中间件</h2><h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p><code>中间件（Middleware）本质是一个回调函数</code></p><p><code>中间件函数</code> 可以像路由回调一样访问 <code>请求对象（request）</code> ， <code>响应对象（response）</code></p><h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><p><code>中间件的作用</code> 就是 <code>使用函数封装公共操作，简化代码</code></p><h3 id="中间件的类型"><a href="#中间件的类型" class="headerlink" title="中间件的类型"></a>中间件的类型</h3><p>  全局中间件<br>  路由中间件</p><h4 id="定义全局中间件"><a href="#定义全局中间件" class="headerlink" title="定义全局中间件"></a>定义全局中间件</h4><p><code>每一个请求</code> 到达服务端之后 <code>都会执行全局中间件函数</code></p><p>声明中间件函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> recordMiddleware = <span class="keyword">function</span>(<span class="params">request,response,next</span>)&#123;</span><br><span class="line">  <span class="comment">//实现功能代码</span></span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">  <span class="comment">//执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next)</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./assets/34b8a3daffba5b366afb6495e4808b12de732403.jpg" alt="08_express框架"></p><p>应用中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(recordMiddleware)</span><br></pre></td></tr></table></figure><p>声明时可以直接将匿名函数传递给 <code>use</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">request, response, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义第一个中间件&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="多个全局中间件"><a href="#多个全局中间件" class="headerlink" title="多个全局中间件"></a>多个全局中间件</h4><p>express 允许使用 app.use() 定义多个全局中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">request, response, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义第一个中间件&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">request, response, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义第二个中间件&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="定义路由中间件"><a href="#定义路由中间件" class="headerlink" title="定义路由中间件"></a>定义路由中间件</h4><p>如果 <code>&lt;span style=&quot;color:red&quot;&gt;</code>只需要对某一些路由进行功能封装，则就需要路由中间件</p><p>调用格式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/路径&#x27;</span>,<span class="string">`中间件函数`</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/路径&#x27;</span>,<span class="string">`中间件函数1`</span>,<span class="string">`中间件函数2`</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态资源中间件"><a href="#静态资源中间件" class="headerlink" title="静态资源中间件"></a>静态资源中间件</h3><p>express 内置处理静态资源的中间件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>)); <span class="comment">//当然这个目录中都是一些静态资源</span></span><br><span class="line"><span class="comment">//如果访问的内容经常变化，还是需要设置路由</span></span><br><span class="line"><span class="comment">//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由</span></span><br><span class="line"><span class="comment">//则谁书写在前，优先执行谁</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/index.html&#x27;</span>,<span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line">respsonse.<span class="title function_">send</span>(<span class="string">&#x27;首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3000 端口启动....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ol><li>index.html 文件为默认打开的资源</li><li>如果静态资源与路由规则同时匹配，谁先匹配谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ol></blockquote><h3 id="获取请求体数据-body-parser"><a href="#获取请求体数据-body-parser" class="headerlink" title="获取请求体数据 body-parser"></a>获取请求体数据 body-parser</h3><p>express 可以使用 <code>body-parser</code> 包处理请求体</p><p>第一步：安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i body-parser</span><br></pre></td></tr></table></figure><p>第二步：导入 body-parser 包</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br></pre></td></tr></table></figure><p>第三步：获取中间件函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理 querystring 格式的请求体</span></span><br><span class="line"><span class="keyword">let</span> urlParser = bodyParser.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;));</span><br><span class="line"><span class="comment">//处理 JSON 格式的请求体</span></span><br><span class="line"><span class="keyword">let</span> jsonParser = bodyParser.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure><p>第四步：设置路由中间件，然后使用 <code>request.body</code> 来获取请求体数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, urlParser, <span class="function">(<span class="params">request,response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//获取请求体数据</span></span><br><span class="line"><span class="comment">//console.log(request.body);</span></span><br><span class="line"><span class="comment">//用户名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">body</span>.<span class="property">username</span>);</span><br><span class="line"> <span class="comment">//密码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">body</span>.<span class="property">userpass</span>);</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;获取请求体数据&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取到的请求体数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>, <span class="attr">userpass</span>: <span class="string">&#x27;123456&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 现在你已经可以抛弃 body-parser 模块，因为 Express 自从 4.16.0 版本开始，内置了 body 解析</p><p><strong>使用方法:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 解析 JSON 格式的请求体的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"><span class="comment">// 解析 querystring 格式请求体的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><h3 id="什么是-Router"><a href="#什么是-Router" class="headerlink" title="什么是 Router"></a>什么是 Router</h3><p>express 中的 Router 是一个完整的中间件和路由系统，可以看做是一个小型的 app 对象。</p><h3 id="Router-作用"><a href="#Router-作用" class="headerlink" title="Router 作用"></a>Router 作用</h3><p>对路由进行模块化，更好的管理路由</p><h3 id="Router-使用"><a href="#Router-使用" class="headerlink" title="Router 使用"></a>Router 使用</h3><p>创建独立的 JS 文件（homeRouter.js）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建路由器对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 在 router 对象身上添加路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;首页&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/cart&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">send</span>(<span class="string">&#x27;购物车&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 暴露</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p>主文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//5.引入子路由文件</span></span><br><span class="line"><span class="keyword">const</span> homeRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/homeRouter&#x27;</span>);</span><br><span class="line"><span class="comment">//6.设置和使用中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(homeRouter);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3000 端口启动....&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="EJS-模板引擎"><a href="#EJS-模板引擎" class="headerlink" title="EJS 模板引擎"></a>EJS 模板引擎</h2><h3 id="什么是模板引擎"><a href="#什么是模板引擎" class="headerlink" title="什么是模板引擎"></a>什么是模板引擎</h3><p>模板引擎是分离 <code>&lt;span style=&quot;color:red&quot;&gt;</code>用户界面和业务数据 的一种技术</p><h3 id="什么是-EJS"><a href="#什么是-EJS" class="headerlink" title="什么是 EJS"></a>什么是 EJS</h3><p>EJS 是一个高效的 Javascript 的模板引擎<br>官网: <a href="https://ejs.co/">https://ejs.co/</a><br>中文站： <a href="https://ejs.bootcss.com/">https://ejs.bootcss.com/</a></p><h3 id="EJS-初体验"><a href="#EJS-初体验" class="headerlink" title="EJS 初体验"></a>EJS 初体验</h3><p>下载安装EJS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i ejs --save</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.引入ejs</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"><span class="comment">//2.定义数据</span></span><br><span class="line"><span class="keyword">let</span> person = [<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王二麻子&#x27;</span>];</span><br><span class="line"><span class="comment">//3.ejs解析模板返回结构</span></span><br><span class="line"><span class="comment">//&lt;%= %&gt; 是ejs解析内容的标记，作用是输出当前表达式的执行结构</span></span><br><span class="line"><span class="comment">//&quot;&lt;%= %&gt;&quot;可以直接输出变量或表达式的值，变量或表达式的值将作为一个字符串在浏览器中输出。</span></span><br><span class="line"><span class="keyword">let</span> html = ejs.<span class="title function_">render</span>(‘&lt;%= person.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>) %&gt;’, &#123;<span class="attr">person</span>:person&#125;);</span><br><span class="line"><span class="comment">//4.输出结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html);</span><br></pre></td></tr></table></figure><p>命令行下运行</p><h3 id="EJS-常用语法"><a href="#EJS-常用语法" class="headerlink" title="EJS 常用语法"></a>EJS 常用语法</h3><p>执行JS代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% code %&gt;</span><br></pre></td></tr></table></figure><p>输出转义的数据到模板上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;%= code %&gt;</span><br></pre></td></tr></table></figure><p>输出非转义的数据到模板上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;%- code %&gt;</span><br></pre></td></tr></table></figure><h3 id="在express中使用ejs"><a href="#在express中使用ejs" class="headerlink" title="在express中使用ejs"></a>在express中使用ejs</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 1. 设置模板引擎</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>)  <span class="comment">// pug  twing</span></span><br><span class="line"><span class="comment">// 2. 设置模板文件的存放位置</span></span><br><span class="line"><span class="comment">// 模板文件: 具有模板语法内容的文件</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./views&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 3. render 响应</span></span><br><span class="line">  <span class="comment">// res.render(&#x27;模板的文件名&#x27;,&#x27;数据&#x27;)</span></span><br><span class="line">  <span class="keyword">let</span> title = <span class="string">&#x27;尚硅谷 - 让天下没有难学的技术&#x27;</span></span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;home&#x27;</span>, &#123; title &#125;)</span><br><span class="line">  <span class="comment">// 4. 创建模板文件</span></span><br><span class="line">  <span class="comment">// 如下面文件 views/home.ejs</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器已启动~~~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>views/home.ejs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h2&gt;</span><br><span class="line">    &lt;%=title %&gt;</span><br><span class="line">  &lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话控制</title>
      <link href="/2023/06/02/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/06/02/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>所谓会话控制就是 <code>&lt;span style=&quot;color:red&quot;&gt;</code>对会话进行控制</p></blockquote><p>HTTP 是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端，<code>&lt;span style=&quot;color:red&quot;&gt;</code>无法区分用户</p><p>而产品中又大量存在的这样的需求，所以我们需要通过 <code>&lt;span style=&quot;color:red&quot;&gt;</code>会话控制 来解决该问题</p><p>常见的会话控制技术有三种：</p><ul><li>cookie</li><li>session</li><li>token</li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="cookie-是什么"><a href="#cookie-是什么" class="headerlink" title="cookie 是什么"></a>cookie 是什么</h3><blockquote><p>cookie 是 HTTP 服务器发送到用户浏览器并保存在本地的一小块数据</p></blockquote><p><code>&lt;span style=&quot;color:red&quot;&gt;</code>cookie 是保存在浏览器端的一小块数据</p><p><code>&lt;span style=&quot;color:red&quot;&gt;</code>cookie 是按照域名划分保存的</p><p>简单示例：</p><table><thead><tr><th>域名</th><th>cookie</th></tr></thead><tbody><tr><td><a href="http://www.baidu.com/">www.baidu.com</a></td><td>a=100; b=200</td></tr><tr><td><a href="http://www.bilibili.com/">www.bilibili.com</a></td><td>xid=1020abce121; hm=112411213</td></tr><tr><td>jd.com</td><td>x=100; ocw=12414cce</td></tr></tbody></table><h3 id="cookie-的特点"><a href="#cookie-的特点" class="headerlink" title="cookie 的特点"></a>cookie 的特点</h3><p>浏览器向服务器发送请求时，会自动将 <code>当前域名下</code> 可用的 cookie 设置在请求头中，然后传递给服务器</p><p><img src="./assets/2432689d3a6913a8952b0e2f7c13b6aa468fe9ce.jpg" alt="11_会话控制"></p><p>这个请求头的名字也叫 <code>cookie</code> ，所以将 <code>&lt;span style=&quot;color:red&quot;&gt;</code>cookie 理解为一个 HTTP 的请求头也是可以的</p><h3 id="cookie-的运行流程"><a href="#cookie-的运行流程" class="headerlink" title="cookie 的运行流程"></a>cookie 的运行流程</h3><p>填写账号和密码校验身份，校验通过后下发 cookie</p><p><img src="./assets/f65d061b87c7b44dbddc1e9703146f9e03482aea.png" alt="image-20230327214116490"><br>有了 cookie 之后，后续向服务器发送请求时，就会自动携带 cookie</p><p><img src="./assets/82caab8f82650a12b76b9085e3d7b5c44a725ee8.png" alt="image-20230327214554199"></p><h3 id="浏览器操作-cookie"><a href="#浏览器操作-cookie" class="headerlink" title="浏览器操作 cookie"></a>浏览器操作 cookie</h3><p>浏览器操作 cookie 的操作，使用相对较少，大家了解即可</p><ol><li>禁用所有 cookie</li><li>删除 cookie</li><li>查看 cookie</li></ol><h3 id="cookie-的代码操作"><a href="#cookie-的代码操作" class="headerlink" title="cookie 的代码操作"></a>cookie 的代码操作</h3><p>express 中可以使用 <code>cookie-parser</code> 进行处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express =<span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//1. 安装 cookie-parser npm i cookie-parser</span></span><br><span class="line"><span class="comment">//2. 引入 cookieParser 包</span></span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 设置 cookieParser 中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>());</span><br><span class="line">  </span><br><span class="line"><span class="comment">//4-1 设置 cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/set-cookie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 不带时效性    会在浏览器关闭的时候，销毁</span></span><br><span class="line">response.<span class="title function_">cookie</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>);</span><br><span class="line">  <span class="comment">// 带时效性</span></span><br><span class="line">  response.<span class="title function_">cookie</span>(<span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;23123456@qq.com&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">5</span>*<span class="number">60</span>*<span class="number">1000</span> &#125;);</span><br><span class="line">  <span class="comment">//响应</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;Cookie的设置&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-2 读取 cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/get-cookie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//读取 cookie</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">cookies</span>);</span><br><span class="line">  <span class="comment">//响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;Cookie的读取&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-3 删除cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/delete-cookie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">response.<span class="title function_">clearCookie</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">response.<span class="title function_">send</span>(<span class="string">&#x27;cookie 的清除&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>不同浏览器中的 cookie 是相互独立的，不共享</p></blockquote><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="session-是什么"><a href="#session-是什么" class="headerlink" title="session 是什么"></a>session 是什么</h3><p>session 是保存在 <code>&lt;span style=&quot;color:red&quot;&gt;</code>服务器端的一块儿数据，保存当前访问用户的相关信息</p><h3 id="session-的作用"><a href="#session-的作用" class="headerlink" title="session 的作用"></a>session 的作用</h3><p>实现会话控制，可以识别用户的身份，快速获取当前用户的相关信息</p><h3 id="session-运行流程"><a href="#session-运行流程" class="headerlink" title="session 运行流程"></a>session 运行流程</h3><p>填写账号和密码校验身份，校验通过后创建 <code>session 信息</code>，然后将 <code>session_id</code> 的值通过响应头返回给浏览器</p><p><img src="./assets/b85539cfe706e14c1b8e3c951169ef818af4f247.png" alt="image-20230327222810111"></p><p>有了cookie，下次发送请求时会自动携带cookie，服务器通过 <code>cookie</code> 中的 <code>session_id</code> 的值确定用<br>户的身份</p><p><img src="./assets/58c03619b70c2ecc76ac8684691a30fe977f59c1.png" alt="image-20230327223550720"></p><h3 id="session-的代码操作"><a href="#session-的代码操作" class="headerlink" title="session 的代码操作"></a>session 的代码操作</h3><p>express 中可以使用 <code>express-session</code> 对 session 进行操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//1. 安装包 npm i express-session connect-mongo</span></span><br><span class="line"><span class="comment">//2. 引入 express-session connect-mongo</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 设置 session 的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;sid&#x27;</span>, <span class="comment">//设置cookie的name，默认值是：connect.sid</span></span><br><span class="line"><span class="attr">secret</span>: <span class="string">&#x27;atguigu&#x27;</span>, <span class="comment">//参与加密的字符串（又称签名）  加盐</span></span><br><span class="line"><span class="attr">saveUninitialized</span>: <span class="literal">false</span>, <span class="comment">//是否为每次请求都设置一个cookie用来存储session的id</span></span><br><span class="line"><span class="attr">resave</span>: <span class="literal">true</span>, <span class="comment">//是否在每次请求时重新保存session</span></span><br><span class="line"><span class="attr">store</span>: <span class="title class_">MongoStore</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">mongoUrl</span>: <span class="string">&#x27;mongodb://127.0.0.1:27017/project&#x27;</span> <span class="comment">//数据库的连接配置</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="attr">cookie</span>: &#123;</span><br><span class="line"><span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="comment">// 开启后前端无法通过 JS 操作</span></span><br><span class="line"><span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">300</span> <span class="comment">// 这一条 是控制 sessionID 的过期时间的！！！</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 session  session的设置</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置session</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">username</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">email</span> = <span class="string">&#x27;zhangsan@qq.com&#x27;</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 session</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;session的信息&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">session</span>.<span class="property">username</span>);</span><br><span class="line">    <span class="comment">// 检测 session 是否存在用户数据</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">session</span>.<span class="property">username</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`你好 <span class="subst">$&#123;req.session.username&#125;</span>`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;登录 注册&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 session</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//销毁session</span></span><br><span class="line">    <span class="comment">// res.send(&#x27;设置session&#x27;);</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;成功退出&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动, 端口 &#x27;</span> + <span class="number">3000</span> + <span class="string">&#x27; 监听中...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="session-和-cookie-的区别"><a href="#session-和-cookie-的区别" class="headerlink" title="session 和 cookie 的区别"></a>session 和 cookie 的区别</h2><p>cookie 和 session 的区别主要有如下几点：</p><ol><li>存在的位置</li></ol><ul><li>cookie：浏览器端</li><li>session：服务端</li></ul><ol start="2"><li>安全性</li></ol><ul><li>cookie 是以明文的方式存放在客户端的，安全性相对较低</li><li>session 存放于服务器中，所以安全性 <code>相对</code> 较好</li></ul><ol start="3"><li>网络传输量</li></ol><ul><li>cookie 设置内容过多会增大报文体积， 会影响传输效率</li><li>session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率</li></ul><ol start="4"><li>存储限制</li></ol><ul><li>浏览器限制单个 cookie 保存的数据不能超过 <code>4K</code> ，且单个域名下的存储数量也有限制</li><li>session 数据存储在服务器中，所以没有这些限制</li></ul><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><h3 id="token-是什么"><a href="#token-是什么" class="headerlink" title="token 是什么"></a>token 是什么</h3><p><code>token</code> 是服务端生成并返回给 HTTP 客户端的一串加密字符串， <code>token</code> 中保存着 <code>用户信息</code></p><p>token 不属于 http 标准，完全由前后端协商而定，但 cookie 属于 http 标准</p><h3 id="token-的作用"><a href="#token-的作用" class="headerlink" title="token 的作用"></a>token 的作用</h3><p>实现会话控制，可以识别用户的身份，主要用于移动端 APP</p><h3 id="token-的工作流程"><a href="#token-的工作流程" class="headerlink" title="token 的工作流程"></a>token 的工作流程</h3><p>填写账号和密码校验身份，校验通过后响应 token，token 一般是在响应体中返回给客户端的</p><p><img src="./assets/5e03daa442b749955aac291d68ffa22c3506ba86.png" alt="image-20230328135106885"><br>后续发送请求时，需要 <code>手动</code>将 token 添加在请求报文中(<code>&lt;span style=&quot;color:red&quot;&gt;</code>cookie是自动携带的)，一般是放在请求头中<br><img src="./assets/7e7369958050ccff563122b9618f09c28dae956b.png" alt="image-20230328135122945"></p><h3 id="token-的特点"><a href="#token-的特点" class="headerlink" title="token 的特点"></a>token 的特点</h3><ul><li><p>服务端压力更小</p><ul><li>数据存储在客户端</li></ul></li><li><p>相对更安全</p><ul><li>数据加密</li><li>可以避免 CSRF（跨站请求伪造）</li></ul></li><li><p>扩展性更强</p><ul><li>服务间可以共享</li><li>增加服务节点更简单</li></ul></li></ul><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 <code>token</code> 的身份验证</p><p>JWT 使 token 的生成与校验更规范</p><p>我们可以使用 <code>jsonwebtoken 包</code> 来操作 token</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入 jsonwebtokan</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 token</span></span><br><span class="line"><span class="comment">// jwt.sign(数据, 加密字符串, 配置对象)</span></span><br><span class="line"><span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;atguigu&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">60</span> <span class="comment">//单位是 秒</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 token</span></span><br><span class="line"><span class="comment">// jwt.verify(token,加密字符串，回调函数)</span></span><br><span class="line">jwt.<span class="title function_">verify</span>(token, <span class="string">&#x27;atguigu&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;校验失败~~&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);<span class="comment">// &#123; username: &#x27;张三&#x27;, iat: (创建时间), exp:(过期时间)&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>扩展阅读： <a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="本地域名"><a href="#本地域名" class="headerlink" title="本地域名"></a>本地域名</h3><p>所谓本地域名就是 <code>&lt;span style=&quot;color:red&quot;&gt;</code>只能在本机使用的域名，一般在开发阶段使用</p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>编辑文件 <code>C:\Windows\System32\drivers\etc\hosts</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1   www.baidu.com</span><br></pre></td></tr></table></figure><p>如果修改失败，<code>&lt;span style=&quot;color:red&quot;&gt;</code>可以修改该文件的权限</p><p><img src="./assets/bfe2b3b80fe871577ca342891eef6201f352b682.jpg" alt="11_会话控制"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在地址栏输入 <code>域名</code> 之后，浏览器会先进行 DNS（Domain Name System）查询，获取该域名对应的 IP 地<br>址<br>请求会发送到 DNS 服务器，可以 <code>根据域名返回 IP 地址</code></p><p>可以通过 <code>ipconfig /all</code> 查看本机的 DNS 服务器</p><p><code>hosts</code> 文件也可以设置域名与 IP 的映射关系，在发送请求前，可以通过该文件获取域名的 IP 地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/06/02/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/06/02/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="接口是什么"><a href="#接口是什么" class="headerlink" title="接口是什么"></a>接口是什么</h3><blockquote><p>接口是 <code>&lt;span style=&quot;color:red&quot;&gt;</code>前后端通信的桥梁</p></blockquote><p>简单理解：一个接口就是 <code>&lt;span style=&quot;color:red&quot;&gt;</code>服务中的一个路由规则 ，根据请求响应结果</p><p>接口的英文单词是 API (Application Program Interface)，所以有时也称之为 <code>API 接口</code></p><p>这里的接口指的是『数据接口』， <code>&lt;span style=&quot;color:red&quot;&gt;</code>与编程语言（Java，Go 等）中的接口语法不同</p><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><blockquote><p>实现 <code>&lt;span style=&quot;color:red&quot;&gt;</code>前后端通信</p></blockquote><p><img src="./assets/b6836e5dc9b1f33ee5f030de2fd1780db7f2447c.png" alt="image-20230327163353386"></p><h3 id="接口的开发与调用"><a href="#接口的开发与调用" class="headerlink" title="接口的开发与调用"></a>接口的开发与调用</h3><p>大多数接口都是由 <code>&lt;span style=&quot;color:red&quot;&gt;</code>后端工程师 开发的， <code>&lt;span style=&quot;color:red&quot;&gt;</code>开发语言不限</p><p>一般情况下接口都是由 <code>&lt;span style=&quot;color:red&quot;&gt;</code>前端工程师 调用的，但有时 <code>&lt;span style=&quot;color:red&quot;&gt;</code>后端工程师也会调用接口 ，比如短信接口，支付接口<br>等</p><h3 id="接口的组成"><a href="#接口的组成" class="headerlink" title="接口的组成"></a>接口的组成</h3><p>一个接口一般由如下几个部分组成</p><ul><li>请求方法</li><li>接口地址（URL）</li><li>请求参数</li><li>响应结果</li></ul><p>一个接口示例 <a href="https://www.free-api.com/doc/325">https://www.free-api.com/doc/325</a></p><p>体验一下： <a href="https://api.asilu.com/idcard/?id=371522199111299668">https://api.asilu.com/idcard/?id=371522199111299668</a></p><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>RESTful API 是一种特殊风格的接口，主要特点有如下几个：</p><ul><li>URL 中的路径表示 <code>&lt;span style=&quot;color:red&quot;&gt;</code>资源，路径中不能有 <code>动词</code>，例如 <code>create</code> , <code>delete</code> , <code>update</code> 等这些都不能有</li><li>操作资源要与 <code>HTTP 请求方法</code> 对应</li><li>操作结果要与 <code>HTTP 响应状态码</code> 对应</li></ul><p>规则示例：</p><table><thead><tr><th>操作</th><th>请求类型</th><th>URL</th><th>返回</th></tr></thead><tbody><tr><td>新增歌曲</td><td>POST</td><td>/song</td><td>返回新生成的歌曲信息</td></tr><tr><td>删除歌曲</td><td>DELETE</td><td>/song/10</td><td>返回一个空文档</td></tr><tr><td>修改歌曲</td><td>PUT</td><td>/song/10</td><td>返回更新后的歌曲信息</td></tr><tr><td>修改歌曲</td><td>PATCH</td><td>/song/10</td><td>返回更新后的歌曲信息</td></tr><tr><td>获取所有歌曲</td><td>GET</td><td>/song</td><td>返回歌曲列表数组</td></tr><tr><td>获取单个歌曲</td><td>GET</td><td>/song/10</td><td>返回单个歌曲信息</td></tr></tbody></table><blockquote><p>扩展阅读： <a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">https://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p></blockquote><h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>json-server 本身是一个 JS 编写的工具包，可以快速搭建 RESTful API 服务</p><p>官方地址: <a href="https://github.com/typicode/json-server">https://github.com/typicode/json-server</a></p><p>操作步骤：</p><ol><li><p>全局安装 <code>json-server</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g json-server</span><br></pre></td></tr></table></figure></li><li><p>创建 JSON 文件（db.json），编写基本结构</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;song&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;干杯&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;五月天&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;当&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;动力火车&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;不能说的秘密&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;周杰伦&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>以 JSON 文件所在文件夹作为工作目录</code>，执行如下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json-server --watch db.json</span><br></pre></td></tr></table></figure></li></ol><p>默认监听端口为 <code>3000</code></p><h2 id="接口测试工具"><a href="#接口测试工具" class="headerlink" title="接口测试工具"></a>接口测试工具</h2><p>  介绍几个接口测试工具<br>  apipost <a href="https://www.apipost.cn/">https://www.apipost.cn/</a> (中文)<br>  apifox <a href="https://www.apifox.cn/">https://www.apifox.cn/</a> (中文)<br>  postman <a href="https://www.postman.com/">https://www.postman.com/</a> (英文)</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/2023/06/02/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/02/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h1><ol><li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。（先判断HTTP请求浏览器是否已缓存）</li></ol><p><strong>有缓存</strong></p><p>如为<strong>强制缓存</strong> ，通过 <code>Expires或Cache-Control：max-age</code>判断该缓存是否过期，未过期，直接使用该资源；Expires和max-age，如果两者同时存在，则被Cache-Control的max-age覆盖。</p><p>如为<strong>协商缓存</strong> ，请求头部带上相关信息如 <code>if-none-match（Etag）</code>与 <code>if-modified-since(last-modified)</code>，验证缓存是否有效，若有效则返回状态码为 <code>304</code>，若无效则重新返回资源，状态码为 <code>200</code></p><ol start="2"><li>DNS解析URL对应的IP</li><li>根据IP建立TCP连接（三次握手）（<code>握手过程见下文</code>）</li><li>HTTP发起请求</li><li>服务器处理请求，浏览器接收HTTP响应</li><li>渲染页面，构建DOM树</li></ol><ul><li>HTML 解析，生成DOM树</li><li>根据 CSS 解析生成 CSS 树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息（layout布局）</li><li>根据计算好的信息绘制页面</li></ul><p>如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，如果有，异步去下载该资源；如果没有设置，暂停dom的解析，去加载script的资源，然后执行该js代码（ <strong>script标签加载和执行会阻塞页面的渲染</strong> ）</p><ol start="7"><li>关闭TCP连接（四次挥手）</li></ol><h1 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http协议又叫超文本传输协议，它是应用层中使用最多的协议，</p><p>http与我们常说的socket有什么区别吗？</p><p>我们使用的网络可以分为（会话层和表示层可以忽略），每一层使用下一层的功能，并为上一层提供接口，我们经常听说的http协议就是应用层的协议，其中应用层协议包括ftp等等，而应用层还需要使用传输层的协议，http使用的就是tcp协议，http3计划使用udp协议。不过不管是tcp还是udp都是使用网络层的ip协议。不过传输层及以下层都是在操作系统内核中的，不利于我们使用，所以在用户态设计了socket接口来帮助我们使用tcp或者udp的网络协议。而http协议则是已经定义好解析标准的能让我们直接使用的协议。</p><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>http1.0是个短连接，即每发一次请求，就建立一次连接，一次响应后就释放连接，这种方式简化了http的请求响应，但是却造成了重大的浪费：不能并行请求，每次请求都需要建立连接和释放连接，导致每次请求都需要三次握手和四次挥手。</p><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><ol><li>长连接: 每个连接完成一次请求后先不关闭，在一定时间内可以发送多次请求。通过设置请求头<em>Connection: keep-alive</em>来实现。</li><li>管道化技术: 虽然长连接减少了握手消耗，但是每次都要前一次请求完成之后才能发送下一次请求，管道化技术允许在一个请求没有响应之前发送多次请求。不过管道话技术要求响应必须按照请求发送的顺序返回，否则无法解析。存在队头阻塞。实际使用不多。</li></ol><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ol><li>二进制分帧：http2设计出了二进制分帧技术，http1中的数据都是通过文本文本传输的，但是二进制结构更有利于数据处理，因为计算机只认识二进制，所以传输时不需要文本与二进制之间的转换。</li><li>http1中的管道技术虽然支持反多次请求，但是响应必须按照顺序返回，不能实现真正的并发，存在队头阻塞问题。针对这个问题，http2将每个响应分成若干个帧序列，而每个帧序列都有流号，标记属于哪个响应，这样即使每个帧序列乱序到客户端，还是能够根据流id重新组装，解决了http方面的队头阻塞，真正实现多路复用。</li><li>头部压缩：在大多数时候，我们请求或者响应的数据可能很少（例如ajax请求），但是同样需要传输各种请求头，尤其是cookie。这无疑给http带来负担，而头部压缩就是解决重复请求头发送的问题。</li><li>服务器推送：在http1中，上一个响应发送完了，服务器才能发送下一个请求，但在http2里，可以将多个响应一起发送。例如在一个html文件中有个多js，css文件，为了快速解析页面，可以直接向客户端推送js文件，从而减少客户端请求的时间。</li></ol><p>http2存在的缺陷：http2虽然实现了多路复用，但是并没有解决tcp方面的队头阻塞。而且，同一个连接内多个流传输，可能会导致响应事件时间变长，相比http1容易出现超时重传；再者，h2适合于大量冗余的请求，对于少量请求并没有太大优势。</p><h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>http3协议使用udp为传输层协议，udp不需要握手就可以直接发送数据，因此udp是不可靠的传输层协议，所以就需要自己实现tcp的流量控制和拥塞控制。</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>http协议都是明文传输的，而且不会对应用数据和主机进行验证，这样即使数据被窃取和篡改我们也不得而知，所以为了保证http的安全，在它的基础上加了TSL/SSL安全协议。形成了我们所说的https协议。</p><p><img src="1.png" alt="1685723109077"></p><p>http之所以不安全最大的原因就是使用明文传输，所以加密成了最大的问题，目前分为两大类加密算法。</p><ul><li>对称加密：DES(分组加密算法)，AES(可以看作是DES的升级版)</li><li>非对称加密：RSA、DSA</li></ul><p><img src="2.png" alt="1685723237404"></p><p>由于目前公钥加密算法的开销比较大，所以一般采用对称加密来保密信息。但是对称加密过程，密钥如何传输？这时可以使用公私钥来进行传输，因为公私钥使用公钥加密，私钥解密，所以只要是对方公钥加密的数据只有对方的私钥才能解密。</p><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><ol><li><p>安全角度</p><p>http属于明文传输协议，https属于加密传输协议，传输的数据需要经过SSL/TLS加密，因此有更高的安全性。</p></li><li><p>端口角度</p><p>http: 80; https: 443</p></li><li><p>加密与证书角度</p><p>http不需要向服务端申请证书</p><p>https在TCP三次握手后，需要进行SSL的握手，协商加密使用的对称加密密钥，还需要向服务端申请证书，浏览器安装对应的根证书。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写源代码</title>
      <link href="/2023/05/30/%E6%89%8B%E5%86%99%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
      <url>/2023/05/30/%E6%89%8B%E5%86%99%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="使用双重-for-和-splice"><a href="#使用双重-for-和-splice" class="headerlink" title="使用双重 for 和 splice"></a>使用双重 for 和 splice</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= i+<span class="number">1</span>;j&lt;arr.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]===arr[j])&#123;</span><br><span class="line">                <span class="comment">// 删除第二个</span></span><br><span class="line">                arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 删除后回调j</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="title function_">unique</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><h2 id="使用-indexOf-或-includes-加新数组"><a href="#使用-indexOf-或-includes-加新数组" class="headerlink" title="使用 indexOf 或 includes 加新数组"></a>使用 indexOf 或 includes 加新数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> uniqueArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// if (!uniqueArr.includes(arr[i])) &#123;</span></span><br><span class="line">            <span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueArr.<span class="title function_">indexOf</span>(arr[i])=== -<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">//indexof返回-1表示在新数组中不存在该元素</span></span><br><span class="line">             uniqueArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-排序后，使用快慢指针的思想"><a href="#sort-排序后，使用快慢指针的思想" class="headerlink" title="sort 排序后，使用快慢指针的思想"></a>sort 排序后，使用快慢指针的思想</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);<span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">1</span>,fast =<span class="number">1</span>;<span class="comment">//快慢指针起始点都是第二个</span></span><br><span class="line">    <span class="keyword">while</span>(fast&lt;arr.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fast] !== arr[fast-<span class="number">1</span>])&#123;</span><br><span class="line">            arr[slow++] = arr[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="property">length</span> = slow;<span class="comment">// 去重后数组长度,原数组多余部分会被删除</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort 方法用于从小到大排序(返回一个新数组)，其参数中不带以上回调函数就会在两位数及以上时出现排序错误(如果省略，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。两位数会变为长度为二的字符串来计算)。</p><h2 id="ES6-提供的-Set-去重"><a href="#ES6-提供的-Set-去重" class="headerlink" title="ES6 提供的 Set 去重"></a>ES6 提供的 Set 去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set 集合</span></span><br><span class="line"><span class="comment"> * 成员的值都是唯一的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line">    <span class="comment">//通过扩展运算符拆分再放入数组中</span></span><br><span class="line">    <span class="keyword">return</span> [...res];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p><h2 id="使用哈希表存储元素是否出现-ES6-提供的-map"><a href="#使用哈希表存储元素是否出现-ES6-提供的-map" class="headerlink" title="使用哈希表存储元素是否出现(ES6 提供的 map)"></a>使用哈希表存储元素是否出现(ES6 提供的 map)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map 集合</span></span><br><span class="line"><span class="comment"> * 保存键值对，与对象类似,键可以是任意类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> uniqueArr= <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.<span class="title function_">has</span>(arr[i]))&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(arr[i],<span class="literal">true</span>);</span><br><span class="line">            uniqueArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueArr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 对象保存键值对，与对象类似。但 map 的键可以是任意类型，对象的键只能是字符串类型。</p><p>如果数组中只有数字也可以使用普通对象作为哈希表。</p><h2 id="filter-配合-indexOf"><a href="#filter-配合-indexOf" class="headerlink" title="filter 配合 indexOf"></a>filter 配合 indexOf</h2><p>filter返回过滤后的数组。filter也接收一个函数作为参数，这个函数将作用于数组中的每个元素，根据该函数每次执行后返回的布尔值来保留结果，如果是true就保留，如果是false就过滤掉。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item,index,arr</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item)===index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf返回元素在数组中第一次出现的位置</p><h2 id="reduce-配合-includes"><a href="#reduce-配合-includes" class="headerlink" title="reduce 配合 includes"></a>reduce 配合 includes</h2><p>reduce也是返回一个全新的数组。reduce接受一个函数作为参数，这个函数要有两个形参，代表数组中的前两项，reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> uniqueArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res,cur</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res.<span class="title function_">includes</span>(cur))res.<span class="title function_">push</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,[])<span class="comment">// []作为回调函数的第一个参数的初始值</span></span><br><span class="line">    <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实现数组扁平化"><a href="#如何实现数组扁平化" class="headerlink" title="如何实现数组扁平化"></a>如何实现数组扁平化</h1><p>数组扁平化就是把多维数组转化成一维数组。</p><h2 id="ES6提供的新方法-flat-depth"><a href="#ES6提供的新方法-flat-depth" class="headerlink" title="ES6提供的新方法 flat(depth)"></a>ES6提供的新方法 flat(depth)</h2><p>不会改变原数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]];  </span><br><span class="line">a = a.<span class="title function_">flat</span>(<span class="number">4</span>-<span class="number">1</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br><span class="line">a = a.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><h2 id="reduce方法-递归"><a href="#reduce方法-递归" class="headerlink" title="reduce方法 递归"></a>reduce方法 递归</h2><p>这里使用的是数组的reduce方法，需要注意的是reduce方法，我们传递了两个参数，<br>第一个参数就是就是处理扁平化的箭头函数<br>第二个参数是一个空数组，也是作为遍历的开始。（res）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = arr =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res,next</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)?<span class="title function_">flatten</span>(next):next);</span><br><span class="line"></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么要使用深拷贝？"><a href="#为什么要使用深拷贝？" class="headerlink" title="为什么要使用深拷贝？"></a><strong>为什么要使用深拷贝？</strong></h1><p>因为希望在改变新的数组或对象时，不改变原数组或原对象。</p><p>深拷贝和浅拷贝是只针对非null的Object和Array这样的引用数据类型的。</p><p>深拷贝和浅拷贝的示意图大致如下：</p><p><img src="1.png" alt="1684286684266"></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowcopy</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (source) == <span class="string">&#x27;object&#x27;</span> &amp;&amp; source != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newsource = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(source) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                newsource[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newsource</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newsource = <span class="title function_">shallowcopy</span>(source);</span><br><span class="line">newsource[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source, newsource)</span><br></pre></td></tr></table></figure><h3 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h3><ul><li>Object.assign()</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123; name: &#x27;sy&#x27;, age: 18 &#125;;</span><br><span class="line">const obj2 = Object.assign(&#123;&#125;, obj, &#123;name: &#x27;sss&#x27;&#125;);</span><br><span class="line">console.log(obj2);//&#123; name: &#x27;sss&#x27;, age: 18 &#125;</span><br></pre></td></tr></table></figure><ul><li>concat</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">concat</span>();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><ul><li>slice</li><li>…展开运算符</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简易版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = source =&gt;&#123;</span><br><span class="line">    <span class="comment">// 判断是否为数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isArray</span> = arr =&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    <span class="comment">// 判断是否为引用类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isObject</span> = obj =&gt; obj !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">    <span class="comment">//拷贝（递归）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">copy</span> = input =&gt;&#123;</span><br><span class="line">        <span class="comment">// 当输入为函数或基本数据类型时，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;function&#x27;</span> || !<span class="title function_">isObject</span>(input)) <span class="keyword">return</span> input;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> output = <span class="title function_">isArray</span>(input) ? [] : &#123;&#125; ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> input)&#123;</span><br><span class="line">             <span class="comment">// 如果key是对象的自有属性</span></span><br><span class="line">            <span class="keyword">if</span>(input.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">                <span class="comment">// 递归调用深拷贝方法</span></span><br><span class="line">                output[key] = <span class="title function_">copy</span>(input[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">copy</span>(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> newArr1 = <span class="title function_">deepClone</span>(arr);<span class="comment">//深拷贝</span></span><br><span class="line">newArr1[<span class="number">2</span>].<span class="property">val</span> = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> newArr2 = newArr1.<span class="title function_">slice</span>();<span class="comment">//浅拷贝</span></span><br><span class="line">newArr2[<span class="number">2</span>].<span class="property">val</span> = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr2)</span><br></pre></td></tr></table></figure><h3 id="循环引用的问题"><a href="#循环引用的问题" class="headerlink" title="循环引用的问题"></a>循环引用的问题</h3><p>使用WeakMap解决</p><p>首先，Map 的键属于强引用，而 WeakMap 的键则属于弱引用。且 WeakMap 的键必须是对象，WeakMap 的值则是任意的。</p><p>由于它们的键与值的引用关系，决定了 Map 不能确保其引用的对象不会被垃圾回收器回收的引用。假设我们使用的 Map，那么图中的 foo 对象和我们深拷贝内部的 const map = new Map() 创建的 map 对象一直都是强引用关系，那么在程序结束之前，foo 不会被回收，其占用的内存空间一直不会被释放。</p><p>相比之下，原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 WeakMap 的结构是特殊且有效的，其用于映射的 key 只有在其没有被回收时才是有效的。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepCopy</span> = source =&gt; &#123;</span><br><span class="line">  <span class="comment">// 其他一样，省略一万字...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个数组，将每次拷贝的对象放进去</span></span><br><span class="line">  <span class="keyword">const</span> copiedArr = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝（递归思路）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">copy</span> = input =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当输入为函数或基本数据类型时，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;function&#x27;</span> || !<span class="title function_">isObject</span>(input)) <span class="keyword">return</span> input;   </span><br><span class="line">    <span class="comment">// 循环遍历，若有已拷贝过的对象，则直接放回，以解决循环引用的问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = copiedArr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input === copiedArr[i].<span class="property">key</span>) <span class="keyword">return</span> copiedArr[i].<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> output = <span class="title function_">isArray</span>(input) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每一次的对象</span></span><br><span class="line">    copiedArr.<span class="title function_">push</span>(&#123; <span class="attr">key</span>: input, <span class="attr">value</span>: output &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面的流程不变...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">copy</span>(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化、模块化、工程化</title>
      <link href="/2023/05/30/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>/2023/05/30/%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是前端工程化、模块化、组件化？"><a href="#什么是前端工程化、模块化、组件化？" class="headerlink" title="什么是前端工程化、模块化、组件化？"></a>什么是前端工程化、模块化、组件化？</h1><h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><p>工程化是一种思想而不是某种技术(当然为了实现工程化我们会用一些技术)</p><p>再用一句通俗的话来概括前端工程化:前端工程化就是用做工程的思维看待和开发自己的项目,而不再是直接撸起袖子一个页面一个页面开写。</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>开发时，我们会使用框架（React、Vue），ES6 模块化语法，Less/Sass 等 css 预处理器等语法进行开发。</p><p>这样的代码要想在浏览器运行必须经过编译成浏览器能识别的 JS、Css 等语法，才能运行。</p><p>所以我们需要打包工具帮我们做完这些事。</p><p>除此之外，打包工具还能压缩代码、做兼容性处理、提升代码性能等。</p><p>目前市面上最流量的是 Webpack，所以我们主要以 Webpack 来介绍使用打包工具</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Webpack 是一个静态资源打包工具。</p><p>它会以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。</p><p>输出的文件就是编译好的文件，就可以在浏览器段运行了。</p><p>我们将 Webpack 输出的文件叫做 bundle。</p><p><img src="webpack.png" alt="1685413462273"></p><p><strong>功能介绍</strong></p><p>Webpack 本身功能是有限的:</p><p>开发模式：仅能编译 JS 中的 ES Module 语法<br>生产模式：能编译 JS 中的 ES Module 语法，还能压缩 JS 代码</p><p><strong>开始使用</strong></p><ol><li>资源目录</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack_code <span class="comment"># 项目根目录（所有指令必须在这个目录运行）</span></span><br><span class="line">    └── src <span class="comment"># 项目源码目录</span></span><br><span class="line">        ├── js <span class="comment"># js文件目录</span></span><br><span class="line">        │   ├── count.js</span><br><span class="line">        │   └── sum.js</span><br><span class="line">        └── main.js <span class="comment"># 项目主文件</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建文件</li></ol><p>count.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&quot;./js/count&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">count</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><ol start="3"><li>下载依赖</li></ol><p>打开终端，来到项目根目录。运行以下指令：</p><ul><li>初始化package.json</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>此时会生成一个基础的 package.json 文件。</p><p>需要注意的是 package.json 中 name 字段不能叫做 webpack, 否则下一步会报错</p><ul><li>下载依赖</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><ol start="4"><li>启用 Webpack</li></ol><p>开发模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=development</span><br></pre></td></tr></table></figure><p>生产模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=production</span><br></pre></td></tr></table></figure><p><code>npx webpack:</code> 是用来运行本地安装 Webpack 包的。</p><p><code>./src/main.js:</code> 指定 Webpack 从 main.js 文件开始打包，不但会打包 main.js，还会将其依赖也一起打包进来。</p><p><code>--mode=xxx:</code> 指定模式（环境）。</p><ol start="5"><li>观察输出文件</li></ol><p>默认 Webpack 会将文件打包输出到 dist 目录下，我们查看 dist 目录下文件情况就好了</p><p><strong>小结</strong><br>Webpack 本身功能比较少，只能处理 js 资源，一旦遇到 css 等其他资源就会报错。</p><p>所以我们学习 Webpack，就是主要学习如何处理其他资源。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在开始使用 Webpack 之前，我们需要对 Webpack 的配置有一定的认识。</p><h4 id="5-大核心概念"><a href="#5-大核心概念" class="headerlink" title="5 大核心概念"></a>5 大核心概念</h4><p><code>entry</code>（入口）</p><p>指示 Webpack 从哪个文件开始打包</p><p><code>output</code>（输出）</p><p>指示 Webpack 打包完的文件输出到哪里去，如何命名等</p><p><code>loader</code>（加载器）</p><p>webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析</p><p><code>plugins</code>（插件）</p><p>扩展 Webpack 的功能</p><p><code>mode</code>（模式）</p><p>主要由两种模式：</p><p>开发模式：development</p><p>生产模式：production</p><p>准备 Webpack 配置文件<br>在项目根目录下新建文件：<code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul><li>配置文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js的核心模块，专门用来处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="comment">// 相对路径和绝对路径都行</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// path: 文件输出目录，必须是绝对路径</span></span><br><span class="line">    <span class="comment">// path.resolve()方法返回一个绝对路径</span></span><br><span class="line">    <span class="comment">// __dirname 当前文件的文件夹绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="comment">// filename: 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>运行指令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>此时功能和之前一样，也不能处理样式资源。</p><p>需要配置loader解析资源</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="comment">// 用来处理图片资源</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">          <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">          <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">          <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">          <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="comment">// 用来处理图标字体资源</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Webpack 将来都通过 webpack.config.js 文件进行配置，来增强 Webpack 的功能</p><h2 id="webpack打包流程"><a href="#webpack打包流程" class="headerlink" title="webpack打包流程"></a>webpack打包流程</h2><p>1）webpack 从项目的 <code>entry</code>入口文件开始递归分析，调用所有配置的 <code>loader</code>对模块进行编译</p><p>因为 webpack 默认只能识别 js 代码，所以如 css 文件、.vue 结尾的文件，必须要通过对应的 loader 解析成 js 代码后，webpack 才能识别</p><p>2）利用 <code>babel(babylon)</code>将 js 代码转化为 <code>ast抽象语法树</code>，然后通过 <code>babel-traverse</code>对 ast 进行遍历</p><p>3）遍历的目的找到文件的 <code>import引用节点</code></p><p>因为现在我们引入文件都是通过 import 的方式引入，所以找到了 import 节点，就找到了文件的依赖关系</p><p>4）同时每个模块生成一个唯一的 id，并将解析过的 <code>模块缓存</code>起来，如果其他地方也引入该模块，就无需重新解析，最后根据依赖关系生成依赖图谱</p><p>5）递归遍历所有依赖图谱的模块，组装成一个个包含多个模块的 <code>Chunk(块)</code></p><p>6）最后将生成的文件输出到 <code>output</code> 的目录中</p><h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><p>前端工程化是一个高层次的思想,而模块化和组件化是为工程化思想下相对较具体的开发方式,因此可以简单的认为模块化和组件化是工程化的表现形式。</p><p>模块化开发，<strong>一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。</strong></p><p><strong>模块化开发的4点好处：</strong></p><ul><li>避免变量污染，命名冲突</li><li>提高代码复用率</li><li>提高维护性</li><li>依赖关系的管理</li></ul><p>那具体什么是模块化呢？还是举简单的例子,我们要写一个实现A功能的JS代码,这个功能在项目其他位置也需要用到,那么我们就可以把这个功能看成一个模块采用一定的方式进行模块化编写,既能实现复用还可以分而治之,同理在写样式的时候,如果我们需要某种特殊的样式,会在很多地方应用,那么我们也可以采用一定的方式进行CSS的模块化,具体说来,JS模块化方案很多有AMD/CommonJS/UMD/ES6 Module等,CSS模块化开发大多是在less、sass、stylus等预处理器的import/mixin特性支持下实现的</p><p>总体而言,<strong>模块化不难理解,重点是要学习相关的技术并且灵活运用。</strong></p><h1 id="前端组件化"><a href="#前端组件化" class="headerlink" title="前端组件化"></a>前端组件化</h1><p>组件化也是工程化的表现形式。</p><p>①页面上的每个独立的、可视/可交互区域视为一个组件;<br>②每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护;<br>③由于组件具有独立性,因此组件与组件之间可以 自由组合;<br>④页面只不过是组件的容器,负责组合组件形成功能完整的界面;<br>⑤当不需要某个组件,或者想要替换组件时,可以整个目录删除/替换。</p><p><strong>组件化将页面视为一个容器,页面上各个独立部分例如:头部、导航、焦点图、侧边栏、底部等视为独立组件,不同的页面根据内容的需要,去盛放相关组件即可组成完整的页面。</strong></p><p> <strong>PS:</strong> 模块化和组件化一个最直接的好处就是复用,同时我们也应该有一个理念,模块化和组件化除了复用之外还有就是分治,我们能够在不影响其他代码的情况下按需修改某一独立的模块或是组件,因此很多地方我们及时没有很强烈的复用需要也可以根据分治需求进行模块化或组件化开发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 组件化、模块化、工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2023/04/20/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/04/20/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>懒加载经常出现在前端面试中，是前端性能优化的常用技巧。懒加载也叫延迟加载，把非关键资源先不加载，等用到了再加载，将加载非关键资源的时间推迟，而加快页面的初始加载时间。懒加载经常被用在图片、视频、音频、JavaScript 文件等资源加载上，本文主要讨论图片的懒加载。通过本文你能收获：</p><ul><li>图片懒加载的原理</li><li>实现图片懒加载的四种方案的原理以及优缺点</li><li>图片懒加载的一些优化</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>图片懒加载的原理是没有在可视区域的图片暂时不加载图片，等进入可视区域后在加载图片，这样可以减少初始页面加载的图片数量而提升页面加载速度。<br>图片懒加载在提升页面加载速度的同时也会伴随用户看其他未展示的图片时会有等待时间；图片加载显示会伴有布局抖动等问题。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>图片懒加载的关键是：判断一个元素是否在可视区域。</p><h2 id="通过offsetTop来计算是否在可视区域内"><a href="#通过offsetTop来计算是否在可视区域内" class="headerlink" title="通过offsetTop来计算是否在可视区域内"></a>通过offsetTop来计算是否在可视区域内</h2><p>可视区域高度是 <code>document.documentElement.clientHeight</code> ，而可视区域的位置是在滚动条滚动位置 <code>scrollTop</code> 到 <code>scrollTop+document.documentElement.clientHeight</code>之间。因此通过 <code>image.offsetTop &lt;= document.documentElement.clientHeight + document.documentElement.scrollTop</code> 判断图片是否可以在可视区域内。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> lazyImages = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.lazyload&quot;</span>);</span><br><span class="line">      lazyImages.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">image</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( image.<span class="property">offsetTop</span> &lt;= <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> + <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>) &#123;</span><br><span class="line">          image.<span class="property">src</span> = image.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加滚动条监听。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">lazyload</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>html结构。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;./default.gif&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;lazyload&quot;</span> data-src=<span class="string">&quot;./photo-1.jpg&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面只是简单的实现图片懒加载，在实际开发中还要很多细节需要优化：<br>首先是兼容性，这里有两个点涉及到兼容性：<code>document.documentElement.clientHeight</code> 和 <code>document.documentElement.scrollTop</code> 。<br>获取浏览器窗口的内部高度方法有 <code>window.innerHeight</code>、<code>document.documentElement.clientHeight</code>。<br><code>window.innerHeight</code>兼容性是 ie9+ 和其他主流浏览器。<code>document.documentElement.clientHeight</code> 浏览器都支持。</p><p>获取滚动位置方法有 <code>window.pageYOffset</code> 和 <code>document.documentElement.scrollTop</code> 。 <code>window.pageYOffset</code> 兼容性是 ie9+ 和其他主流浏览器。</p><p>第二优化点是offsetTop</p><blockquote><p>offsetParent 元素有滚动条的情况下计算会不会有问题?<strong>HTMLElement.offsetTop</strong> 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部内边距的距离</p></blockquote><p>offsetTop 是相对其 offsetParent 元素的并不是相对浏览器窗口可视区域的。如果图片元素有 offsetParent 那么 offsetTop 是有偏差的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getBoundingClientTop</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> top = el.<span class="property">offsetTop</span>;</span><br><span class="line">  <span class="keyword">let</span> parent = el.<span class="property">offsetParent</span>;</span><br><span class="line">  <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    top += parent.<span class="property">offsetTop</span>;</span><br><span class="line">    parent = parent.<span class="property">offsetParent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三优化点避免赋值 src 。 代码是通过 lazyload 类获取需要懒加载的元素，这样会把之前已经加载图片的元素也获取到了，而重复设置 src属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> lazyImages = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.lazyload[data-src]&quot;</span>);</span><br><span class="line">     lazyImages.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">image</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (</span><br><span class="line">         <span class="title function_">getBoundingClientTop</span>(image) &lt;=</span><br><span class="line">         <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> +</span><br><span class="line">           <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">       ) &#123;</span><br><span class="line">         image.<span class="property">src</span> = image.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">         image.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-src&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过 lazyload 类并且有 data-src 来获取元素，src 设置完后移除 data-src 属性来避免重复设置 src 。</p><p>第四优化点 onscroll 是否添加防抖。<br>onscroll 常用的优化点是加入防抖来减少事件触发的频率，但这里如果加了防抖，计算元素是否在可视区域内的精度就差很多，当滚动速度比较快的情况下加载反应不灵敏，这里就要找平衡点。</p><p>第五优化点页面中局部的 div 滚动图片懒加载。<br>除了整个页面的滚动图片懒加载，也有页面中局部滚动图片懒加载，就需要给制定的有滚动条 dom 元素绑定onscroll 事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">srcollDom.<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">lazyload</span>();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>并且获取图片 top 是相对有滚动条 dom 元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getBoundingClientTop</span>(image)-<span class="title function_">getBoundingClientTop</span>(srcollDom) &lt;= srcollDom.<span class="property">clientHeight</span> + srcollDom.<span class="property">scrollTop</span></span><br></pre></td></tr></table></figure><p>第六优化点加载图片的时间点提前。<br>代码中是图片元素进入可视区域后才加载图片，用户就需要等待一段时间才能看到图片显示出来，如果把图片加载时间提前，图片元素距离可视区域一定范围内就加载图片，那么用户等待时间就会减少一些。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性好，各个环节可以控制。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>性能相对不是很好，滚动事件频繁触发，并且获取元素的位置信息，可能会强行触发重排和重绘导致一定的性能消耗。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="布局抖动"><a href="#布局抖动" class="headerlink" title="布局抖动"></a>布局抖动</h2><p>布局抖动是因为开始图片没有宽高，内容显示出来后有了宽高导致位置变动。带来的影响主要是用户体验不好，用户的注意力已经锁定了某个区域准备阅读，突然那个区域下移了，中断阅读而重新定位。可以直接在 img 标签上设置要加载图片的宽高。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;blank.gif&quot;</span> data-src=<span class="string">&quot;normal.jpg&quot;</span> style=<span class="string">&quot;width:800px;height:600px;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>虽然响应式下图片的宽高会变，但是图片的宽高比是不变的，图片的宽高比变了图片也就变形了。所以 img 标签设定图片宽高比，就能根据不同视图的宽度算出不同高度。 先创建一个宽高比为 5:1 的 div。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;padding-bottom: 20%;background-color: green;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>padding 为百分比是相对自身宽度的百分比。 然后再创建了一个宽高比为 5:1 的 img。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;padding-bottom: 20%;position: relative;&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;width: 100%;height:100%&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样就能适应响应式的宽度改变，这种方式叫 Aspect Ratio Boxes。<br>占位图片可以设置成原图片的小尺寸图片，被放大后图片变模糊，这样开始加载小图片但图片的轮廓出现，后面在加载大图片显示清晰，给用户的体验是图片开始就在加载，然后加载完成就变清晰了。<br>img 标签 srcset 属性是处理响应式图片的。懒加载中可以设置 data-srcset 来延迟修改 srcset 属性。</p><h2 id="SEO不友好"><a href="#SEO不友好" class="headerlink" title="SEO不友好"></a>SEO不友好</h2><p><code>&lt;img&gt;</code> 标签中的 src 属性携带的仍然是原始大小的图片确保了站外 SEO、社会化分享、RSS 等不会读不到原图。Aspect Ratio Boxes 方式使占位图片适应响应式，srcset 属性存放了一张原图的小尺寸缩略图阻止 src 原图的加载而加载缩略图优化加载体验，最后延迟将 data-srcset 的值赋值到 srcset 中。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul><li><a href="https://link.juejin.cn/?target=https://github.com/tuupola/lazyload" title="https://github.com/tuupola/lazyload">lazyload.js</a><br>是 IntersectionObserver 方式，而且当浏览器不支持 IntersectionObserver 的时候就直接加载图片，没有延迟加载的功能。</li><li><a href="https://link.juejin.cn/?target=https://github.com/hilongjw/vue-lazyload" title="https://github.com/hilongjw/vue-lazyload">vue-lazyload</a><br>使用 IntersectionObserver 和 getBoundingClientRect 方式，默认 getBoundingClientRect 方式懒加载，里面的一些封装细节有很多有意思的地方，不止绑定了 onscroll 事件还绑定了 ‘onwheel’、’onmousewheel’、’onresize’、 ‘onanimationend’、’ontransitionend’、’ontouchmove’问什么要绑定这么多事件，插件为什么默认 getBoundingClientRect 方式而不用 IntersectionObserver 方式。</li><li><a href="https://link.juejin.cn/?target=https://github.com/twobin/react-lazyload" title="https://github.com/twobin/react-lazyload">react-lazyload</a><br>只用了 getBoundingClientRect 方式。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、token</title>
      <link href="/2023/04/04/cookie%E3%80%81session%E3%80%81token/"/>
      <url>/2023/04/04/cookie%E3%80%81session%E3%80%81token/</url>
      
        <content type="html"><![CDATA[<h1 id="session，cookie和token究竟是什么"><a href="#session，cookie和token究竟是什么" class="headerlink" title="session，cookie和token究竟是什么"></a><strong>session，cookie和token究竟是什么</strong></h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>cookie，session，token作为面试必问题，很多同学能答个大概，但是又迷糊不清，希望本篇文章对大家有所帮助</p><h2 id="http是一个无状态协议"><a href="#http是一个无状态协议" class="headerlink" title="http是一个无状态协议"></a><strong>http是一个无状态协议</strong></h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a><strong>cookie和session</strong></h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li><p>首先，客户端会发送一个http请求到服务器端。</p></li><li><p>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解<br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p></li><li><p>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</p></li><li><p>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</p><p><img src="1.png" alt="1680574215469"></p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="cookie和session通俗小结"><a href="#cookie和session通俗小结" class="headerlink" title="cookie和session通俗小结"></a><strong>cookie和session通俗小结</strong></h3><p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p><h2 id="token定义"><a href="#token定义" class="headerlink" title="token定义"></a><strong>token定义</strong></h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存<a href="https://cloud.tencent.com/solution/tb-digitalid?from=20065&from_column=20065">身份认证</a>相关的数据。</p><h3 id="token组成"><a href="#token组成" class="headerlink" title="token组成"></a><strong>token组成</strong></h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放"><a href="#存放" class="headerlink" title="存放"></a><strong>存放</strong></h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><h3 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a><strong>token认证流程</strong></h3><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h2 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a><strong>token可以抵抗csrf，cookie+session不行</strong></h2><p>因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h2 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a><strong>分布式情况下的session和token</strong></h2><p>我们已经知道session是有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种解决session负载均衡的方法。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><p><strong>补充:JWT</strong></p><p>JWT就是token的一种实现方式，并且基本是java web领域的事实标准。</p><p>JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输token</p><p>JWT 由 3 部分构成:</p><p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。流程：</p><p>在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，</p><p>然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: 你的Token。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS、XSRF</title>
      <link href="/2023/03/23/XSS%E3%80%81XSRF/"/>
      <url>/2023/03/23/XSS%E3%80%81XSRF/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是XSS？"><a href="#什么是XSS？" class="headerlink" title="什么是XSS？"></a>什么是XSS？</h3><p>跨站脚本（Cross-site scripting，简称为：CSS, 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。</p><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、 LiveScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h3 id="XSS-常见的注入方法："><a href="#XSS-常见的注入方法：" class="headerlink" title="XSS 常见的注入方法："></a>XSS 常见的注入方法：</h3><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><h3 id="XSS常见分类"><a href="#XSS常见分类" class="headerlink" title="XSS常见分类"></a>XSS常见分类</h3><p><strong>反射型（非持久型）XSS</strong> 、 <strong>存储型（持久型）XSS</strong> 、<strong>DOM型XSS</strong></p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS主要是诱导欧诺个户点击一个URL链接，在这个URL链接里就嵌入了恶意脚本，点击URL链接之后，那个URL指向的是黑客自己的服务器上的一段恶意脚本。然后恶意脚本被返回到用户的浏览器里就会运行，然后就可以控制你的浏览器里的行为了，这个控制行为就很恐怖了，他可以干很多的事儿。</p><p>反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，所以它的危害性较存储型要小。</p><p><img src="1.png" alt="1693923770831"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型（或 HTML 注入型/持久型）XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站，不需要特制的链接来执行。黑客仅仅需要利用 XSS 漏洞提交代码（反射型XSS通常只在url中）到一个网站上其他用户可能访问的地方。这些地区可能是 <code>博客评论，用户评论，留言板，聊天室，HTML 电子邮件</code>，和其他的许多地方。一旦用户访问受感染的页，执行是自动的。（比如在评论区文本框输入js恶意代码，这段代码被保存到数据库，用户翻看评论区时就会自动执行这段代码）</p><p><img src="2.png" alt="1693923779947"></p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p><p>DOM型XSS是基于DOM文档对象模型的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使(钓鱼)一名用户访问自己构造的URL，利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM Based XSS Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">xsstest</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>).<span class="property">value</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;img src=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">size</span>=<span class="string">50</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;xsstest()&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="XSS攻击代码出现的场景"><a href="#XSS攻击代码出现的场景" class="headerlink" title="XSS攻击代码出现的场景"></a>XSS攻击代码出现的场景</h3><p>有url（跳转）或者有输入（请求）的地方</p><h3 id="XSS-攻击的预防"><a href="#XSS-攻击的预防" class="headerlink" title="XSS 攻击的预防"></a>XSS 攻击的预防</h3><p><strong>常用防范方法</strong></p><ul><li>httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。</li><li>输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li>转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善。想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库。</li><li>白名单: 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul><h4 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a><strong>预防存储型和反射型 XSS 攻击</strong></h4><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</p><p>预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><p>TML转义前面已经说过,这里仅仅谈谈纯前端渲染</p><p><strong>纯前端渲染的过程：</strong></p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。</p><h4 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a><strong>预防 DOM 型 XSS 攻击</strong></h4><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML、.outerHTML、document.write() </code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code> .textContent、.setAttribute()</code> 等。</p><p>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover </code>等， 标签的 <code>href</code>属性，JavaScript 的 <code>eval()、setTimeout()、setInterval()</code>等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易 产生安全隐患，请务必避免</p><h3 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><p>如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><img src="3.png" alt="1693923887457"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生</p><ul><li>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ul><h3 id="常见的CSRF攻击类型"><a href="#常见的CSRF攻击类型" class="headerlink" title="常见的CSRF攻击类型"></a>常见的CSRF攻击类型</h3><h4 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h4><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt;</span> </span><br></pre></td></tr></table></figure><p>在受害者访问含有这个img的页面后，浏览器会自动向<a href="http://bank.example/withdraw?amount=10000&amp;for=hacker">http://bank.example/withdraw?amount=10000&amp;for=hacker</a> 发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求</p><h4 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h4><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><h4 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h4><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>重磅消息！！<span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险</p><h3 id="CSRF与-XSS-区别"><a href="#CSRF与-XSS-区别" class="headerlink" title="CSRF与 XSS 区别"></a>CSRF与 XSS 区别</h3><ul><li>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</li><li>本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。 XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相关问题</title>
      <link href="/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/23/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="将文章部署到远程仓库不成功时，可能的问题："><a href="#将文章部署到远程仓库不成功时，可能的问题：" class="headerlink" title="将文章部署到远程仓库不成功时，可能的问题："></a>将文章部署到远程仓库不成功时，可能的问题：</h2><p>如果出现下图中的问题，说明未连接到远程仓库</p><p><img src="2.png" alt="1693923650987"></p><p>右键选择Git Bash Here，输入以下命令进行连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/repositoryname.git</span><br></pre></td></tr></table></figure><p>yourName是用户名，repositoryname是仓库名字，地址也可以直接在github中复制</p><p><img src="1.png" alt="1693923682751"></p><p>连接到远程仓库后，重新生成一次ssh key，在Git Hub Here中输入ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#97;&#105;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;">&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#97;&#105;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a>“</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>xxxxxx<a href="mailto:youremail@example.com">@example.com</a>改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key），此时会提醒密钥所在位置，如下图所示</p><p><img src="3.png" alt="1693923740387"></p><p>找到密钥后，复制粘贴到github中：个人头像-setting-SSH and GPG keys</p><p><img src="4.png" alt="1693923720131"></p><p>即可成功部署文章</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型/原型链</title>
      <link href="/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2023/03/15/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a><strong>原型的作用</strong></h2><p>原型被定义为给其它对象提供共享属性的对象，函数的实例可以共享原型上的属性和方法</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>它的作用就是当你在访问一个对象上属性的时候，如果该对象内部不存在这个属性，那么就会去它 <code>__proto__</code>属性所指向的对象（原型对象）上查找。如果原型对象依旧不存在这个属性，那么就会去其原型的 <code>__proto__</code>属性所指向的原型对象上去查找。以此类推，直到找到 <code>null</code>，而这个查找的线路，也就构成了我们常说的<strong>原型链</strong></p><p><strong>原型链和作用域的区别：</strong> 原型链是查找对象上的属性，作用域链是查找当前上下文中的变量</p><h2 id="proto-、prototype、constructor属性介绍"><a href="#proto-、prototype、constructor属性介绍" class="headerlink" title="proto 、prototype、constructor属性介绍"></a><strong>proto</strong> 、prototype、constructor属性介绍</h2><ol><li>js中对象分为两种，普通对象和函数对象</li><li><code>__proto__</code>和 <code>constructor</code>是对象独有的。<code>prototype</code>属性是函数独有的，它的作用是包含可以给特定类型的所有实例提供共享的属性和方法；但是在 JS 中，函数也是对象，所以函数也拥有 <code>__proto__</code>和 <code>constructor</code>属性</li><li><code>constructor</code>属性是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数 <code>构造函数.prototype.constructor === 该构造函数本身</code></li><li>一个对象的 <code>__proto__</code>指向其构造函数的 <code>prototype</code>,<code>函数创建的对象.__proto__ === 该函数.prototype</code></li><li>特殊的 <code>Object</code>、<code>Function</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Function</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 的基本用法，它可以判断一个对象的原型链上是否包含该构造函数的原型，经常用来判断对象是否为该构造函数的实例</p><p><strong>特殊示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>手写instanceof方法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">obj, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = obj.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === fn.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">instanceOf</span>(proto, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(dog, <span class="title class_">Dog</span>), <span class="title function_">instanceOf</span>(dog, <span class="title class_">Object</span>)); <span class="comment">// true true</span></span><br></pre></td></tr></table></figure><h2 id="instanceof与typeof的区别"><a href="#instanceof与typeof的区别" class="headerlink" title="instanceof与typeof的区别"></a><strong>instanceof与typeof的区别</strong></h2><p>1）<code>typeof</code>一般被用于来判断一个变量的类型</p><p>typeof可以用来判断 <code>number、undefined、symbol、string、function、boolean、object</code> 这七种数据类型，特殊情况：<code>typeof null === &#39;object&#39;</code></p><p>2）<code>instanceof</code>判断一个对象的原型链上是否包含该构造函数的原型</p><h2 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h2><p><strong>new一个对象，到底发生什么？</strong></p><p>1）创建一个对象，该对象的原型指向构造函数的原型</p><p>2）调用该构造函数，构造函数的this指向新生成的对象</p><p>3）判断构造函数是否有返回值，如果有返回值且返回值是一个对象或一个方法，则返回该值；否则返回新生成的对象</p><p><strong>构造函数有返回值的案例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">test</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;ming&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;test:1&#125; </span></span><br></pre></td></tr></table></figure><p><strong>手写new</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selfNew(fn, ...args) &#123;</span><br><span class="line">  // 创建一个instance对象，该对象的原型是fn.prototype</span><br><span class="line">  let instance = Object.create(fn.prototype);</span><br><span class="line">  // 调用构造函数，使用apply，将this指向新生成的对象</span><br><span class="line">  let res = fn.apply(instance, args);</span><br><span class="line">  // 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象</span><br><span class="line">  return typeof res === &quot;object&quot; || typeof res === &quot;function&quot; ? res : instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>多种继承方式</strong></p><p>1）原型链继承，缺点：引用类型的属性被所有实例共享<br>2）借用构造函数（经典继承）<br>3）原型式继承<br>4）寄生式继承<br>5）组合继承<br>6）寄生组合式继承</p><p><strong>寄生组合式继承的优势</strong></p><p>优势：借用父类的构造函数，在不需要生成父类实例的情况下，继承了父类原型上的属性和方法</p><p><strong>手写寄生组合式继承</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精简版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 利用Object.create生成一个对象，新生成对象的原型是父类的原型，并将该对象作为子类构造函数的原型，继承了父类原型上的属性和方法</span></span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="comment">// 原型对象的constructor指向子类的构造函数</span></span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="comment">// 目的是为了继承父类原型上的属性和方法，在不需要实例化父类构造函数的情况下，避免生成父类的实例，如new Parent()</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="comment">// 创建一个空对象，该对象原型指向父类的原型对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Child.prototype = Object.create(Parent.prototype)</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">createObj</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">child.<span class="title function_">getName</span>(); <span class="comment">// tom</span></span><br></pre></td></tr></table></figure><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p><strong>Class 类可以看作是构造函数的语法糖</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Point</span>); <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Point</span> === <span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>Class 类中定义的方法，都是定义在该构造函数的原型上</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;, <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>static</code>关键字，作为静态方法</strong>（静态方法，只能通过类调用，实例不能调用）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">classMethod</span>(); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>实例属性的简写写法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  bar = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  baz = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">baz</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>extends</code> 关键字，底层是利用的寄生组合式继承</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;li&quot;</span>, <span class="number">16</span>);</span><br><span class="line">child.<span class="title function_">getName</span>(); <span class="comment">// li</span></span><br></pre></td></tr></table></figure><p>ES6的 Class 内部是基于寄生组合式继承，它是目前最理想的继承方式<br>ES6的 Class 允许子类继承父类的静态方法和静态属性</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/03/15/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/15/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包：就是函数引用了外部作用域的变量</strong></p><p><strong>闭包常见的两种情况：</strong></p><p>一是函数作为返回值； 另一个是函数作为参数传递</p><p><strong>闭包的作用：</strong></p><p>可以让局部变量的值始终保持在内存中；对内部变量进行保护，使外部访问不到</p><p>最常见的案例：<code>函数节流和防抖</code></p><p><strong>闭包的垃圾回收：</strong></p><p>副作用：不合理的使用闭包，会造成内存泄露(就是该内存空间使用完毕之后未被回收)</p><p>闭包中引用的变量直到闭包被销毁时才会被垃圾回收</p><p><strong>闭包的示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始题目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1s后打印出5个5</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬅️利用闭包，将上述题目改成1s后，打印0,1,2,3,4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="comment">// 利用setTimeout的第三个参数，第三个参数将作为setTimeout第一个参数的参数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>, i); <span class="comment">// 第三个参数i,将作为fn的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬅️将上述题目改成每间隔1s后，依次打印0,1,2,3,4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span> * i, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2023/03/15/this/"/>
      <url>/2023/03/15/this/</url>
      
        <content type="html"><![CDATA[<h1 id="this的5种绑定方式"><a href="#this的5种绑定方式" class="headerlink" title="this的5种绑定方式"></a><strong>this的5种绑定方式</strong></h1><p>1）默认绑定(非严格模式下this指向全局对象，严格模式下函数内的this指向 <code>undefined</code>)</p><p>2）隐式绑定(当函数引用有上下文对象时, 如 <code>obj.foo()</code>的调用方式, foo内的this指向obj)</p><p>3）显示绑定(通过call或者apply方法直接指定this的绑定对象, 如 <code>foo.call(obj)</code>)</p><p>4）new构造函数绑定，this指向新生成的对象</p><p>5）箭头函数，this指向的是定义该函数时，外层环境中的this，<strong>箭头函数的this在定义时就决定了，不能改变</strong></p><p><strong>this 题目1</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var a = 10; // var定义的a变量挂载到window对象上</span><br><span class="line">function foo () &#123;</span><br><span class="line">  console.log(&#x27;this1&#x27;, this)  // undefined</span><br><span class="line">  console.log(window.a)  // 10</span><br><span class="line">  console.log(this.a)  //  报错，Uncaught TypeError: Cannot read properties of undefined (reading &#x27;a&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;this2&#x27;, this)  // window</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>注意：开启了严格模式，只是使得函数内的this指向 <code>undefined</code>，它并不会改变全局中this的指向。因此 <code>this1</code>中打印的是 <code>undefined</code>，而 <code>this2</code>还是 <code>window</code>对象。</p><p><strong>this 题目2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 10</span><br><span class="line">const b = 20</span><br><span class="line">function foo () &#123;</span><br><span class="line">  console.log(this.a)  // undefined</span><br><span class="line">  console.log(this.b)  // undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">console.log(window.a) // undefined  </span><br></pre></td></tr></table></figure><p>如果把 var 改成了 let 或 const，变量是不会被绑定到window上的，所以此时会打印出三个undefined</p><p><strong>this 题目3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function foo () &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  console.log(this)  // window</span><br><span class="line">  console.log(this.a) // 1</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>foo()函数内的this指向的是window，因为是window调用的foo，打印出的 <code>this.a</code>是window下的 <code>a</code></p><p><strong>this 题目4</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj2 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    foo1: function () &#123;</span><br><span class="line">      console.log(this.a) // 2</span><br><span class="line">    &#125;,</span><br><span class="line">    foo2: function () &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        console.log(this) // window</span><br><span class="line">        console.log(this.a) // 3</span><br><span class="line">      &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var a = 3</span><br><span class="line">  </span><br><span class="line">  obj2.foo1()</span><br><span class="line">  obj2.foo2() </span><br></pre></td></tr></table></figure><p>对于 <code>setTimeout</code>中的函数，这里存在隐式绑定的this丢失，也就是当我们将函数作为参数传递时,会被隐式赋值，回调函数丢失this绑定，因此这时候setTimeout中函数内的this是指向 <code>window</code></p><p><strong>this 题目5</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line"> <span class="attr">foo1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// window</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// obj</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// obj</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line">obj.<span class="title function_">foo1</span>()</span><br><span class="line">obj.<span class="title function_">foo2</span>()()</span><br></pre></td></tr></table></figure><p>这道题非常经典，它证明了<strong>箭头函数内的this是由外层作用域决定的</strong></p><p><strong>题目5解析：</strong></p><p>1）对于 <code>obj.foo1()</code>函数的调用，它的外层作用域是window，对象obj当然不属于作用域了(作用域只有全局作用域、函数作用域、块级作用域)，所以会打印出 <code>window</code></p><p>2）<code>obj.foo2()()</code>，首先会执行 <code>obj.foo2()</code>，这不是个箭头函数，所以它里面的this是调用它的obj对象，因此第二个打印为 <code>obj</code>，而返回的匿名函数是一个箭头函数， <strong>它的this由外层作用域决定</strong> ，那也就是它的this会和foo2函数里的this一样，第三个打印也是 <code>obj</code></p><h1 id="call-apply-bind三者的区别"><a href="#call-apply-bind三者的区别" class="headerlink" title="call apply bind三者的区别"></a>call apply bind三者的区别</h1><ol><li>三者都可以显式绑定函数的this指向</li><li>三者第一个参数都是this要指向的对象，若该参数为undefined或null，this则默认指向全局window传参不同：apply是数组、call是参数列表，而bind可以分为多次传入，实现参数的合并</li><li>call、apply是立即执行，bind是返回绑定this之后的函数，如果这个新的函数作为构造函数被调用，那么this不再指向传入给bind的第一个参数，而是指向新生成的对象</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var_let_const</title>
      <link href="/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/03/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h1><h2 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h2><ol><li>var定义的变量，没有块的概念，可以跨块访问, 可以变量提升</li><li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明</li><li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明</li></ol><p><strong>let和const声明的变量只在块级作用域内有效，示例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 报错 &quot;i is not defined&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><h2 id="var与let的经典案例"><a href="#var与let的经典案例" class="headerlink" title="var与let的经典案例"></a>var与let的经典案例</h2><p>用var定义i变量，循环后打印i的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例1</span></span><br><span class="line"><span class="comment">// i是var声明的，在全局范围内都有效，全局只有一个变量i，输出的是最后一轮的i值，也就是 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>用let定义i变量，循环后打印i的值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例2</span></span><br><span class="line"><span class="comment">// 用let声明i，for循环体内部是一个单独的块级作用域，相互独立，不会相互覆盖</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="let-实现原理"><a href="#let-实现原理" class="headerlink" title="let 实现原理"></a>let 实现原理</h2><p><strong>借助闭包和函数作用域来实现块级作用域的效果</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用var实现案例2的效果</span><br><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">var _loop = function _loop(i) &#123;</span><br><span class="line">  a[i] = function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  _loop(i);</span><br><span class="line">&#125;</span><br><span class="line">a[0](); // 0</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域：可访问变量的集合</p><p>作用域最大的用处就是 <code>隔离变量</code>，不同作用域下同名变量不会有冲突</p><h2 id="作用域类型"><a href="#作用域类型" class="headerlink" title="作用域类型"></a>作用域类型</h2><p><code>全局作用域</code>、<code>函数作用域</code>、ES6中新增了 <code>块级作用域</code></p><p><strong>函数作用域</strong></p><p>是指声明在函数内部的变量，函数的作用域在函数定义的时候就决定了</p><p><strong>块作用域</strong></p><p>1）块作用域由 <code>&#123; &#125;</code>包括，if和for语句里面的 <code>&#123; &#125;</code>也属于块作用域</p><p>2）在块级作用域中，可通过let和const声明变量，该变量在指定块的作用域外无法被访问</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当查找变量的时候，首先会先从当前上下文的变量对象（作用域）中查找，如果没有找到，就会从父级的执行上下文的变量对象中查找，如果还没有找到，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 <code>作用域链</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3</title>
      <link href="/2023/03/13/vue3/"/>
      <url>/2023/03/13/vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3新特性"><a href="#Vue3新特性" class="headerlink" title="Vue3新特性"></a>Vue3新特性</h1><h2 id="Vue2的核心模块和历史遗留问题"><a href="#Vue2的核心模块和历史遗留问题" class="headerlink" title="Vue2的核心模块和历史遗留问题"></a>Vue2的核心模块和历史遗留问题</h2><p>从下图可以看到，Vue2是一个响应式驱动的、内置虚拟DOM、组件化、用在浏览器开发，并且有一个运行时把这些模块很好地管理起来的框架。</p><p><img src="1.png" alt="1693814916837"></p><p>Vue 2 能把上面所说的这些模块很好地管理起来，看起来已经足够好了。不过事实真的如此么？Vue 2 还是有缺陷的，所以后面才会升级迭代。</p><p>下面列举了一些 Vue 2 常见的缺陷，可以对照你的实际开发经验，看看是否也遇到过这些问题：</p><p>首先从开发维护的角度看，Vue 2 是使用 Flow.js 来做类型校验。但现在 Flow.js 已经停止维护了，整个社区都在全面使用 TypeScript 来构建基础库，Vue 团队也不例外。</p><p>然后从社区的二次开发难度来说，Vue 2 内部运行时，是直接执行浏览器 API 的。但这样就会在 Vue 2 的跨端方案中带来问题，要么直接进入 Vue 源码中，和 Vue 一起维护，比如 Vue 2 中你就能见到 Weex 的文件夹。要么是要直接改为复制一份全部 Vue 的代码，把浏览器 API 换成客户端或者小程序的。比如 mpvue 就是这么做的，但是 Vue 后续的更新就很难享受到。</p><p>最后从我们普通开发者的角度来说，Vue 2 响应式并不是真正意义上的代理，而是基于 Object.defineProperty() 实现的，这个 API 并不是代理，而是对某个属性进行拦截，所以有很多缺陷，比如：删除数据就无法监听，需要 $delete 等 API 辅助才能监听到。</p><p>并且，Option API 在组织代码较多组件的时候不易维护。对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，这对小应用来说还好。但代码超过 300 行的时候，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。</p><h2 id="从七个方面了解Vue3新特性"><a href="#从七个方面了解Vue3新特性" class="headerlink" title="从七个方面了解Vue3新特性"></a>从七个方面了解Vue3新特性</h2><p>前面这些问题并不是 Vue 2 有意为之，大部分是发展的过程中碰见的。Vue 3 就是继承了 Vue 2 具有的响应式、虚拟 DOM，组件化等所有优秀的特点，并且全部重新设计，解决了这些历史包袱的新框架，是一个拥抱未来的前端框架。接下来我们就来具体看看 Vue 3 新特性，其中，响应式系统、Composition API 组合语法、新的组件和 Vite 是你需要重视的；自定义渲染器这方面的知识，你想用 Vue 开发跨端应用时会用到；如果你想对 Vue 源码作出贡献，RFC 机制你也需要好好研究，并且得对 TypeScript 重构有很好的经验。</p><h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的，此外，Vue 还使用了 Proxy，这两者看起来都像是对数据的读写进行拦截，但是 defineProperty 是拦截具体某个属性，Proxy 才是真正的“代理”。怎么理解这两者的区别呢？我们首先看 defineProperty 这个 API，defineProperty 的使用，要明确地写在代码里，下面是示例代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;title&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当项目里“读取 obj.title”和“修改 obj.title”的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。而且，如果 title 是一个数组的时候，对数组的操作，并不会改变 obj.title 的指向，虽然我们可以通过拦截.push 等操作实现部分功能，但是对数组的长度的修改等操作还是无法实现拦截，所以还需要额外的 $set 等 API。而 Proxy 这个 API 就是真正的代理了，我们先看它的用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然 Proxy 拦截 obj 这个数据，但 obj 具体是什么属性，Proxy 则不关心，统一都拦截了。而且 Proxy 还可以监听更多的数据格式，比如 Set、Map，这是 Vue 2 做不到的。当然，Proxy 存在一些兼容性问题，这也是为什么 Vue 3 不兼容 IE11 以下的浏览器的原因，还好现在 IE 用的人不多了。更重要的是，我觉得 Proxy 代表一种方向，就是框架会越来越多的拥抱浏览器的新特性。在 Proxy 普及之前，我们是没有办法完整的监听一个 JavaScript 对象的变化，只能使用 Object.defineProperty() 去实现一部分功能。前端框架利用浏览器的新特性来完善自己，才会让前端这个生态更繁荣，抛弃旧的浏览器是早晚的事。</p><h3 id="Composition-API组合语法"><a href="#Composition-API组合语法" class="headerlink" title="Composition API组合语法"></a>Composition API组合语法</h3><p>先举个 Vue 2 中的简单例子，一个累加器，并且还有一个计算属性显示累加器乘以 2 的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>&#123;&#123;count&#125;&#125; * 2 = &#123;&#123;double&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> <span class="title class_">App</span> = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>:<span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">count</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">double</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>*<span class="number">2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在 Vue 3 中，采用下方的写法，新增一个 setup 配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>&#123;&#123;state.count&#125;&#125; * 2 = &#123;&#123;double&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> &#123;reactive,computed&#125; = <span class="title class_">Vue</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> <span class="title class_">App</span> = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">count</span>:<span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      state.<span class="property">count</span>++</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>state.<span class="property">count</span>*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;state,add,double&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用 Composition API 后，代码看起来很烦琐，没有 Vue 2 中 Options API 的写法简单好懂，但 Options API 的写法也有几个很严重的问题：</p><p>由于所有数据都挂载在 this 之上，因而 Options API 的写法对 TypeScript 的类型推导很不友好，并且这样也不好做 Tree-shaking 清理代码。新增功能基本都得修改 data、method 等配置，并且代码上 300 行之后，会经常上下反复横跳，开发很痛苦。代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用 mixin，还会带来命名冲突的问题。我们使用 Composition API 后，虽然看起来烦琐了一些，但是带来了诸多好处：所有 API 都是 import 引入的（现在我们的例子还没有工程化，后续会加入）。用到的功能都 import 进来，对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小。不再上下反复横跳，我们可以把一个功能模块的 methods、data 都放在一起书写，维护更轻松。代码方便复用，可以把一个功能所有的 methods、data 封装在一个独立的函数里，复用代码非常容易。Composotion API 新增的 return 等语句，在实际项目中使用 <code>&lt;script setup&gt;</code>特性可以清除。</p><p>Composition API 对我们开发 Vue 项目起到了巨大的帮助。下面这个示例图很好地说明了问题：每一个功能模块的代码颜色一样，左边是 Options API，一个功能的代码零散的分布在 data，methods 等配置内，维护起来很麻烦，而右边的 Compositon API 就不一样了，每个功能模块都在一起维护。</p><p><img src="2.png" alt="1693818512182"></p><p>其实还可以更进一步，如果每个颜色块代码，我们都拆分出去一个函数，我们就会写出类似上面右侧风格的代码，每个数据来源都清晰可见，而且每个功能函数都可以在各个地方复用。</p><h3 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h3><p>Vue 3 内置了 Fragment、Teleport 和 Suspense 三个新组件。</p><ul><li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li><li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li><li>Suspense: 异步组件，更方便开发有异步请求的组件。</li></ul><h3 id="新一代工程化工具Vite"><a href="#新一代工程化工具Vite" class="headerlink" title="新一代工程化工具Vite"></a>新一代工程化工具Vite</h3><p>Vite 不在 Vue 3 的代码包内，和 Vue 也不是强绑定，Vite 的竞品是 Webpack，而且按照现在的趋势看，使用率超过 Webpack 也是早晚的事。</p><p>Vite 主要提升的是开发的体验，Webpack 等工程化工具的原理，就是根据你的 import 依赖逻辑，形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试。</p><p>由于要预打包，所以复杂项目的开发，启动调试环境需要 3 分钟都很常见，Vite 就是为了解决这个时间资源的消耗问题出现的。现代浏览器已经默认支持了 ES6 的 import 语法，Vite 就是基于这个原理来实现的。具体来说，在调试环境下，我们不需要全部预打包，只是把你首页依赖的文件，依次通过网络请求去获取，整个开发体验得到巨大提升，做到了复杂项目的秒级调试和热更新。</p><p>下图展示了 Webpack 的工作原理，Webpack 要把所有路由的依赖打包后，才能开始调试</p><p><img src="3.png" alt="1693818710537"></p><p>下图所示的是 Vite 的工作原理，一开始就可以准备联调，然后根据首页的依赖模块，再去按需加载，这样启动调试所需要的资源会大大减少。</p><p><img src="4.png" alt="1693818746076"></p><h3 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h3><p>Vue 2 内部所有的模块都是揉在一起的，这样做会导致不好扩展的问题，刚才我也提到了这一点。Vue 3 是怎么解决这个问题的呢？那就是拆包，使用最近流行的 monorepo 管理方式，响应式、编译和运行时全部独立了，变成下图所示的模样</p><p><img src="5.png" alt="1693818956818"></p><p>可以看到，在 Vue 3 的组织架构中，响应式独立了出来。而 Vue 2 的响应式只服务于 Vue，Vue 3 的响应式就和 Vue 解耦了，你甚至可以在 Node.js 和 React 中使用响应式。</p><p>渲染的逻辑也拆成了平台无关渲染逻辑和浏览器渲染 API 两部分 。</p><p>在这个架构下，Node 的一些库，甚至 React 都可以依赖响应式。</p><p>在任何时候，如果你希望数据被修改了之后能通知你，你都可以单独依赖 Vue 3 的响应式。那么，在你想使用 Vue 3 开发小程序、开发 canvas 小游戏以及开发客户端的时候，就不用全部 fork Vue 的代码，只需要实现平台的渲染逻辑就可以</p><p><img src="6.png" alt="1693819037466"></p><p>就像动画片《战神金刚》，五个机器人可以独立执行任务，但关键时刻，高呼一声“我来组成头部”，就可以合体，从而发挥整体的作用。Vue 3 也是一样，响应式、编译和运行时几部分组合在一起就是运行在浏览器端的 Vue 3，每个模块又都可以独立扩展出新的功能。</p><h3 id="全部模块使用TypeScript重构"><a href="#全部模块使用TypeScript重构" class="headerlink" title="全部模块使用TypeScript重构"></a>全部模块使用TypeScript重构</h3><p> JavaScript 是弱类型的语言。，类型系统带来了更方便的提示，并且让我们的代码能够更健壮。我们还是结合例子来看看，在下面这段代码中，我们首先定义了 name 这个变量，在定义的时候标记的是一个字符串，因而后面给它赋值时，赋值为数字就会报错。之后，我们定义一个类型 Person，里面的变量 name 是字符串类型，变量 age 是数字类型。违反这个设置的数据就报错，这在多人协同和长期维护的项目里带来的收益是巨大的，因为这样可以使错误的代码在编译阶段就被发现，从而避免程序上线运行后，可能会发生的更大的异常错误。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span> = <span class="string">&#x27;我是个靓仔&#x27;</span></span><br><span class="line">name = <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">me</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;靓仔圣&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">me.<span class="property">age</span> = <span class="string">&#x27;整条街&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>所以大部分开源的框架都会引入类型系统，来对 JavaScript 进行限制。这样做的原因，就是我们前面提到的两点：第一点是，类型系统带来了更方便的提示；第二点是，类型系统让代码更健壮。Vue 2 那个时代基本只有两个技术选型，Facebook 家的 Flow.js 和微软家的 TypeScript。Vue 2 选 Flow.js 没问题，但是现在 Flow.js 被抛弃了。Vue 3 选择了 TypeScript，TypeScript 官方也对使用 TypeScript 开发 Vue 3 项目的团队也更加友好</p><h3 id="RFC机制"><a href="#RFC机制" class="headerlink" title="RFC机制"></a>RFC机制</h3><p>Vue 3 的第一个新特性和代码无关，而是 Vue 团队开发的工作方式。</p><p>关于 Vue 的新语法或者新功能的讨论，都会先在 GitHub 上公开征求意见，邀请社区所有的人一起讨论， 你随时可以打开这个项目<a href="">https://github.com/vuejs/rfcs</a>。Vue 3 正在讨论中的新需求，任何人都可以围观、参与讨论和尝试实现。这个改变让 Vue 社区更加有活力。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们再来对Vue 3 主要的新特性做一个回顾：</p><ul><li>新的 RFC 机制也让我们所有人都可以参与 Vue 新语法的讨论。</li><li>工程化工具 Vite 带来了更丝滑的调试体验。对于产品的最终效果来看，Vue 3 性能更高，体积更小。</li><li>对于普通开发者来说，Composition API 组合语法带来了更好的组织代码的形式。全新的响应式系统基于 Proxy，也可以独立使用。Vue 3 内置了新的 Fragment、Teleport 和 Suspense 等组件。</li><li>对于 Vue 的二次开发来说，自定义渲染器让我们开发跨端应用时更加得心应手。</li><li>对于 Vue 的源码维护者，全部的模块使用 TypeScript 重构，能够带来更好的可维护性。</li></ul><p>简而言之，Vue 3 带给我们的就是更快、更强且更易于扩展的开发体验，我们也可以用下面这个图来做个总结：</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS注意点</title>
      <link href="/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2023/03/13/CSS%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><h3 id="怎么创建BFC"><a href="#怎么创建BFC" class="headerlink" title="怎么创建BFC"></a>怎么创建BFC</h3><ol><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block、table-cell、table-caption、flex、inline-flex</li><li>overflow不为visible</li></ol><blockquote><p>虽然添加上述的任意一条都能创建BFC，但会有一些副作用</p></blockquote><ol><li>float: left 将把元素移至左侧，并被其他元素环绕</li><li>display: table 可能引发响应性问题</li><li>overflow: scroll 可能产生多余的滚动条</li></ol><p><strong>最常用是overflow为hidden，这种方式的副作用最小，其他三种方式的副作用较大</strong></p><h3 id="BFC中盒子怎么对齐"><a href="#BFC中盒子怎么对齐" class="headerlink" title="BFC中盒子怎么对齐"></a>BFC中盒子怎么对齐</h3><p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。</p><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>常规流布局时，盒子都是垂直排列，两者之间的间距由各自的外边距所决定，但不是二者外边距之和。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//对应的CSS</span></span><br><span class="line">.<span class="property">container</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: red;</span><br><span class="line">  <span class="attr">overflow</span>: hidden; <span class="comment">/* creates a block formatting context */</span></span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">  background-<span class="attr">color</span>: lightgreen;</span><br><span class="line">  <span class="attr">margin</span>: 10px <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果图：</p><p><img src="1.PNG" alt="1678677743829"></p><p>在上图中，一个红盒子（div）包含着两个兄弟元素（p），一个BFC已经创建了出来。</p><p>理论上，两个p元素之间的外边距应当是二者外边距之和（20px）但实际上却是10px，这是外边距折叠(Collapsing Margins)的结果。</p><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果按照如下规则计算：</p><ol><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ol><p>产生折叠的必备条件：margin必须是邻接的!</p><h2 id="sticky-粘性布局"><a href="#sticky-粘性布局" class="headerlink" title="sticky 粘性布局"></a>sticky 粘性布局</h2><p><code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是 <code>position:relative</code>和 <code>position:fixed</code>的结合体——当元素在屏幕内，表现为 <code>relative</code>，就要滚出显示器屏幕的时候，表现为 <code>fixed</code></p><p><img src="sticky-layout-s.gif" alt="1678679237721"></p><p>正如大家看到，随着页面的滚动，当导航距离上边缘0距离的时候，黏在了上边缘，表现如同 <code>position:fixed</code>。</p><p>这就是 <code>position:sticky</code>最基本的表现，特别适合导航的跟随定位效果。</p><h3 id="position-sticky"><a href="#position-sticky" class="headerlink" title="position:sticky"></a>position:sticky</h3><p><code>position:sticky</code>有个非常重要的特性，那就是 <strong>sticky元素效果完全受制于父级元素们</strong> 。</p><p>这和 <code>position:fixed</code>定位有着根本性的不同，fixed元素直抵页面根元素，其他父元素对其left/top定位无法限制。</p><p><strong>发现了sticky元素一些特性表现：</strong></p><ol><li>父级元素不能有任何 <code>overflow:visible</code>以外的overflow设置，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）。因此，如果你的 <code>position:sticky</code>无效，看看是不是某一个祖先元素设置了 <code>overflow:hidden</code>，移除之即可。</li><li>父级元素设置和粘性定位元素等高的固定的 <code>height</code>高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果。</li><li>同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，且这些父元素正好紧密相连，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li><li>sticky定位，不仅可以设置 <code>top</code>，基于滚动容器上边缘定位；还可以设置 <code>bottom</code>，也就是相对底部粘滞。如果是水平滚动，也可以设置 <code>left</code>和 <code>right</code>值。</li></ol><h3 id="层次滚动实现原理"><a href="#层次滚动实现原理" class="headerlink" title="层次滚动实现原理"></a>层次滚动实现原理</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>网曝王宝强殴打马蓉<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">content</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>12月2日，有网友爆料称...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>网友评论：...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>知情人爆料称马蓉闯入王宝强家拿剪刀对峙<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">content</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>网友评论：...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">h4</span>, </span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">50vh</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每一段短新闻都在section标签中，属于不同的父元素，因此，滚动的时候，后面的新闻标题才能把前面已经sticky定位的新闻标题推开，这是sticky定位天然的特性，无需任何JavaScript的帮助。所以，<code>position:sticky</code>布局的时候，使用合适的HTML结构很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2023/03/10/nodejs/"/>
      <url>/2023/03/10/nodejs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nodejs.dev/en/">nodejs文档</a></p><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程（厂房）：程序运行的环境</li><li>线程（工人）：实行进行运算的东西</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>通常情况代码都是自上而下一行一行执行的，前面的代码不执行后面的也不会执行，同步的代码执行会出现阻塞的情况，一行代码执行慢会影响整个程序的执行。</p><h3 id="解决同步"><a href="#解决同步" class="headerlink" title="解决同步"></a>解决同步</h3><p>java、python 通过多线程来解决，成本高</p><p>node.js 通过异步方式解决</p><p>异步：一段代码的执行不会影响其它代码</p><ul><li>异步的问题：无法通过return设置返回值</li><li>特点：不会阻塞其它代码的执行，需要通过回调函数来返回结果</li></ul><p>基于回调函数的异步带来的问题：代码可读性差，可调试性差（回调地狱）</p><p>解决问题：需要一个东西，可以代替回调函数来返回结果：Promise</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是一个可以用来存储数据的对象，存取数据的方式比较特殊，这种特殊的方式使得Promise可以用来存储异步调用的数据</p><ul><li>创建promise时，构造函数中需要一个函数作为参数。</li><li>resolve,reject是两个函数，通过这两个函数向promise中存储数据，resolve在执行正常时存储数据，reject在执行错误时存储数据</li><li>通过函数向promise中添加数据的好处就是可以用来添加异步调用的数据</li><li>通过promise的实例方法then来读取promise中存储的数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="promise实例的方法"><a href="#promise实例的方法" class="headerlink" title="promise实例的方法"></a>promise实例的方法</h3><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then需要两个回调函数作为参数，回调函数用来获取promise中的数据。通过resolve存储的数据，会调用第一个函数返回，可以在第一个函数中编写处理数据的代码；通过reject存储的数据或者出现异常时，会调用第二个函数返回，可以在第二个函数中编写处理异常的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise中的数据&quot;</span>,result)</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据&quot;</span>,reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><ul><li>catch()用法和then类似，但是只需要一个回调函数作为参数</li><li>catch()中的回调函数只会在promise被拒绝时调用，catch()相当于then(null,reason=&gt;{})，是一个专门处理promise异常的方法</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>finally()无论是正常存储还是出现异常了，都会执行</li><li>finally的回调函数中不会接收到数据，通常用来编写一些无论成功与否都要执行的代码</li></ul><h4 id="promise实例的方法总结"><a href="#promise实例的方法总结" class="headerlink" title="promise实例的方法总结"></a>promise实例的方法总结</h4><ul><li>then、catch会返回一个新的promise，promise中会存储回调函数的返回值（为什么是promise：为了返回数据）</li><li>finally的返回值不会存到新的promise中</li></ul><h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>Promise中维护了两个隐藏属性：</p><ul><li>PromiseResult: 用来存储数据</li><li>PromiseState: 记录promise的状态，只能修改一次，修改以后永远不会再变<br>fulfilled（完成）：通过resolve存储数据时<br>rejected（拒绝，出错了）：通过reject存储数据或者出错了<br>pending（进行中）</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当promise创建时，PromiseState的初始值为pending，当通过resolve存储数据时，PromiseState变为fulfilled，PromiseResult变为存储的数据。当通过reject存储数据时，PromiseState变为rejected，PromiseResult变为存储的数据或异常对象（错误信息）<br>当通过then读取数据时，相当于为promise设置了回调函数（监听），如果PromiseState变为fulfilled，则调用then的第一个回调来返回数据；如果PromiseState变为rejected，则调用then的第二个回调来返回数据。</p><h3 id="promise解决回调地狱"><a href="#promise解决回调地狱" class="headerlink" title="promise解决回调地狱"></a>promise解决回调地狱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">7</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>result+<span class="number">8</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对promise进行链式调用时，后边的方法（then和catch）读取的上一步的执行结果，如果上一步的执行结果不是当前想要的结果，则跳过当前的方法。当promise出现异常时，而整个调用链中没有出现catch,则异常会向外抛出。</p><h3 id="promise的静态方法"><a href="#promise的静态方法" class="headerlink" title="promise的静态方法"></a>promise的静态方法</h3><ul><li>Promise.resolve() 创建一个立即完成的promise，相当于下图代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>Promise.reject() 创建一个立即拒绝的promise</li><li>Promise.all([…]) 同时返回多个promise的执行结果，其中有一个错就返回错误</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">sum</span>(<span class="number">123</span>,<span class="number">456</span>),<span class="title function_">sum</span>(<span class="number">5</span>,<span class="number">6</span>),<span class="title function_">sum</span>(<span class="number">3</span>,<span class="number">4</span>)])</span><br></pre></td></tr></table></figure><ul><li>Promise.allSettled([…]) 同时返回多个promise的执行结果，无论成功或失败，都会返回</li><li>Promise.race([…]) 返回执行最快的promise，不考虑对错</li><li>Promise.any([…]) 返回执行最快的成功的promise，若全报错，则报错</li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是单线程的，运行机制遵循事件循环机制（event loop）</p><p>调用栈：</p><ul><li>栈是一种数据结构，先进后出</li><li>调用栈中放的是要执行的代码<br>任务队列</li><li>队列是一种数据结构，先进先出</li><li>任务队列中放的是要执行的代码<br>当调用栈中的代码执行完以后，队列中的代码才会按照顺序依次引入到栈中执行</li></ul><p>JS中任务队列有两种</p><ul><li>宏任务队列（大部分代码都去宏任务队列中去排队）</li><li>微任务队列（Promise的回调函数（then、catch、finally））</li></ul><p>整个流程：</p><ol><li>执行调用栈中的代码</li><li>执行微任务队列中的任务</li><li>执行宏任务队列中的任务</li></ol><p>queueMicrotask()用来向微任务队列中添加一个任务</p><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>通过async可以创建一个异步函数，异步函数的返回值会自动封装到一个promise中返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">111</span>,<span class="number">222</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br></pre></td></tr></table></figure><p>通过await调用异步函数时，会暂停代码的运行，直到异步代码有结果时，才会将结果返回。（只阻塞异步函数内部的代码，不影响外部的，但是一般情况下await函数之后的代码会依赖await的结果，所以阻塞不影响）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(a+b))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4,33,1,2,3</span></span><br></pre></td></tr></table></figure><p>注意！await只能用于async声明的异步函数中，或es模块的顶级作用域中（.mjs文件或者script标签里有type:module）。通过await调用异步函数时，需要通过try-catch来处理异常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">sum</span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果async声明的函数中没有写await，那么async里的代码会依次执行</p><p>注意以下代码的运行顺序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(a+b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>).<span class="title function_">then</span>(<span class="function"><span class="params">r</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(r))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出1,2,3</span></span><br></pre></td></tr></table></figure><p>await也可以加在同步代码的前面,当使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕后被放到微任务队列中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">s</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出1,2,4,3</span></span><br></pre></td></tr></table></figure><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><p>早期的网页中，是没有一个实质的模块化规范的，实现模块化的方式，就是通过最原始的通过script标签来引入多个js文件。<br>问题：</p><ol><li>无法选择要引入模块的哪些内容</li><li>在复杂的场景下容易出错</li></ol><p>在node中，默认支持的模块化规范叫做CommonJS，在CommonJS中，一个js文件就是一个模块。<br>引入模块：</p><ul><li>使用require（“模块的路径”）函数引入模块</li><li>引入自定义模块时，模块名要以./或者../开头</li><li>扩展名可以省略，node会自动为js文件补全扩展名，如果没有js，会寻找json文件</li></ul><p>在定义模块时，模块中的内容默认是不能被外部看到的。可以通过exports来设置向外暴露的内容。在其他模块中引入当前模块时，require函数返回的就是exports，可以将希望暴露给外部模块的内容设置为exports的属性。</p><p>访问exports的方式有着两种：</p><ul><li>exports</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li>module.exports</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入核心模块（node自带的模块）时，直接写核心模块的名字即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，Node.js会将以下内容视为CommonJS模块：<br>1 使用.cjs为扩展名的文件<br>2 当前的package.json的type属性为commonjs时，扩展名为js的文件（不重要）<br>3 当前的package.json不包含type属性时，扩展名为js的文件（不重要）<br>4 文件的扩展名为mjs、cjs、json、node、js以外的值时（type不是module时）（不重要）</p><h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>默认情况下，node中的模块化标准是commonjs。要想使用ES的模块化，可以采用以下两种方案</p><ul><li>使用.mjs作为扩展名</li><li>在package.json在配置”type”:”module”，则当前项目下所有的js文件都默认为es module。</li></ul><p>向外部导出内容：export</p><p>导入内容：</p><ul><li>import {变量名} as 别名 from “url”  es模块不能省略扩展名（官方标准）变量名必须和暴露内容的变量名相同</li></ul><p>export default：用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面不用加大括号，因为只可能唯一对应export default命令</p><p>导入：</p><ul><li>import 变量名 from “url” 变量名可以随意命名</li></ul><p>es模块都运行在严格模式下</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是node 中的内置模块，可以在node中直接使用</p><p>window是浏览器的宿主对象；global是node的全局对象，作用类似于window。ES标准下，全局对象的标准名应该是globalThis。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>process表示当前的node进程，通过该对象可以获取进程的信息，或者对进程做各种操作</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>1 process是一个全局变量，可以直接使用<br>2 有哪些属性和方法：</p><ul><li>process.exit()  结束当前进程</li><li>process.nextTick(callback[…args])  将函数插入到tick队列中，调用栈 -&gt; tick队列 -&gt; 微任务队列 -&gt; 宏任务队列</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span> (<span class="string">&quot;process&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//输出4、3、2、1</span></span><br></pre></td></tr></table></figure><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>通过path可以获取路径</p><p>path.resolve([…paths])用来生成一个绝对路径。<strong>注意</strong>同步不同方式执行代码的时候，工作目录有可能不同<br>如果直接调用（不传参），则返回当前的工作目录<br>如果将一个相对路径作为参数调用，则会将其转为绝对路径</p><p>工作目录不同，所产生的绝对路径也就不同</p><p>最终形态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./05.promise.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><h4 id="fs-file-system"><a href="#fs-file-system" class="headerlink" title="fs (file system)"></a>fs (file system)</h4><p>用来帮助node 来操作磁盘中的文件，文件操作也就是所谓的I/O操作</p><ul><li>fs.readFileSync  同步的读取文件的方法，会阻塞后边的代码的执行<br>（当通过fs模块读取磁盘中的数据时，读取到的数据总会以buffer对象的形式返回，buffer是一个临时用来存储数据的缓冲区）</li><li>fs.readFile()，异步的文件读取方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(</span><br><span class="line">    path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>),</span><br><span class="line">    <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>主流用法：promise版本的fs</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span> (<span class="string">&quot;fs/promises&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span> (<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./hello.txt&quot;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>())</span><br><span class="line">&#125;,)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node中的包管理器，npm是世界上最大的包管理库</p><p>npm init 初始化项目，创建package.json文件（需要回答问题）</p><p>npm init -y 初始化项目，创建package.json文件（所有值采用默认值）</p><p>npm install 包名 将指定包下载到当前项目中<br>install时发生了什么？</p><ul><li>将包下载到当前项目的node_modules目录下</li><li>会在package.json的dependencies属性中添加一个新属性<br>“lodash”: “^4.17.21”(^:4版本下的最新版本；~：4.17版本下的最新版本）</li><li>会自动添加package-lock.json文件：加速npm下载的，不用动</li></ul><p>npm i 自动安装所有依赖</p><p>npm install 包名 -g 全局安装（将包安装到计算机中，通常是一些工具）</p><p>npm uninstall 包名  卸载  若是全局安装，卸载时也要加 -g</p><p>npm镜像：<br>npm的仓库的服务器位于国外，存在网络问题，为了解决这个问题，可以在npm中配置一个镜像服务器</p><p>镜像的配置：</p><ul><li>(不推荐)在系统中安装cnpm:npm install -g cnpm –registry=<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>（推荐）彻底修改npm仓库地址：npm set registry <a href="https://registry.npmmirror.com（还是使用npm命令，若要还原：npm">https://registry.npmmirror.com（还是使用npm命令，若要还原：npm</a> config delete registry）</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件：node中通过该对项目进行描述，每个node项目必须有该文件</p><p>package.json中的scripts:可以自定义一些命令，定义以后可以直接通过npm来执行。start和test 可以通过 npm  start 和 npm test 执行，其他命令需要通过npm run xxx执行</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络的服务器基于请求和响应</p><p><a href="https://space.bilibili.com/1500126264">b站</a></p><p>https://  协议名<br>space.bilibili.com 域名<br>/1500126264 网络资源路径</p><p>整个网络中存在着无数个服务器，每一个服务器都有自己唯一标识，这个标识被称为ip地址 192.168.1.18，但是ip地址不方便记忆，域名就相当于是ip地址的别名。</p><h3 id="当在浏览器中输入地址以后发生了什么？"><a href="#当在浏览器中输入地址以后发生了什么？" class="headerlink" title="当在浏览器中输入地址以后发生了什么？"></a>当在浏览器中输入地址以后发生了什么？</h3><p>1 DNS（电话本）解析，获取网站的ip地址（电话号码）<br>2 浏览器需要和服务器建立连接（tcp/ip）（拨号）（三次握手）<br>3 向服务器发送请求（http协议）<br>4 服务器处理请求，并返回响应（http协议）<br>5 浏览器将响应的页面渲染<br>6 断开和服务器的连接（四次挥手）</p><p>第二步中客户端如何和服务器建立（断开）连接</p><p>答：<br>三次握手（建立连接）</p><ul><li>客户端发送请求连接（SYN:同步）</li><li>服务器收到连接请求，向客户端返回消息（SYN ACK：同意）</li><li>客户端向服务器发送同意连接的信息（ACK：同意）</li></ul><p>四次挥手（断开连接）</p><ul><li>客户端向服务器发送请求，通知服务器数据发送完毕，请求断开连接（FIN：finally）</li><li>服务器向客户端返回数据，知道了（ACK）</li><li>服务器向客户端返回数据，收完了，可以断开连接（FIN,ACK）</li><li>客户端向服务器发数据，可以断开了（ACK）</li></ul><p>请求和响应实际上就是一段数据，只不过需要遵循特殊的格式，这个格式由http协议规定</p><p>TCP/IP协议族：规定了互联网中所有的通信细节</p><p>网络通信的过程由四层组成</p><ul><li>应用层<br>软件层面，浏览器、服务器都属于应用层</li><li>传输层<br>负责对数据进行拆分，把大数据拆分为一个一个小包</li><li>网络层<br>负责给数据包，添加信息</li><li>数据链路层<br>传输信息</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是应用层的协议，用来规定客户端和服务器通信的报文格式的（请求字符串是明文，不安全）</p><h3 id="请求报文（request）"><a href="#请求报文（request）" class="headerlink" title="请求报文（request）"></a>请求报文（request）</h3><p>客户端发送给服务器的报文称为请求报文</p><p>请求报文的格式：</p><ul><li>请求首行<br>第一部分  get/post：get请求主要用来向服务器请求资源，没有请求体，键值对为明文，安全性差，且不能发送较大的数据；post请求主要用来向服务器发送数据，post请求有请求体，无法在地址栏直接查看，安全性较好，请求体大小没有限制，可以发送任意大小的数据，所以尽量用post发送请求<br>第二部分  请求资源的路径，多个名值对用&amp;连接<br>第三部分  http协议版本</li><li>请求头<br>请求头也是名值对结构，用来告诉服务器我们浏览器的信息（浏览器可以接受的文件类型、浏览器允许的压缩的编码、浏览器的信息）</li><li>空行<br>用来分隔请求头和请求头</li><li>请求体<br>post请求直接通过请求体发送数据</li></ul><h3 id="响应报文（response）"><a href="#响应报文（response）" class="headerlink" title="响应报文（response）"></a>响应报文（response）</h3><p>服务器发送给客户端的报文称为请求报文</p><ul><li><p>响应首行<br>第一部分  http协议版本<br>第二部分  响应状态码<br>响应状态码的规则：</p><ul><li>1xx  请求处理中</li><li>2xx  请求成功</li><li>3xx  请求重定向</li><li>4xx  客户端错误</li><li>5xx  服务器错误<br>第三部分  对响应状态码的描述</li></ul></li><li><p>响应头<br>也是名值对结构，告诉浏览器响应的信息（响应体的类型、大小等）</p></li><li><p>空行<br>分隔响应头和响应体</p></li><li><p>响应体<br>服务器返回给客户端的内容</p></li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>express是node中的服务器软件，通过express可以快速在node中搭建一个web服务器</p><p>使用步骤：</p><ol><li>创建并初始化项目：npm init -y</li><li>安装express: npm add express</li><li>创建index.js编写代码</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="comment">// 获取服务器的实例（一起皆对象）</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// &quot;/&quot;相当于http://localhost:3000</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// req：请求信息，res:响应信息</span></span><br><span class="line">    <span class="comment">// 在路由中，应该做两件事:读取用户的请求和根据请求返回响应</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello路由&quot;</span>）</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务器(监听端口号)，启动后就可以通过3000端口来访问了</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动“”）</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="nodemon使用"><a href="#nodemon使用" class="headerlink" title="nodemon使用"></a>nodemon使用</h3><p>代码修改后可以自动重启服务器</p><p>使用方式：全局安装</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i nodemon -g</span><br></pre></td></tr></table></figure><p>启动：</p><ul><li>nodemon  运行index.js</li><li>nodemon xxx  运行指定的js</li></ul><h3 id="访问服务器呈现页面"><a href="#访问服务器呈现页面" class="headerlink" title="访问服务器呈现页面"></a>访问服务器呈现页面</h3><p>服务器器中的代码，对于外部来说是不可见的，所以写的html页面，浏览器无法直接访问，需要将页面所在的目录设置为静态资源的目录（public文件夹）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 设置static中间价后，浏览器访问时会自动去public目录寻找是否有匹配的静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./public&quot;</span>)))</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;这是hello1路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已启动&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>在路径中以冒号命名的部分称为param,可以通过req.params获取。param一般不会传递很复杂的参数</p><h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><p>get请求通过req.query获取参数，post通过req.body获取参数</p><p>默认情况下，express不会自动解析请求头，需要通过中间价来为其增加功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入解析请求头的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>())</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="错误路由"><a href="#错误路由" class="headerlink" title="错误路由"></a>错误路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有路由后边配置错误路由</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">404</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;您访问的地址已被劫持&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h4><p>ejs是node中的一款模板引擎长得像个网页，可以嵌入变量</p><p>使用步骤：</p><ol><li>安装ejs</li><li>配置express的模板引擎为ejs</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将ejs设置为默认的模板引擎</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&quot;view engine&quot;</span>,<span class="string">&quot;ejs&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>模板引擎需要被express渲染后才能使用,res.render()用来渲染一个模板引擎，并将其返回给浏览器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/students&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&quot;students&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是express中创建的一个对象,实际上是一个中间件，可以在该中间件上绑定各种路由以及其他的中间件（便于管理）</p><p>新建routes文件夹，在该文件夹下存放各种路由数据的文件，再在服务器的主文件中引入使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;./list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hell0,我是list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&quot;./routes/user&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP协议是一个无状态的协议，服务器无法区分请求是否发送自同一个客户端</p><p>cookie是HTTP协议中用来解决无状态问题的技术，本质就是一个头，服务器以响应头的形式将cookie发送给客户端，客户端收到后会将其存储，并在下次向服务器发送请求时将其传回，这样服务器就可以根据cookie来识别出客户端</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cookie解析</span></span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/hello&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 将用户名放入cookie</span></span><br><span class="line">        res.<span class="title function_">cookie</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">cookie</span>.<span class="property">username</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>cookie的不足：<br>cookie是由服务器创建，浏览器保存，每次浏览器访问服务器时都需要将cookie发回，这就导致我们不能在cookie存放较多的数据，并且cookie是直接存储在客户端，容易被篡改盗用，不能存储敏感数据</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>为了解决cookie的不足，希望可以将每个用户的数据都有一个对应的id，只需要通过cookie将id发送给浏览器，浏览器每次访问只需将id发回，即可读取到服务器中的数据。</p><p>session是服务器中的一个对象，这个对象用来存储用户的数据，每一个session对象都有一个唯一的id，会通过cookie的形式发送给客户端，客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入session</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>)</span><br><span class="line"><span class="comment">// 设置session中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>:<span class="string">&quot;dazhaxie&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(username === <span class="string">&quot;admin&quot;</span> &amp;&amp; password === <span class="string">&quot;123123&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 登录成功后，将用户名放入session，这里仅仅是添加到了内存中的session，而没有写入文件中</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="property">loginUser</span> = username</span><br><span class="line">        <span class="comment">// 为了使得session可以立刻存储</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="title function_">save</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            res.<span class="title function_">redirect</span>(<span class="string">&quot;/students/list&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello路由&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//session的默认有效期是一次会话</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">loginUser</span>)&#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&quot;stuents&quot;</span>,&#123;<span class="attr">stus</span>:<span class="variable constant_">STU</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">redirect</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商城项目</title>
      <link href="/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/03/10/%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><p>node_modules文件夹：项目依赖文件夹</p><p>public文件夹：一般放置一些静态资源（图片）。值得注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动的打包到dist文件夹中。</p><p>src文件夹</p><ul><li>api文件夹：发送请求的配置</li><li>assets文件夹：一般用于存放静态资源（放置多个组件共用的静态资源），值得注意，放在assets文件夹里的静态资源，在webpack打包的时候，webpack会把静态资源当做一个模块，打包到JS文件里面。</li><li>components文件夹：一般放置非路由组件（全局组件）</li><li>pages文件夹：存放路由相关组件（pages也可换成views）</li><li>router文件夹：路由配置文件</li><li>store文件夹：vuex相关文件</li><li>mock文件夹：存放mock模拟数据</li><li>App.vue：唯一的根组件（汇总所有组件）</li><li>main.js：入口文件，也是整个程序当中最先执行的文件</li><li>.gitignore:git版本管制忽略的配置（一般不碰）</li><li>babel.config.js：babel的配置文件（相当于翻译官，比如把ES6相关语法翻译为ES5，兼容性更好，一般不碰）</li><li>package.json：应用包配置文件（类似于项目身份证，记录着项目名称、项目依赖、项目运行等信息）</li><li>package-lock.json：包版本控制文件（缓存性文件）</li><li>README.md：应用描述文件（说明性文件）</li><li>vue.config.js：可以对脚手架进行个性化定制，如何配置可以参考Vue CLI</li></ul><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="comment">// 注册路由:组件身上都有$route、$router属性</span></span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 注册仓库:组件身上有$store属性</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="comment">// 配置全局事件总线</span></span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$API</span>=<span class="variable constant_">API</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>main.js是入口文件，所有全局组件在该文件中引入</p><h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Header</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 路由组件出口 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 在Home、Search显示，在登录、注册隐藏 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Footer</span> <span class="attr">v-show</span>=<span class="string">&quot;$route.meta.show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Header、Footer是非路由组件，路由组件将展示在 <code>&lt;router-view&gt;&lt;/router-view&gt;</code>的位置。</p><p>Footer组件在某些路由组件展示时要隐藏掉，就可以在路由配置中增加meta属性进行控制。</p><h2 id="router文件夹"><a href="#router文件夹" class="headerlink" title="router文件夹"></a>router文件夹</h2><h3 id="routes-js"><a href="#routes-js" class="headerlink" title="routes.js"></a>routes.js</h3><p>该文件用来配置路由信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span>=(<span class="params"></span>)=&gt;<span class="keyword">import</span> (<span class="string">&#x27;@/pages/Home&#x27;</span>) <span class="comment">//路由懒加载写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Search</span> <span class="keyword">from</span> <span class="string">&quot;../pages/Search&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: foo,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Search</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;search&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: <span class="literal">true</span></span><br><span class="line">    &#125;，</span><br><span class="line"><span class="comment">// 重定向，项目运行的时候，首先定位到首页</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/trade&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Trade</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 路由独享守卫</span></span><br><span class="line">    <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 去交易页面，必须是从购物车来的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&quot;/shopcart&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><blockquote><p>学习Vue的时候，各类教程都会告诉我们：Vue 的特点是SPA—— <strong>Single Page Application</strong> （单页应用程序）。</p><p>它有着诸如：“只有第一次会加载页面, 以后的每次页面切换，只需要进行组件替换；减少了请求体积，加快页面响应速度，降低了对服务器的压力” 等等优点。</p><p>但是呢！因为Vue 是SPA，所以首页第一次加载时会把所有的组件以及组件相关的资源全都加载了。</p><p>这样就会导致首页加载时加载了许多首页用不上的资源，造成网站首页打开速度变慢的问题，降低用户体验。</p><p>为了解决上面问题，我们需要对Vue实现组件懒加载（按需加载）。</p></blockquote><p>而vue中的路由懒加载其实是利用了webpack的异步加载的方法。</p><p>我们都知道webpack会整合所有的资源，将其打入一个包内。但是要实现懒加载，我们肯定不能让子组件被整合进一个包里头。所以需要解决的问题就是如何将子组件单独打包成一个文件，在我们需要用到他的时候去加载。</p><p>首先解决第一个问题，如何将子组件打包成一个单独的文件。</p><p>在webpack中提供了一个import方法给我们，注意是方法，而不是我们经常使用的那个import。</p><p>正常的引入文件我们会这样做</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">&#x27;./js/count&#x27;</span> <span class="comment">//同步加载</span></span><br></pre></td></tr></table></figure><p>而这样的写法就是大家所说的同步引入，他是会被打进一个文件内的。<br>使用import方法，就可以做到异步引入，从而使被引入的文件单独被打包。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;count&quot; */</span>  <span class="string">&#x27;./js/count&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样就会使这个count.js被单独打包成一个文件了</p><p><img src="1.jpg" alt="1684379436196"></p><p>被单独打包的文件默认会使用文件的路径作为文件名。</p><p>在webpack配置中我们还需要这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//所有文件的输出路径</span></span><br><span class="line">        <span class="comment">//__dirname: nodejs的变量，代表当前文件的文件夹目录</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),<span class="comment">//绝对路径</span></span><br><span class="line">        <span class="comment">//文件名</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        <span class="comment">//代码块的文件名</span></span><br><span class="line">        <span class="attr">chunkFilename</span>:<span class="string">&quot;[name].chunk.js&quot;</span>,  这里的name就是上面的webpackChunkName</span><br><span class="line">        <span class="attr">clean</span>:<span class="literal">true</span> <span class="comment">//自动删除上次打包的结果</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>/* webpackChunkName: “count” */这一行注释就是为了修改打包出来的文件名的  count就是文件名。</p><p>这样我们就实现了一个将文件单独打包的功能。</p><p>当然离懒加载还差一点。</p><p>虽然上文中我们做到了异步加载，并且也将文件单独打包了，但是如果单纯这样做的话资源还是会被一起加载。细心的同学可能已经发现了，在vue中我们通常会给需要懒加载的路由这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">() =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;con&quot; */</span> <span class="string">&#x27;./xxx.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>没错，这里就是利用了函数只有被调用才会执行的特性。将组件的component属性赋值一个函数，在函数中去异步引入组件。这样才是一个完整的路由懒加载方案。</p><h4 id="props-路由传递参数-："><a href="#props-路由传递参数-：" class="headerlink" title="props(路由传递参数)："></a>props(路由传递参数)：</h4><p><strong>props分为三种形式</strong></p><ul><li>props为对象</li><li>props为布尔值，这种只能接收params动态路由的参数</li><li>props为函数，可以接收query和params参数(推荐)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="attr">addr</span>:<span class="string">&#x27;河南省信阳市商城县李集乡新庄村&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/detail/:id/:title&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">    <span class="comment">// props是个布尔值</span></span><br><span class="line">    <span class="comment">// props:true,</span></span><br><span class="line">    <span class="title function_">props</span>(<span class="params">$route</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">id</span>:$route.<span class="property">params</span>.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">title</span>:$route.<span class="property">params</span>.<span class="property">title</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;detail&quot; */</span> <span class="string">&#x27;../views/Detail.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;hash&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题"><a href="#vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题" class="headerlink" title="vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题"></a>vue路由传参的三种方式以及解决vue路由传参页面刷新参数丢失问题</h4><p>项目中涉及到跨页面传参数和后台进行数据交互，看到需求之后第一反应就是用路由传参来解决；Vue中给我们提供了三种路由传参方式，下面我们一个一个的来看一下:</p><p><strong>方法一：params传参</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/child&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过params传递参数，如果我们想获取id的参数值，我们可以通过 <code>this.$route.params.id</code>这种方式来打印出来就可以得到了；（注意：获取参数的时候是 <code>$route</code>，跳转和传参的时候是 <code>$router</code>）</p><blockquote><p>传参时params要与name配合使用，query没有这种要求</p></blockquote><p><strong>方法二：路由属性配置传参</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/child/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/child/$&#123;id&#125;&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过路由属性配置传参我们可以用 <code>this.$route.params.id</code>来获取到id的值，注意this.$router.push方法里面路径带的是值，路由配置项那里带的是变量名(属性名)来实现的对应；</p><p>以上两种传参方式基本上可以理解为ajax中的post请求方式，参数都是不可见的，但是上面两种方法都有一个弊端，就是当页面刷新了是获取不到参数值的，那么有没有一种方法是页面刷新之后参数依然存在呢？</p><p>方法三：query传参</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/child&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure><p>第三种方式是用query来传参，这种方式是可以解决页面刷新参数消失问题的，这种方式可以理解为是ajax中的get方法，参数是直接在url后面添加的，参数是可见的，所以解决页面刷新参数消失问题建议使用方法三来解决；</p><p>其实解决页面刷新参数丢失问题的方案还有很多，比如把参数存在sessionStorange或者localStorange中都是可行的，不过我们既然用vue框架，就要用vue的方式来解决问题。这里只是想告诉大家，问题的解决方案可以多种多样，要学会用多种方式或者说多种方案来解决一个问题，不要有太多的局限性！</p><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><h4 id="重写push、replace方法"><a href="#重写push、replace方法" class="headerlink" title="重写push、replace方法"></a>重写push、replace方法</h4><p><strong>编程式导航</strong>路由跳转到 <strong>当前路由</strong> , 多次执行会抛出**NavigationDuplicated **的警告错误。</p><blockquote><p>注意:编程式导航（push|replace）才会有这种情况的异常， <strong>声明式导航是没有这种问题</strong> ，因为声明式导航内部已经解决这种问题。</p></blockquote><p>这种异常，对于程序没有任何影响的。 但为什么会出现这种现象？</p><p>由于vue-router最新版本3.5.2，引入了promise，当传递参数多次且重复，会抛出异常，因此出现上面现象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写push||replace方法</span></span><br><span class="line"><span class="keyword">let</span> originPush = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>;</span><br><span class="line"><span class="keyword">let</span> originReplace = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">        <span class="comment">// 保证上下文仍是VueRouter的实例</span></span><br><span class="line">        originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">        <span class="comment">// 保证上下文仍是VueRouter的实例</span></span><br><span class="line">        originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    <span class="comment">// 滚动行为</span></span><br><span class="line">    <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入页面时始终滚动到顶部</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="设置全局路由守卫"><a href="#设置全局路由守卫" class="headerlink" title="设置全局路由守卫"></a>设置全局路由守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫（路由跳转之前进行判断）</span></span><br><span class="line"><span class="comment">//登录后不能再进登录界面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span></span><br><span class="line">    <span class="keyword">let</span> token = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>;</span><br><span class="line">    <span class="keyword">let</span> name = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//如果登录了</span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还要去登录界面</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name)&#123;</span><br><span class="line">                <span class="comment">// 如果有用户信息</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;getUserInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//token失效了，获取不到用户信息，重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;userLogout&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未登录，不能去交易相关的页面，若要去先登录</span></span><br><span class="line">        <span class="keyword">let</span> toPath=to.<span class="property">path</span></span><br><span class="line">        <span class="keyword">if</span>(toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./trade&#x27;</span>)!=-<span class="number">1</span> || toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./pay&#x27;</span>)!=-<span class="number">1</span>||toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;/center&#x27;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login?redirect=&#x27;</span>+toPath)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="store文件夹"><a href="#store文件夹" class="headerlink" title="store文件夹"></a>store文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store</span><br><span class="line">  detail.js</span><br><span class="line">  home.js</span><br><span class="line">  search.js</span><br><span class="line">  shopcart.js</span><br><span class="line">  trade.js</span><br><span class="line">  user.js</span><br><span class="line">  index.js</span><br></pre></td></tr></table></figure><h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&#x27;./home&#x27;</span>; <span class="comment">//每个小仓库</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露store类的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">modules</span>:&#123;</span><br><span class="line">        home,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="home-js"><a href="#home-js" class="headerlink" title="home.js"></a>home.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// home的小仓库</span></span><br><span class="line"><span class="keyword">import</span> &#123; reqCategoryList, reqGetBannerList, reqGetFloorList &#125; <span class="keyword">from</span> <span class="string">&quot;@/api&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> state = &#123;  <span class="comment">//存储数据</span></span><br><span class="line">    <span class="comment">// state中数据默认值根据接口返回值初始化的</span></span><br><span class="line">    <span class="attr">categoryList</span>: [],</span><br><span class="line">    <span class="comment">// 轮播图的数据</span></span><br><span class="line">    <span class="attr">bannerList</span>: [],</span><br><span class="line">    <span class="comment">// floor的数据</span></span><br><span class="line">    <span class="attr">floorList</span>: [],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;   <span class="comment">//可以书写业务逻辑或者异步处理</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">categoryList</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">reqCategoryList</span>();</span><br><span class="line">        <span class="comment">// console.log(result)</span></span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">code</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="title function_">commit</span>(<span class="string">&quot;CATEGORYLIST&quot;</span>, result.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;   <span class="comment">//修改state的唯一手段</span></span><br><span class="line">    <span class="title function_">CATEGORYLIST</span>(<span class="params">state, categoryList</span>) &#123;</span><br><span class="line">        state.<span class="property">categoryList</span> = categoryList;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">GETBANNERLIST</span>(<span class="params">state, bannerList</span>) &#123;</span><br><span class="line">        state.<span class="property">bannerList</span> = bannerList;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">GETFLOORLIST</span>(<span class="params">state, floorList</span>) &#123;</span><br><span class="line">        state.<span class="property">floorList</span> = floorList;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 理解为计算属性，用于简化仓库数据，让组件获取仓库数据更加方便</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state,</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="api文件夹"><a href="#api文件夹" class="headerlink" title="api文件夹"></a>api文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api</span><br><span class="line">  ajax.js</span><br><span class="line">  index.js</span><br><span class="line">  mockAjax.js</span><br></pre></td></tr></table></figure><h3 id="ajax-js-二次封装axios"><a href="#ajax-js-二次封装axios" class="headerlink" title="ajax.js(二次封装axios)"></a>ajax.js(二次封装axios)</h3><p>封装了什么？</p><ol><li>基础路径，请求超时时间</li><li>请求拦截器<br>如果有token,把token放入请求头<br>进度条开始</li><li>响应拦截器<br>进度条结束</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对axios进行二次封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="comment">// 引入进度条</span></span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&quot;nprogress&quot;</span>;</span><br><span class="line"><span class="comment">// 引入进度条的样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="comment">// 利用axios对象的方法create创建axios的实例</span></span><br><span class="line"><span class="comment">// request就是axios，只不过稍微配置一下</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// 基础路径，发请求的时候，路径中会出现/api</span></span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&quot;/api&quot;</span>,</span><br><span class="line">    <span class="comment">// 请求超时的时间</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截器：在发请求之前，请求拦截器可以检测到，可以在请求发出去之前做一些事</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(store.<span class="property">state</span>.<span class="property">detail</span>.<span class="property">uuid_token</span>)&#123;</span><br><span class="line">        <span class="comment">// 请求头添加一个字段userTempId</span></span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">userTempId</span> = store.<span class="property">state</span>.<span class="property">detail</span>.<span class="property">uuid_token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要携带token给服务器</span></span><br><span class="line">    <span class="keyword">if</span>(store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>)</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">token</span>=store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进度条开始动</span></span><br><span class="line">    nprogress.<span class="title function_">start</span>();</span><br><span class="line">    <span class="comment">// config:配置对象、对象里面有一个属性很重要，headers请求头</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 进度条结束</span></span><br><span class="line">    nprogress.<span class="title function_">done</span>();</span><br><span class="line">    <span class="comment">// 成功的回调函数:服务器相应数据回来后，响应拦截器可以检测到</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;faile&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> requests</span><br></pre></td></tr></table></figure><h3 id="index-js-2"><a href="#index-js-2" class="headerlink" title="index.js"></a>index.js</h3><p>API统一管理</p><h2 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mock</span><br><span class="line">  banner.json</span><br><span class="line">  floor.json</span><br><span class="line">  mockServe.js</span><br></pre></td></tr></table></figure><h3 id="mockServe-js"><a href="#mockServe-js" class="headerlink" title="mockServe.js"></a>mockServe.js</h3><p>创建接口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mockjs模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Mock</span> <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入JSON格式数据(webpack默认对外暴露图片、JSON数据格式)</span></span><br><span class="line"><span class="keyword">import</span> banner <span class="keyword">from</span> <span class="string">&#x27;./banner.json&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> floor <span class="keyword">from</span> <span class="string">&#x27;./floor.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock数据：第一个参数：请求地址；第二个：请求数据</span></span><br><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="string">&quot;/mock/banner&quot;</span>,&#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">data</span>:banner&#125;)<span class="comment">//模拟首页大的轮播图的数据</span></span><br><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="string">&quot;/mock/floor&quot;</span>,&#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">data</span>:floor&#125;)</span><br></pre></td></tr></table></figure><p>在api/mockAjax.js中封装axios方法，配置基础路径为”/mock”</p><p>在api/index.js中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mockRequests <span class="keyword">from</span> <span class="string">&quot;./mockAjax&quot;</span>;</span><br><span class="line"><span class="comment">// 获取home首页轮播图接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">reqGetBannerList</span> = (<span class="params"></span>) =&gt; mockRequests.<span class="title function_">get</span>(<span class="string">&#x27;/banner&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>此项目为在线电商Web App (SPA)，包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块，使用Vue全家桶+ES6++Webpack+Axios等前端热门技术，采用模块化、组件化、工程化的模式开发</p><p>首先为每个单页面编写了html\css的静态页面，使用vue-cli脚手架搭建项目，根据模块将静态页面拆分成静态组件，为每个组件配置路由，建一个router文件夹,专门用来配置路由，在router的总文件中可以设置全局路由守卫，在某个具体的路由配置中可以设置路由独享守卫。组件分为路由组件和非路由组件，放在两个不同的文件夹中，其中非路由组件分为全局组件（三级联动、分页器、轮播图）和非全局组件（header、footer），全局组件在入口文件main.js中引入，可在任意组件中使用。</p><p>用axios发送ajax请求，首先对axios进行二次封装，配置基础路径以及请求超时的时间，另外配置请求拦截器和响应拦截器，同时配置请求进度条。引入vuex插件，在actions中发送请求，将获得的数据存放在state中，组件需要的时候，派发actions捞取数据进行展示，以此实现前后端交互、数据动态展示。</p><p>使用导航守卫实现以下功能：</p><ul><li>只有登陆了, 才能查看交易/支付/个人中心界面</li><li>只有没有登陆, 才能查看登陆界面</li><li>只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面</li><li>只能从购物车界面, 才能跳转到交易界面</li><li>只能从交易界面, 才能跳转到支付界面</li><li>只有从支付界面, 才能跳转到支付成功的界面</li></ul><h3 id="home组件"><a href="#home组件" class="headerlink" title="home组件"></a>home组件</h3><h4 id="三级联动"><a href="#三级联动" class="headerlink" title="三级联动"></a>三级联动</h4><p><strong>静态文件+过渡：</strong></p><p>CSS：确定过渡元素的起始状态、结束状态、过渡事件、过渡规律</p><p>HTML：用 <code>&lt;transation&gt;&lt;transation/&gt;</code> 包裹过渡元素</p><p>JS：绑定鼠标事件</p><p>对于一级列表，在home组件中，初始化v-show=true，在其他组建中初始化v-show=false</p><p>对于二、三级列表，在一级列表的每一项上绑定鼠标移入事件，在绑定函数中传入index，用该条件决定二、三级列表的display样式。</p><p><strong>路由跳转：</strong></p><p>在三级列表中点击某类商品需要跳转路由，如何跳转到对应路由：</p><ol><li>利用事件委派，在一二三级列表的父元素上绑定点击事件</li><li>在每个a标签上添加自定义属性（商品名：判断点击的是否是a标签；商品id：判断点击的是那个a标签），经过判断后再决定路由跳转</li></ol><h3 id="serach组件"><a href="#serach组件" class="headerlink" title="serach组件"></a>serach组件</h3><p>由面包屑区域、商品筛选框、商品列表、分页器组成</p><p>把商品的品牌和属性单独写一个商品筛选的组件，父组件由面包屑、商品筛选、商品详情。当点击品牌值或者属性值时，需要把值传递给父组件，以在面包屑中（此处需要去重）显示。此处涉及子组件给父组件传递信息，用到自定义事件，在父组件中用子组件时绑定自定义事件，子组件中发生点击事件时触发函数。</p><p>同时点击商品值或者属性值后要更新商品筛选组件和商品列表，此处需要在父组件中发送请求，因为发送请求需要带的参数在父组件中。请求获得的数据存放在vuex中，而商品筛选组件所需的数据是从vuex中取，所以会更新商品筛选框。注意：在header的搜索框中输入值点击搜索后，值会作为params参数参与路由跳转到search中，所以在search组件挂载前要将该参数合并到searchParams（发送请求需要带的参数）中</p><p>商品详情处会有综合排序或者价格排序，点击综合时，就按综合属性进行排序，如果原来是升序，就按降序排列，否则反之；点击价格时同理。</p><h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a><strong>分页器</strong></h3><p>点击某一页时，把当前页数放入searchParams（发送请求需要带的参数）中，发送请求获取对应数据</p><p>父向子传递参数：当前页数，每页展示多少条数据、总共有多少条数据、中间的连续页数</p><p>如果当前页为1，则上一页按钮disable</p><p>如果连续页的第一页大于1，则显示第一页</p><p>如果连续页的第一页大于2，则显示省略号</p><p>如果连续页大于总页数，则首页为1，尾页为总页数；否则，连续页的首项为当前页-parseInt(连续页数/2),尾项为当前页+parseInt(连续页数/2)，如果首页小于1，取1，尾页为连续页数；如果尾页大于总页数，取最后一页，首页为总页数-连续页数+1</p><p>如果连续页的尾页小于总页数，则有总页数</p><p>如果连续页的尾页小于总页数-1，则有省略号</p><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><p>手机号：</p><p>验证码：如果有了手机号，带上手机号发送请求，获取验证码</p><p>登录密码：</p><p>确认密码：</p><p>同意协议：</p><p><strong>表单验证:</strong></p><p><strong>注册</strong></p><p>表单验证成功后，带着手机号、验证码、密码向服务器发送请求存储用户数据，并跳转路由到登录页</p><h3 id="登录组件"><a href="#登录组件" class="headerlink" title="登录组件"></a><strong>登录组件</strong></h3><p>携带手机号和密码发送登录请求，服务器会下发一个token，将其本地存储，在请求拦截器中判断是否有token,有则加入请求头中。</p><h3 id="详情组件"><a href="#详情组件" class="headerlink" title="详情组件"></a><strong>详情组件</strong></h3><h3 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a><strong>添加购物车</strong></h3><p>携带商品id和数量向后端发送请求（后台会存储数据），同时将该商品的信息会话存储，跳转到成功添加购物车页面，展示会话存储的信息。从成功添加购物车页面，可以去购物车，进行结算</p><h3 id="放大镜"><a href="#放大镜" class="headerlink" title="放大镜"></a><strong>放大镜</strong></h3><p>放大镜下方有个图片列表，里面为该商品的一些图片，图片列表和放大镜是兄弟组件。在放大镜组件中首先获取兄弟组件中传过来的图片索引，此处用到了全局事件总线。</p><p>布局：图片框设置相对定位，遮罩层和放大的区域的display为none，鼠标移入的时候display为block。遮罩层的宽高都为图片框的一半，放大框和图片框大小相同，但是放大框中图片宽高为图片框中图片的2倍，鼠标移入图片框的时候，获取鼠标的位置，定位遮罩层的位置，同时设置放大框中图片的left和top属性为-2倍</p><h3 id="订单组件"><a href="#订单组件" class="headerlink" title="订单组件"></a><strong>订单组件</strong></h3><p>收件人信息、商品清单、买家留言等部分</p><p>点击去支付，跳转到支付页</p><h3 id="支付组件"><a href="#支付组件" class="headerlink" title="支付组件"></a><strong>支付组件</strong></h3><p>点击立即支付后，弹出二维码支付框（elementui），设置定时器，每过一秒钟获取以下支付信息，如果支付成功，则关闭支付框，跳转到支付成功组件</p><h3 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a><strong>个人中心</strong></h3><h3 id="我的订单"><a href="#我的订单" class="headerlink" title="我的订单"></a><strong>我的订单</strong></h3><h3 id="支付成功组件"><a href="#支付成功组件" class="headerlink" title="支付成功组件"></a><strong>支付成功组件</strong></h3><p>该部分有组件内守卫，如果是从pay组件过来的，放行</p><h2 id="项目中的难点、亮点、挑战"><a href="#项目中的难点、亮点、挑战" class="headerlink" title="项目中的难点、亮点、挑战"></a>项目中的难点、亮点、挑战</h2><ol><li>mock模拟数据</li><li>组件间通信：父组件给子组件传递数据用props、子组件给父组件用自定义事件、兄弟组件间通信用全局事件总线（$bus）(商品详情组件中放大镜组件和图片list组件处使用到)</li><li>编程式路由跳转到当前路径且参数没有变化时, 会抛出NavigationDuplicated的警告错误，是因为编程式导航中引入了promise语法，如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，解决办法，重写push和replace，指定两个空回调</li><li>展示某用户的订单信息：携带token。携带手机号、验证码、密码等数据进行注册请求，注册成功后，服务器会下发token。当携带手机号和密码进行登录请求时，可获取相应的token，在请求拦截器中将token作为一个字段添加到响应头，此后发送的请求都会带着token获取数据。</li><li>防抖、节流：三级联动中，鼠标移入添加背景颜色时，为了防止事件触发过于频繁，此处用了节流。</li></ol><p><strong>重难点</strong></p><h3 id="优化减少组件对象数量：编程式导航代替声明式导航"><a href="#优化减少组件对象数量：编程式导航代替声明式导航" class="headerlink" title="优化减少组件对象数量：编程式导航代替声明式导航"></a>优化减少组件对象数量：编程式导航代替声明式导航</h3><h3 id="合并query参数与搜索框的params参数"><a href="#合并query参数与搜索框的params参数" class="headerlink" title="合并query参数与搜索框的params参数"></a>合并query参数与搜索框的params参数</h3><p>跳转商品详情页时，要合并点击产生的query参数和输入搜索框产生的params参数</p><h3 id="利用事件委托优化时间处理效率"><a href="#利用事件委托优化时间处理效率" class="headerlink" title="利用事件委托优化时间处理效率"></a>利用事件委托优化时间处理效率</h3><p>三级联动处，在三级列表的父元素上绑定点击事件，通过触发事件的目标（父元素）和 <code>&lt;a&gt;</code>标签上的自定义属性判断触发事件的具体目标，跳转到目标的详情页。</p><h3 id="重写Push、replace"><a href="#重写Push、replace" class="headerlink" title="重写Push、replace"></a>重写Push、replace</h3><p>编程式路由跳转到当前路径且参数没有变化时会抛NavigationDuplicated 错误</p><p>原因：vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise</p><p>解决办法：如果没穿成功和失败的回调函数，传两个空函数</p><h3 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h3><p>二次封装即配置基础路径，设置请求超时时间</p><p>另外还可以配置请求拦截器和响应拦截器</p><p>请求拦截器：把token放入请求头、进度条开始</p><p>响应拦截器：进度条结束</p><h3 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h3><p>本项目自创了首页轮播图以及两个floor层的数据，数据为json格式。然后写一个mockserve服务器，引入数据，作为接口的响应数据。同二次封装axios一样封装一个mockajax，将基础路径配置为/mock。</p><p>注：以/api开头的接口在vue.config.js中配置proxy代理</p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><p>项目中在轮播图处使用了，只有循环dom节点更新后才能使用第三方轮播图组件</p><h3 id="路由懒加载-1"><a href="#路由懒加载-1" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ol><li>当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能 <strong>把不同路由对应的组件分割成不同的代码块</strong> ，然后当路由被访问的时候才加载对应组件，这样就更加高效了</li><li>本质就是<strong>Vue 的异步组件</strong>在路由组件上的应用</li><li>需要使用动态import语法, 也就是<strong>import()方法</strong>，webpack的import方法会把组件单独打包，另外，用函数引入组件，实现使用组件时加载。</li></ol><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>history</p><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>编程式路由导航：</p><ul><li>push</li><li>replace</li></ul><h3 id="编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误"><a href="#编程式路由跳转到当前路由-参数不变-会抛出NavigationDuplicated的警告错误" class="headerlink" title="编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误"></a>编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误</h3><p>解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误<br>解决2: 修正Vue原型上的push和replace方法 (优秀)</p><h3 id="如何指定params参数可传可不传"><a href="#如何指定params参数可传可不传" class="headerlink" title="如何指定params参数可传可不传?"></a>如何指定params参数可传可不传?</h3><p>path: ‘/search/:keyword?’</p><h3 id="指定params参数时可不可以用path和params配置的组合"><a href="#指定params参数时可不可以用path和params配置的组合" class="headerlink" title="指定params参数时可不可以用path和params配置的组合?"></a>指定params参数时可不可以用path和params配置的组合?</h3><p>不可以,用path和params配置的组合, 只能用name和params配置的组合<br>query配置可以与path或name进行组合使用</p><h3 id="如果指定name与params配置-但params中数据是一个””-无法跳转"><a href="#如果指定name与params配置-但params中数据是一个””-无法跳转" class="headerlink" title="如果指定name与params配置, 但params中数据是一个””, 无法跳转"></a>如果指定name与params配置, 但params中数据是一个””, 无法跳转</h3><p>解决1: 不指定params<br>解决2: 指定params参数值为undefined</p><h3 id="路由组件能不能传递props数据"><a href="#路由组件能不能传递props数据" class="headerlink" title="路由组件能不能传递props数据?"></a>路由组件能不能传递props数据?</h3><p>可以: 可以将query或且params参数映射/转换成props传递给路由组件对象<br>实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><ol><li>全局守卫：如果没有登录（没有token），则不能去trade\pay\center等页面，到直接去登录界面，同时将要去的页面路径作为重定向的参数传递，待登录后，判断路径中是否有重定向参数，再跳转至重定向页面<br>登录后，如果token过期了，则需要到登录界面重新登录</li><li>支付成功组件用到了组件内守卫，如果是从pay组件过来的，放行</li><li>路由独享守卫：只能从购物车界面跳转到交易界面，只能从交易界面跳转到支付界面</li></ol><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><p>在准备跳转到某个路由组件之前 (在开发中用的比较多)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫（路由跳转之前进行判断）</span></span><br><span class="line"><span class="comment">//登录后不能再进登录界面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//to:要跳转的路由的信息；from：从哪个路由来的；next：放行</span></span><br><span class="line">    <span class="keyword">let</span> token = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">token</span>;</span><br><span class="line">    <span class="keyword">let</span> name = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//如果登录了</span></span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还要去登录界面</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name)&#123;</span><br><span class="line">                <span class="comment">// 如果有用户信息</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;getUserInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//token失效了，获取不到用户信息，重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;userLogout&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未登录，不能去交易相关的页面，若要去先登录</span></span><br><span class="line">        <span class="keyword">let</span> toPath=to.<span class="property">path</span></span><br><span class="line">        <span class="keyword">if</span>(toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./trade&#x27;</span>)!=-<span class="number">1</span> || toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;./pay&#x27;</span>)!=-<span class="number">1</span>||toPath.<span class="title function_">indexOf</span>(<span class="string">&#x27;/center&#x27;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login?redirect=&#x27;</span>+toPath)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>说明:</p><p>to: 目标route;</p><p>from: 起始route;</p><p>next: 放行函数；</p><ul><li>next(): 执行下一个守卫回调, 如果没有跳转到目标路由</li><li>next(false)/不执行: 跳转流程在当前处中断, 不会跳转到目标路由组件</li><li>next(path): 跳转到指定的另一个路由</li></ul><h4 id="全局后置守卫-在跳转到某个路由组件之后"><a href="#全局后置守卫-在跳转到某个路由组件之后" class="headerlink" title="全局后置守卫: 在跳转到某个路由组件之后"></a>全局后置守卫: 在跳转到某个路由组件之后</h4><p>router.afterEach((to, from) =&gt; {})</p><h4 id="路由独享守卫-1"><a href="#路由独享守卫-1" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由独享守卫</span></span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 去交易页面，必须是从购物车来的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">from</span>.<span class="property">path</span> == <span class="string">&quot;/shopcart&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="组件守卫"><a href="#组件守卫" class="headerlink" title="组件守卫"></a>组件守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 组件内守卫</span></span><br><span class="line">    <span class="title function_">beforeRouteEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">      <span class="comment">// 在渲染该组件的路由被confirm前调用</span></span><br><span class="line">      <span class="comment">// 不能获取组件实例this，因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">      <span class="comment">// 但可以通过next(component =&gt; &#123;&#125;), 在回调函数中访问组件对象</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">from</span>.<span class="property">path</span>==<span class="string">&#x27;/pay&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前组件对象将要更新前调用, 可以访问this</span></span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;&#125;,</span><br><span class="line"><span class="comment">// 在当前组件离开前调用, 可以访问this</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">     <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面刷新参数丢失问题"><a href="#页面刷新参数丢失问题" class="headerlink" title="页面刷新参数丢失问题"></a>页面刷新参数丢失问题</h3><p>给url传递query参数，类似于get请求，直接拼接在url后，刷新之后参数不丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 商城项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/02/25/git/"/>
      <url>/2023/02/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是一个免费开源的版本控制系统，有效管理项目开发的源码。<br>解决的问题：</p><ul><li>开发中代码会存在多个版本，将代码在多个版本之间进行切换</li><li>在不影响现行开发工作的情况下对代码进行维护</li><li>开发时，某段代码被多人修改时，处理代码的冲突问题</li></ul><p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。<img src="1.png" alt="1682601512635"></p><p>远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便协同开发。实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。</p><p>学习阶段直接使用一些开放的公共git仓库。目前常用的库有两个：GitHub和Gitee（码云）</p><h2 id="下载和配置"><a href="#下载和配置" class="headerlink" title="下载和配置"></a>下载和配置</h2><p><a href="https://git-scm.com/">Git</a>无脑下载</p><p>下载Git后，首先要配置个人用户名称和电子邮件地址。这两条配置很重要，每次Git提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global [user.name]</span><br><span class="line">git config --global [user.email]</span><br></pre></td></tr></table></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>被git管理的文件有三种状态：</p><ul><li>暂存，表示文件修改已经保存，但是尚未提交到git仓库</li><li>未修改，表示磁盘中的文件与git仓库的文件相同，没有修改</li><li>已修改，表示磁盘中文件已被修改，和git仓库中文件不同</li></ul><p>可以通过git status查看文件的状态</p><p>新添加的文件处于未跟踪状态（未被git管理）:</p><ul><li>未跟踪-&gt;暂存：git add <code>&lt;filename&gt;</code></li><li>暂存-&gt;未修改：git commit -m “xxx” 将暂存的文件存储到仓库中</li><li>未修改-&gt;修改：修改代码后，转为修改状态</li><li>修改-&gt;暂存：git add <code>&lt;filename&gt;</code></li></ul><p>git add *: 将未被跟踪或者已修改的文件全部转换为暂存状态<br>git commit -a -m “xxx”: 提交所有已修改的文件（未跟踪的文件不会提交）</p><h2 id="将文件提交至远程仓库："><a href="#将文件提交至远程仓库：" class="headerlink" title="将文件提交至远程仓库："></a>将文件提交至远程仓库：</h2><ol><li>在总文件夹中右键选择 <code>git bash here</code>，初始化git。</li></ol><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><ol start="2"><li>连接远程仓库</li></ol><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git remote add origin &quot;仓库地址&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>上传文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add &quot;文件名&quot;/git add *  把工作区某个文件提交至暂存区/把工作区所有文件提交至暂存区</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;版本名&quot;  把暂存区文件提交至本地仓库</span><br><span class="line"></span><br><span class="line">$ git push origin master  把本地仓库的文件推送到远程仓库的某一分支上</span><br></pre></td></tr></table></figure><h2 id="从远程仓库下载文件：fork、clone"><a href="#从远程仓库下载文件：fork、clone" class="headerlink" title="从远程仓库下载文件：fork、clone"></a>从远程仓库下载文件：fork、clone</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork包含了原来的仓库所有内容，如分支、Tag、提交</p><p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p><p>执行 <code>clone</code>命令后，会在当前目录下创建一个名为 <code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p><p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p><h3 id="使用fork和clone"><a href="#使用fork和clone" class="headerlink" title="使用fork和clone"></a>使用fork和clone</h3><p>当你在 <code>github</code>发现感兴趣开源项目的时候，可以通过点击 <code>github</code>仓库中右上角 <code>fork</code>标识的按钮，如下图：</p><p><img src="2.png" alt="1682602188024"></p><p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的 <code>github</code>仓库中，而你本地仓库是不会存在任何更改</p><p>然后你就可以通过 <code>git clone</code>对你这个复制的远程仓库进行克隆,在 <code>github</code>中，开源项目右侧存在 <code>code</code>按钮，点击后则会显示开源项目 <code>url</code>信息，如下图所示：通过 <code>git clone xxx</code>则能完成远程项目的下载</p><p><img src="5.png" alt="1682602404998"></p><p>后续更改任何东西都可以在本地完成，如 <code>git add</code>、<code>git commit</code>一系列的操作，然后通过 <code>push</code>命令推到自己的远程仓库</p><p>如果希望对方接受你的修改，可以通过发送 <code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p><p><img src="3.png" alt="1682602282691"></p><p>整体流程如下图：</p><p><img src="4.png" alt="1682602320048"></p><p>fork和clone的区别</p><h3 id="其三者区别如下："><a href="#其三者区别如下：" class="headerlink" title="其三者区别如下："></a>其三者区别如下：</h3><ul><li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li><li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p><code>git</code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p><p><img src="6.png" alt="1682603560111"></p><p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的 <code>git</code>命令</p><h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>一个 <code>git</code>项目的初始有两个途径，分别是：</p><ul><li>git init [project-name]：创建或在当前目录初始化一个git代码库</li><li>git clone url：下载一个项目和它的整个代码历史</li></ul><h4 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h4><p>在日常工作中，代码常用的基本操作如下：</p><ul><li>git init 初始化仓库，默认为 master 分支</li><li>git add . 提交全部文件修改到缓存区</li><li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li><li>git diff 查看当前代码 add后，会 add 哪些内容</li><li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li><li>git status 查看当前分支状态</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li><li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li><li>git commit -v 提交时显示所有diff信息</li><li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li></ul><p>关于提交信息的格式，可以遵循以下的规则：</p><ul><li>feat: 新特性，添加功能</li><li>fix: 修改 bug</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理</li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git在存储文件时，每一次代码的提交都会创建一个与之对应的节点，git就是通过一个一个节点来记录代码的状态。节点会构成树状结构，会存在分支，默认情况下仓库只有一个分支master。在使用git时，可以创建多个分支，分支之间相互独立，在一个分支上修改代码不会影响其它分支。在开发中，创建自己的分支，最终合并到主分支上</p><ul><li>git branch 查看本地所有分支</li><li>git branch -r 查看远程所有分支</li><li>git branch -a 查看本地和远程所有分支</li><li>git merge &lt;分支名&gt; 合并分支</li><li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li><li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li><li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li><li>git branch -D &lt;分支名&gt; 删除本地某个分支</li><li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li><li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li><li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li><li>git checkout &lt;分支名&gt; 切换到本地某个分支</li><li>git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</li><li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li></ul><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><p>远程操作常见的命令：</p><ul><li>git fetch [remote] 下载远程仓库的所有变动</li><li>git remote -v 显示所有远程仓库</li><li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li><li>git fetch 获取线上最新版信息记录，不合并</li><li>git push [remote] [branch] 上传本地指定分支到远程仓库</li><li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li><li>git push [remote] –all 推送所有分支到远程仓库</li></ul><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul><li>git checkout [file] 恢复暂存区的指定文件到工作区</li><li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li><li>git checkout . 恢复暂存区的所有文件到工作区</li><li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li><li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li><li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li><li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li></ul><blockquote><p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p><p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p></blockquote><h4 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h4><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p><ul><li>git stash 暂时将未提交的变化移除</li><li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li><li>git stash list 查看所有储藏中的工作</li><li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li><li>git stash clear 清空所有储藏中的工作</li><li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li></ul><h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p><p>而 <code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p><p>在我们本地的 <code>git</code>文件中对应也存储了 <code>git</code>本地仓库分支的 <code>commit ID</code>和 跟踪的远程分支的 <code>commit ID</code>，对应文件如下：</p><ul><li>.git/refs/head/[本地分支]</li><li>.git/refs/remotes/[正在跟踪的分支]</li></ul><p>使用 <code>git fetch</code>更新代码，本地的库中 <code>master</code>的 <code>commitID</code>不变</p><p>但是与 <code>git</code>上面关联的那个 <code>orign/master</code>的 <code>commit ID</code>发生改变</p><p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过 <code>merge</code>去合并这两个不同的代码版本</p><p><img src="7.png" alt="1682604231981"></p><p>也就是 <code>fetch</code>的时候本地的 <code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地 <code>merge</code>合并这两个版本号的代码</p><p>相比之下，使用 <code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p><p><img src="8.png" alt="1682604272380"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到 <code>git pull</code>或者 <code>git fetch</code>命令</p><p><strong>fetch</strong></p><p>用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例如从远程的 <code>origin</code>仓库的 <code>master</code>分支下载代码到本地并新建一个 <code>temp</code>分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master:temp</span><br></pre></td></tr></table></figure><p>如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来到本地当前分支</p><p>这里 <code>git fetch</code>不会进行合并，执行后需要手动执行 <code>git merge</code>合并，如下：</p><p><strong>pull</strong></p><p>两者的用法十分相似，<code>pull</code>用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例如将远程主机 <code>origin</code>的 <code>master</code>分支拉取过来，与本地的 <code>branchtest</code>分支合并，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure><p>同样如果上述没有冒号，则表示将远程 <code>origin</code>仓库的 <code>master</code>分支拉取下来与本地当前分支合并</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>相同点：</p><ul><li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li></ul><p>不同点：</p><ul><li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge</li><li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li></ul><h2 id="git-rebase-和-git-merge"><a href="#git-rebase-和-git-merge" class="headerlink" title="git rebase 和 git merge"></a>git rebase 和 git merge</h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p><ul><li>git merge</li><li>git rebase</li></ul><p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p><p><strong>git merge</strong></p><p>将当前分支合并到指定分支，命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure><p>通过 <code>git merge</code>将当前分支与 <code>xxx</code>分支合并，产生的新的 <code>commit</code>对象有两个父节点</p><p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p><p>举个例子，<code>bugfix</code>分支是从 <code>master</code>分支分叉出来的，如下所示：</p><p><img src="9.png" alt="1682604971963"></p><p>合并 <code>bugfix</code>分支到 <code>master</code>分支时，如果 <code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含 <code>master</code>分支所有的历史记录</p><p>所以通过把 <code>master</code>分支的位置移动到 <code>bugfix</code>的最新分支上，就完成合并</p><p>如果 <code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="10.png" alt="1682605021939"></p><p>这时候使用 <code>git merge</code>的时候，会生成一个新的提交，并且 <code>master</code>分支的 <code>HEAD</code>会移动到新的分支上，如下：</p><p><img src="11.png" alt="1682605062943"></p><p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p><p><strong>git rebase（变基）</strong></p><p>将当前分支移植到指定分支或指定 <code>commit</code>之上，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>同样，<code>master</code>分支的历史记录在创建 <code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="12.png" alt="1682605154719"></p><p>通过 <code>git rebase</code>，会变成如下情况：</p><p><img src="13.png" alt="1682605189602"></p><p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p><p><img src="14.png" alt="1682605269640"></p><p><code>rebase</code>之后，<code>master</code>的 <code>HEAD</code>位置不变。因此，要合并 <code>master</code>分支和 <code>bugfix</code>分支</p><p><img src="15.png" alt="1682605347300"></p><p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的 <code>B</code></p><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交 <code>X</code>和 <code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p><p>然后将当前分支指向目标最新位置 <code>D</code>, 然后将之前另存为临时文件的修改依序应用</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>从上面可以看到，<code>merge</code>和 <code>rebasea</code>都是合并历史记录，但是各自特性不同：</p><p><strong>merge</strong></p><p>通过 <code>merge</code>合并分支会新增一个 <code>merge commit</code>，然后将两个分支的历史联系起来</p><p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p><p><strong>rebase</strong></p><p><code>rebase</code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p><p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 <code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p><p>解决冲突就是把 <code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p><p><strong>冲突如何产生？</strong></p><p>所谓冲突就是两个开发者对同一个文件同一个位置做出了不同内容的修改，因此就产生了冲突。</p><p>一般冲突的产生发生在两个分支进行合并时或者是从远程仓库拉取代码到本地时。</p><p>但是归根结底，冲突产生的原因还是：对同一个文件同一个位置做出了不同内容的修改。从而导致冲突发生。</p><p><strong>比如：master 分支和 hot-fix 分支上都修改了代码</strong>， 那么在合并分支的时候就会发生冲突。</p><p><code>【第一步】在 hot-fix 分支上增加如下代码，并且提交。</code></p><p><img src="18.png" alt="1685437407135"></p><p><code>【第二步】在master 分支上同样的地方增加如下代码，并且提交。</code></p><p><img src="19.png" alt="1685437413727"></p><p><code>【第三步】 我们现在站在 master 分支上合并 hot-fix 分支， 就会发生代码冲突。</code></p><p><code>【第四步】手动解决冲突，合并代码。</code></p><p><img src="20.png" alt="1685437533173"></p><p>代码冲突就解决了， 提交本地库，查看修改结果：</p><p><img src="21.png" alt="1685437711486"></p><h2 id="git-reset-和-git-revert"><a href="#git-reset-和-git-revert" class="headerlink" title="git reset 和 git revert"></a>git reset 和 git revert</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p><p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p><p><img src="16.png" alt="1682605761698"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p><p><img src="17.png" alt="1682605793002"></p><h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p><p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p><p>两者主要区别如下：</p><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li><li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li></ul><blockquote><p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p><p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p></blockquote><ul><li>如果回退分支的代码以后还需要的情况则使用 <code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用 <code>git reset</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
